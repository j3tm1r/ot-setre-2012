
exe/main.elf:     file format elf32-msp430

SYMBOL TABLE:
00001100 l    d  .text	00000000 .text
00000200 l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
0000012e l       *ABS*	00000000 TA0IV
00000160 l       *ABS*	00000000 TA0CTL
00000170 l       *ABS*	00000000 TA0R
00000162 l       *ABS*	00000000 TA0CCTL0
00000164 l       *ABS*	00000000 TA0CCTL1
00000172 l       *ABS*	00000000 TA0CCR0
00000174 l       *ABS*	00000000 TA0CCR1
00000166 l       *ABS*	00000000 TA0CCTL2
00000176 l       *ABS*	00000000 TA0CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000190 l       *ABS*	00000000 TBR
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000004 l       *ABS*	00000000 ME1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000005 l       *ABS*	00000000 ME2
00000002 l       *ABS*	00000000 PUSH_BYTES
00001130 l       .text	00000000 _branch_to_unexpected_
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 main.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
0000012e l       *ABS*	00000000 TA0IV
00000160 l       *ABS*	00000000 TA0CTL
00000170 l       *ABS*	00000000 TA0R
00000162 l       *ABS*	00000000 TA0CCTL0
00000164 l       *ABS*	00000000 TA0CCTL1
00000172 l       *ABS*	00000000 TA0CCR0
00000174 l       *ABS*	00000000 TA0CCR1
00000166 l       *ABS*	00000000 TA0CCTL2
00000176 l       *ABS*	00000000 TA0CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000190 l       *ABS*	00000000 TBR
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000004 l       *ABS*	00000000 ME1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000005 l       *ABS*	00000000 ME2
000013b0 l       .text	00000000 TA0_ISR
000013e0 l       .text	00000000 L1
000013fc l       .text	00000000 L2
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_core.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001c4c l     F .text	00000028 OS_InitMisc
00001c74 l     F .text	00000042 OS_InitRdyList
00001cea l     F .text	0000006c OS_InitTCBList
00001be2 l     F .text	0000006a OS_InitEventList
00001cb6 l     F .text	00000034 OS_InitTaskIdle
00000000 l    df *ABS*	00000000 os_flag.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00002642 l     F .text	000000fa OS_FlagBlock
000027a6 l     F .text	000000a8 OS_FlagTaskRdy
00000000 l    df *ABS*	00000000 os_mbox.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_mem.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_mutex.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_q.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_sem.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_task.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_time.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Display.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 ServiceOutput.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 GestionMode.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 StatLogger.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 TraitementInput.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 g       *ABS*	00000000 __data_size
00001430 g     F .text	00000010 OSTaskCreateHook
00003fb8 g     F .text	00000084 InitOsc
00001694 g     F .text	00000022 OSIntEnter
000043f4 g     F .text	00000036 setVolume
00001458 g     F .text	00000008 OSTaskStatHook
0000030c g     O .bss	00000001 OSLockNesting
0000030d g     O .bss	00000001 OSRunning
0000413a g     F .text	00000094 SEND_CHAR
00003d02 g     F .text	00000026 printString
00001420 g     F .text	00000008 OSInitHookBegin
0000030e g     O .bss	00000004 OSIdleCtr
00001e9a g     F .text	000001f0 OS_TCBInit
00000312 g     O .bss	00000001 OSPrioHighRdy
00001440 g     F .text	00000010 OSTaskDelHook
0000466e g       .text	00000000 _etext
00003cda g     F .text	00000018 clearDisplay
00001302 g     F .text	00000000 OSStartHighRdy
0000381e g     F .text	0000010a OSTaskCreateExt
00002474 g     F .text	0000002c OSFlagPendGetFlagsRdy
0000208a g     F .text	0000012a OSFlagAccept
00002d86 g     F .text	0000005c OSQFlush
00002bc0 g     F .text	000000c4 OSQAccept
00003742 g     F .text	000000dc OSTaskCreate
00003500 g     F .text	00000242 OSTaskChangePrio
000003a0 g       *ABS*	00000000 __bss_size
00000314 g     O .bss	00000012 OSFlagTbl
0000466c  w      .text	00000000 __stop_progExec__
00001130  w      .text	00000000 vector_ffe0
00004114 g     F .text	00000026 _E
000016b6 g     F .text	000000c2 OSIntExit
00000326 g     O .bss	00000001 OSPrioCur
00003e2e g     F .text	0000018a printDecimal
0000132e g       .text	00000000 OSCtxSw
0000442a g     F .text	000000f2 sendOverSPI
000045aa g     F .text	0000004c GestionMode
00003d4e g     F .text	00000050 printByte
00000328 g     O .bss	00000002 OSTCBList
0000032a g     O .bss	00000001 OSTickStepState
00002f34 g     F .text	000000dc OSQPost
0000284e g     F .text	00000068 OS_FlagUnlink
00001d80 g     F .text	0000003c OS_MemCopy
00001dbc g     F .text	000000a8 OS_Sched
0000032c g     O .bss	00000004 OSCtxSwCtr
000013b0 g       .text	00000000 vector_ffec
00001558 g     F .text	00000008 OSTimeTickHook
00001130  w      .text	00000000 vector_fff0
0000466e g       *ABS*	00000000 __data_load_start
00003382 g     F .text	000000f6 OSSemPend
00001560 g     O .text	00000008 OSMapTbl
00001130 g       .text	00000000 __dtors_end
00001130  w      .text	00000000 vector_fffc
00001548 g     F .text	00000010 OSTCBInitHook
00002a90 g     F .text	00000084 OSMboxPost
00003cc4 g     F .text	00000016 putch
0000273c g     F .text	0000006a OS_FlagInit
00001130  w      .text	00000000 vector_ffe4
000032aa g     F .text	0000005e OSSemAccept
00001380 g       .text	00000000 OSIntCtxSw
00003d28 g     F .text	00000026 HexDigit
00000330 g     O .bss	00000002 OSTCBFreeList
0000ffe0 g     O .vectors	00000020 InterruptVectors
0000451c g     F .text	0000008e ModeStep
00004324 g     F .text	0000007c ServiceOutput
00000202 g     O .bss	00000002 mode
000040d2 g     F .text	00000042 Delayx100us
0000111c  w      .text	00000000 __do_clear_bss
00001d56 g     F .text	0000002a OS_MemClr
00001460 g     F .text	000000e0 OSTaskStkInit
0000191c g     F .text	00000142 OS_EventTaskRdy
00002de2 g     F .text	00000152 OSQPend
000041ce g     F .text	00000094 SEND_CMD
00003a8e g     F .text	00000084 OSTimeDly
00000332 g     O .bss	00000001 OSTaskCtr
00003b12 g     F .text	0000019a OSTimeDlyHMSM
000012ee g       .text	00000000 vector_ffe2
00003478 g     F .text	00000088 OSSemPost
0000124c g       .text	00000000 vector_ffe8
000045f6  w      .text	00000000 _unexpected_
00001130  w      .text	00000000 vector_fffa
00004262 g     F .text	000000c2 InitLCD
00000334 g     O .bss	00000046 OSQTbl
00001100  w      .text	00000000 _reset_vector__
00001130 g       .text	00000000 __ctors_start
0000037a g     O .bss	00000002 OSTCBHighRdy
0000037c g     O .bss	00000002 OSQFreeList
0000110a  w      .text	00000000 __do_copy_data
0000124c g     F .text	000000a2 ButtInterrupt
0000037e g     O .bss	00000001 OSRdyGrp
00000200 g       .bss	00000000 __bss_start
00001130  w      .text	00000000 vector_ffee
00001130  w      .text	00000000 vector_fff4
00000204 g     O .bss	00000002 count_int_me
00001146 g     F .text	00000106 main
00001130  w      .text	00000000 vector_fff8
00001568 g     O .text	00000100 OSUnMapTbl
00000200 g     O .bss	00000002 global_pb_gd
00001130  w      .text	00000000 vector_fff2
000024a0 g     F .text	000001a2 OSFlagPost
00003cac g     F .text	00000018 initDisplay
00001a5e g     F .text	000000b0 OS_EventTaskWait
00001778 g     F .text	00000066 OSStart
00003010 g     F .text	000000e4 OSQPostFront
00000380 g     O .bss	00000003 OSRdyTbl
00010000 g       .vectors	00000000 _vectors_end
00002c84 g     F .text	00000102 OSQCreate
000030f4 g     F .text	0000015c OSQPostOpt
000017de g     F .text	00000132 OSTimeTick
00001130  w      .text	00000000 vector_ffe6
00003308 g     F .text	0000007a OSSemCreate
0000403c g     F .text	00000056 InitPortsDisplay
000021b4 g     F .text	0000008e OSFlagCreate
00000206 g     O .bss	00000002 StkServiceOutput
00000384 g     O .bss	00000002 OSEventFreeList
00003d9e g     F .text	00000090 printHex
00001100  w      .text	00000000 __init_stack
00002242 g     F .text	00000232 OSFlagPend
00000208 g     O .bss	00000002 StkGestionMode
00004092 g     F .text	00000040 Delay
0000020a g     O .bss	00000080 TaskStartStk2
00001428 g     F .text	00000008 OSInitHookEnd
00001130 g       .text	00000000 __dtors_start
00001130 g       .text	00000000 __ctors_end
00004622 g       .text	00000000 __divmodsi4
00000a00 g       *ABS*	00000000 __stack
00002900 g     F .text	00000078 OSMboxCreate
0000141c g     F .text	00000000 OSCPURestoreSR
00000200 g       .text	00000000 _edata
000005a0 g       .bss	00000000 _end
00000386 g     O .bss	00000001 OSIntNesting
0000028a g     O .bss	00000080 TaskStartStk
00001416 g     F .text	00000000 OSCPUSaveSR
00002978 g     F .text	00000118 OSMboxPend
00003928 g     F .text	00000118 OSTaskStkChk
00000388 g     O .bss	00000002 OSTCBCur
000043a0 g     F .text	00000054 setFrequency
000045f8 g       .text	00000000 __udivmodsi4
000028b6 g     F .text	0000004a OSMboxAccept
00001668 g     F .text	0000002c OSInit
00001b0e g     F .text	00000092 OS_EventTO
00003250 g     F .text	0000005a OS_QInit
00001130  w      .text	00000000 vector_fff6
000012ee g     F .text	00000014 TelInterrupt
0000038a g     O .bss	00000080 OSTaskIdleStk
00002b14 g     F .text	000000ac OSMboxPostOpt
00001540 g     F .text	00000008 OSTaskSwHook
0000040a g     O .bss	00000032 OSEventTbl
00001104  w      .text	00000000 __low_level_init
0000043c g     O .bss	00000138 OSTCBTbl
0000112c  w      .text	00000000 __jump_to_main
00003cf2 g     F .text	00000010 gotoSecondLine
00000200 g       .text	00000000 __data_start
00000574 g     O .bss	00000002 OSFlagFreeList
00000576 g     O .bss	0000002a OSTCBPrioTbl
00000120  w      *ABS*	00000000 __WDTCTL
0000030a g     O .bss	00000002 OSISRStkPtr
00001130  w      .text	00000000 vector_ffea
00001910 g     F .text	0000000c OSVersion
00003a40 g     F .text	0000004e OS_TaskStkClr
00001ba0 g     F .text	00000042 OS_EventWaitListInit
00001450 g     F .text	00000008 OSTaskIdleHook
00001e64 g     F .text	00000036 OS_TaskIdle



Disassembly of section .text:

00001100 <__init_stack>:
    1100:	31 40 00 0a 	mov	#2560,	r1	;#0x0a00

00001104 <__low_level_init>:
    1104:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    1108:	20 01 

0000110a <__do_copy_data>:
    110a:	3f 40 00 00 	mov	#0,	r15	;#0x0000
    110e:	0f 93       	tst	r15		
    1110:	05 24       	jz	$+12     	;abs 0x111c
    1112:	2f 83       	decd	r15		
    1114:	9f 4f 6e 46 	mov	18030(r15),512(r15);0x466e(r15), 0x0200(r15)
    1118:	00 02 
    111a:	fb 23       	jnz	$-8      	;abs 0x1112

0000111c <__do_clear_bss>:
    111c:	3f 40 a0 03 	mov	#928,	r15	;#0x03a0
    1120:	0f 93       	tst	r15		
    1122:	04 24       	jz	$+10     	;abs 0x112c
    1124:	1f 83       	dec	r15		
    1126:	cf 43 00 02 	mov.b	#0,	512(r15);r3 As==00, 0x0200(r15)
    112a:	fc 23       	jnz	$-6      	;abs 0x1124

0000112c <__jump_to_main>:
    112c:	30 40 46 11 	br	#0x1146	

00001130 <__ctors_end>:
    1130:	30 40 f6 45 	br	#0x45f6	
    1134:	53 74       	.word	0x7453;	????	Illegal as 2-op instr
    1136:	61 72       	subc.b	#4,	r1	;r2 As==10
    1138:	74 69       	addc.b	@r9+,	r4	
    113a:	6e 67       	addc.b	@r7,	r14	
    113c:	00 53       	add	#0,	r0	;r3 As==00
    113e:	74 61       	addc.b	@r1+,	r4	
    1140:	72 74       	subc.b	@r4+,	r2	
    1142:	20 4f       	br	@r15		
    1144:	53 00       	.word	0x0053;	????	

00001146 <main>:
 *********************************************************************************************************
 *                                                MAIN
 *********************************************************************************************************
 */

int main(void) {
    1146:	31 40 e8 09 	mov	#2536,	r1	;#0x09e8
    114a:	04 41       	mov	r1,	r4	

	WDTCTL = WDTCTL_INIT; //Init watchdog timer
    114c:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    1150:	20 01 

	P6OUT = P1OUT_INIT; //Init output data of port1
    1152:	c2 43 35 00 	mov.b	#0,	&0x0035	;r3 As==00
	P6OUT = P1OUT_INIT; //Init output data of port2
    1156:	c2 43 35 00 	mov.b	#0,	&0x0035	;r3 As==00

	P6SEL = P1SEL_INIT; //Select port or module -function on port1
    115a:	c2 43 37 00 	mov.b	#0,	&0x0037	;r3 As==00
	P6SEL = P2SEL_INIT; //Select port or module -function on port2
    115e:	c2 43 37 00 	mov.b	#0,	&0x0037	;r3 As==00

	P6DIR = P1DIR_INIT; //Init port direction register of port1
    1162:	f2 43 36 00 	mov.b	#-1,	&0x0036	;r3 As==11
	P6DIR = P2DIR_INIT; //Init port direction register of port2
    1166:	f2 43 36 00 	mov.b	#-1,	&0x0036	;r3 As==11

	P1IES = P1IES_INIT; //init port interrupts
    116a:	d2 43 24 00 	mov.b	#1,	&0x0024	;r3 As==01
	P2IES = P2IES_INIT;
    116e:	c2 43 2c 00 	mov.b	#0,	&0x002c	;r3 As==00
	P1IE = ~BIT0;
    1172:	f2 40 fe ff 	mov.b	#-2,	&0x0025	;#0xfffe
    1176:	25 00 
	P2IE = P2IE_INIT;
    1178:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00
// changement au vue de tournier , 3 lignes
	P2SEL = 0;
    117c:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00
	P2OUT = 0;
    1180:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00
	P2DIR = ~BIT0; //only P2.0 is input
    1184:	f2 40 fe ff 	mov.b	#-2,	&0x002a	;#0xfffe
    1188:	2a 00 

	/*Initialisation ineruptions Buttons et Irda*/

	//Pour avoir les pins en interruptions, il faut configurer
	P1SEL = 1; //
    118a:	d2 43 26 00 	mov.b	#1,	&0x0026	;r3 As==01
	P2SEL = 1; // sélection "input/output" (0) au lieu de "périphérique" (1)
    118e:	d2 43 2e 00 	mov.b	#1,	&0x002e	;r3 As==01
	P1DIR = 0x00;
    1192:	c2 43 22 00 	mov.b	#0,	&0x0022	;r3 As==00
	P2DIR = 0x00;
    1196:	c2 43 2a 00 	mov.b	#0,	&0x002a	;r3 As==00
	P1IES = 1;
    119a:	d2 43 24 00 	mov.b	#1,	&0x0024	;r3 As==01
	P2IES = 0; //-> savoir si c'est un front montant (0) ou descendant (1)
    119e:	c2 43 2c 00 	mov.b	#0,	&0x002c	;r3 As==00
	P1IFG = 0;
    11a2:	c2 43 23 00 	mov.b	#0,	&0x0023	;r3 As==00
	P2IFG = 0;
    11a6:	c2 43 2b 00 	mov.b	#0,	&0x002b	;r3 As==00
	//	il faut utiliser eint(); pour enable global interrupt, P1IE = 1 et P2IE = 1
	/*Fin initialisation*/

	eint();
    11aa:	32 d2       	eint			
	InitPortsDisplay();
    11ac:	b0 12 3c 40 	call	#0x403c	
	initDisplay();
    11b0:	b0 12 ac 3c 	call	#0x3cac	
	clearDisplay();
    11b4:	b0 12 da 3c 	call	#0x3cda	
	printString("Starting");
    11b8:	3f 40 34 11 	mov	#4404,	r15	;#0x1134
    11bc:	b0 12 02 3d 	call	#0x3d02	

	WDTCTL = WDTPW + WDTHOLD; /* Disable the watchdog timer   */
    11c0:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    11c4:	20 01 
	//   P6DIR = 0x01;                       /* P1.0 is the only output.     */
	//  P6OUT = 0x00;                       /* P1.0 initially low.          */

	// TIMERA Configuration             /* Configure TIMERA for the system Tick source. */
	//
	TACTL = TASSEL1 + TACLR; /* Clear the Timer and set SMCLK as the source. */
    11c6:	b2 40 04 02 	mov	#516,	&0x0160	;#0x0204
    11ca:	60 01 
	TACTL |= 0x00C0; /* Input divider is /8.  		*/
    11cc:	1f 42 60 01 	mov	&0x0160,r15	
    11d0:	3f d0 c0 00 	bis	#192,	r15	;#0x00c0
    11d4:	82 4f 60 01 	mov	r15,	&0x0160	
	TACCTL0 = CCIE; /* Enable the TACCR0 interrupt. */
    11d8:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    11dc:	62 01 
	TACCR0 = 2304; /* Load the TACCR0 register.    	*/
    11de:	b2 40 00 09 	mov	#2304,	&0x0172	;#0x0900
    11e2:	72 01 

	OSInit(); /* Initialize uC/OS-II                     */
    11e4:	b0 12 68 16 	call	#0x1668	

	/*  P6OUT = 0;*/

	void *CommMsg[10];
	OS_EVENT *msgQServiceOutput = OSQCreate(&CommMsg[0], 10);
    11e8:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    11ec:	0f 44       	mov	r4,	r15	
    11ee:	2f 52       	add	#4,	r15	;r2 As==10
    11f0:	b0 12 84 2c 	call	#0x2c84	
    11f4:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	INT8U prio = 0;
    11f8:	c4 43 00 00 	mov.b	#0,	0(r4)	;r3 As==00, 0x0000(r4)

	OSTaskCreate(GestionMode, (void *) msgQServiceOutput,
    11fc:	3e 40 08 03 	mov	#776,	r14	;#0x0308
    1200:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1204:	6c 44       	mov.b	@r4,	r12	
    1206:	0d 4e       	mov	r14,	r13	
    1208:	0e 4f       	mov	r15,	r14	
    120a:	3f 40 aa 45 	mov	#17834,	r15	;#0x45aa
    120e:	b0 12 42 37 	call	#0x3742	
			&TaskStartStk[TASK_STK_SIZE - 1], prio);

	prio = 5;
    1212:	f4 40 05 00 	mov.b	#5,	0(r4)	;#0x0005, 0x0000(r4)
    1216:	00 00 

	OSTaskCreate(ServiceOutput, (void *) msgQServiceOutput,
    1218:	3e 40 88 02 	mov	#648,	r14	;#0x0288
    121c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1220:	6c 44       	mov.b	@r4,	r12	
    1222:	0d 4e       	mov	r14,	r13	
    1224:	0e 4f       	mov	r15,	r14	
    1226:	3f 40 24 43 	mov	#17188,	r15	;#0x4324
    122a:	b0 12 42 37 	call	#0x3742	
			&TaskStartStk2[TASK_STK_SIZE - 1], prio);
	clearDisplay();
    122e:	b0 12 da 3c 	call	#0x3cda	
	printString("Start OS");
    1232:	3f 40 3d 11 	mov	#4413,	r15	;#0x113d
    1236:	b0 12 02 3d 	call	#0x3d02	
	count_int_me = 0;
    123a:	82 43 04 02 	mov	#0,	&0x0204	;r3 As==00
	OSStart();
    123e:	b0 12 78 17 	call	#0x1778	
	return (0);
    1242:	0f 43       	clr	r15		
}
    1244:	31 50 18 00 	add	#24,	r1	;#0x0018
    1248:	30 40 6c 46 	br	#0x466c	

0000124c <ButtInterrupt>:
 *********************************************************************************************************
 *                                            STARTUP TASK
 *********************************************************************************************************
 */

interrupt (PORT1_VECTOR) ButtInterrupt(void) {
    124c:	0f 12       	push	r15		
    124e:	0e 12       	push	r14		
    1250:	0d 12       	push	r13		
    1252:	0c 12       	push	r12		
    1254:	04 12       	push	r4		
    1256:	31 82       	sub	#8,	r1	;r2 As==11
    1258:	04 41       	mov	r1,	r4	
	INT8U poll = 0;
    125a:	c4 43 03 00 	mov.b	#0,	3(r4)	;r3 As==00, 0x0003(r4)
	uint8_t P4Buffer;
	InputEvent Message;
	OS_CPU_SR cpu_sr = 0;
    125e:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)

	//désactiver les interruptions
	P1IE = 0;
    1262:	c2 43 25 00 	mov.b	#0,	&0x0025	;r3 As==00
	OS_ENTER_CRITICAL(); /*save cpu status register locally end restore it when finished*/
    1266:	b0 12 16 14 	call	#0x1416	
    126a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	//OSIntEnter();

	//remise du sémaphore à 0
	P1IFG = 0;
    126e:	c2 43 23 00 	mov.b	#0,	&0x0023	;r3 As==00
	//récupérer les informations des boutons
	Delayx100us(10);
    1272:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    1276:	0f 43       	clr	r15		
    1278:	b0 12 d2 40 	call	#0x40d2	
	Message.bEvent = 4;
    127c:	a4 42 04 00 	mov	#4,	4(r4)	;r2 As==10, 0x0004(r4)

	//while (Message.bEvent == 4)
	{
		P4Buffer = P4IN;
    1280:	d4 42 1c 00 	mov.b	&0x001c,2(r4)	;0x0002(r4)
    1284:	02 00 
		if (!(P4Buffer & 0x10)) {
    1286:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    128a:	3f f0 10 00 	and	#16,	r15	;#0x0010
    128e:	02 20       	jnz	$+6      	;abs 0x1294
			Message.bEvent = 0;
    1290:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)

		}
		if (!(P4Buffer & 0x20)) {
    1294:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1298:	3f f0 20 00 	and	#32,	r15	;#0x0020
    129c:	02 20       	jnz	$+6      	;abs 0x12a2
			Message.bEvent = 1;
    129e:	94 43 04 00 	mov	#1,	4(r4)	;r3 As==01, 0x0004(r4)

		}
		if (!(P4Buffer & 0x40)) {
    12a2:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    12a6:	3f f0 40 00 	and	#64,	r15	;#0x0040
    12aa:	02 20       	jnz	$+6      	;abs 0x12b0
			Message.bEvent = 2;
    12ac:	a4 43 04 00 	mov	#2,	4(r4)	;r3 As==10, 0x0004(r4)

		}
		if (!(P4Buffer & 0x80)) {
    12b0:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    12b4:	4f 93       	tst.b	r15		
    12b6:	03 38       	jl	$+8      	;abs 0x12be
			Message.bEvent = 3;
    12b8:	b4 40 03 00 	mov	#3,	4(r4)	;#0x0003, 0x0004(r4)
    12bc:	04 00 
		}

		//Pour éviter de rester bloqué en cas d'erreur on incrémente une variable et on la compare avec une valeur arbitraire
		//On assigne une valeur "ERREUR" au message, on pourra le traiter de façon particulière
	}
	clearDisplay();
    12be:	b0 12 da 3c 	call	#0x3cda	
	printDecimal(Message.bEvent);
    12c2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    12c6:	b0 12 2e 3e 	call	#0x3e2e	
	gotoSecondLine();
    12ca:	b0 12 f2 3c 	call	#0x3cf2	
	printByte(P4IN);
    12ce:	5f 42 1c 00 	mov.b	&0x001c,r15	
    12d2:	b0 12 4e 3d 	call	#0x3d4e	

	//todo:les transmettre par MailBox ou MessageQueue au TraitementInput

	//OSIntExit();
	OS_EXIT_CRITICAL();
    12d6:	2f 44       	mov	@r4,	r15	
    12d8:	b0 12 1c 14 	call	#0x141c	
	//réactiver les interruptions
	P1IE = 0xFF;
    12dc:	f2 43 25 00 	mov.b	#-1,	&0x0025	;r3 As==11
}
    12e0:	31 52       	add	#8,	r1	;r2 As==11
    12e2:	34 41       	pop	r4		
    12e4:	3c 41       	pop	r12		
    12e6:	3d 41       	pop	r13		
    12e8:	3e 41       	pop	r14		
    12ea:	3f 41       	pop	r15		
    12ec:	00 13       	reti			

000012ee <TelInterrupt>:

//todo: a finir
interrupt (PORT2_VECTOR) TelInterrupt(void) {
    12ee:	04 12       	push	r4		
    12f0:	04 41       	mov	r1,	r4	
	//désactiver les interruptions
	P2IE = 0;
    12f2:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00

	//remise des sémaphores à 0
	P2IFG = 0;
    12f6:	c2 43 2b 00 	mov.b	#0,	&0x002b	;r3 As==00
	//récupération des infos -> lesquelles et comment? Comment marche la liaison série?

	//transmission par MB ou MQ au traitement input

	//réactiver les interruptions
	P2IE = 1;
    12fa:	d2 43 2d 00 	mov.b	#1,	&0x002d	;r3 As==01
}
    12fe:	34 41       	pop	r4		
    1300:	00 13       	reti			

00001302 <OSStartHighRdy>:

	.global OSStartHighRdy
	.type OSStartHighRdy, @function

OSStartHighRdy:	
            call     #OSTaskSwHook
    1302:	b0 12 40 15 	call	#0x1540	

            mov.b    #1, &OSRunning         /* kernel running */
    1306:	d2 43 0d 03 	mov.b	#1,	&0x030d	;r3 As==01

            mov.w    r1, &OSISRStkPtr       /* save interrupt stack  */            
    130a:	82 41 0a 03 	mov	r1,	&0x030a	

            mov.w    &OSTCBHighRdy, r13     /* load highest ready task stack  */
    130e:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w    @r13, r1
    1312:	21 4d       	mov	@r13,	r1	

            POPALL							/* Restore all the registers.  */
    1314:	3f 41       	pop	r15		
    1316:	3e 41       	pop	r14		
    1318:	3d 41       	pop	r13		
    131a:	3c 41       	pop	r12		
    131c:	3b 41       	pop	r11		
    131e:	3a 41       	pop	r10		
    1320:	39 41       	pop	r9		
    1322:	38 41       	pop	r8		
    1324:	37 41       	pop	r7		
    1326:	36 41       	pop	r6		
    1328:	35 41       	pop	r5		
    132a:	34 41       	pop	r4		
                    
            reti                            /* emulate return from interrupt  */
    132c:	00 13       	reti			

0000132e <OSCtxSw>:
;********************************************************************************************************
*/

.global OSCtxSw
OSCtxSw:
            push      r2                    /* emulate interrupt by also saving the SR */
    132e:	02 12       	push	r2		
            
            PUSHALL							/* Save all the task registers.  */
    1330:	04 12       	push	r4		
    1332:	05 12       	push	r5		
    1334:	06 12       	push	r6		
    1336:	07 12       	push	r7		
    1338:	08 12       	push	r8		
    133a:	09 12       	push	r9		
    133c:	0a 12       	push	r10		
    133e:	0b 12       	push	r11		
    1340:	0c 12       	push	r12		
    1342:	0d 12       	push	r13		
    1344:	0e 12       	push	r14		
    1346:	0f 12       	push	r15		
            
            mov.w     &OSTCBCur, r13        /* OSTCBCur->OSTCBStkPtr = SP  */
    1348:	1d 42 88 03 	mov	&0x0388,r13	
            mov.w     r1, 0(r13)
    134c:	8d 41 00 00 	mov	r1,	0(r13)	;0x0000(r13)

            call      #OSTaskSwHook
    1350:	b0 12 40 15 	call	#0x1540	

            mov.b     &OSPrioHighRdy, r13   /*  OSPrioCur = OSPrioHighRdy  */
    1354:	5d 42 12 03 	mov.b	&0x0312,r13	
            mov.b     r13, &OSPrioCur       /*                             */
    1358:	c2 4d 26 03 	mov.b	r13,	&0x0326	
                          
            mov.w     &OSTCBHighRdy, r13    /* OSTCBCur  = OSTCBHighRdy    */
    135c:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w     r13, &OSTCBCur        /*                             */
    1360:	82 4d 88 03 	mov	r13,	&0x0388	
                          
            mov.w     @r13, r1              /*  SP        = OSTCBHighRdy->OSTCBStkPtr  */
    1364:	21 4d       	mov	@r13,	r1	
             
            POPALL							/* Restore the new task registers.  */
    1366:	3f 41       	pop	r15		
    1368:	3e 41       	pop	r14		
    136a:	3d 41       	pop	r13		
    136c:	3c 41       	pop	r12		
    136e:	3b 41       	pop	r11		
    1370:	3a 41       	pop	r10		
    1372:	39 41       	pop	r9		
    1374:	38 41       	pop	r8		
    1376:	37 41       	pop	r7		
    1378:	36 41       	pop	r6		
    137a:	35 41       	pop	r5		
    137c:	34 41       	pop	r4		
            
            reti                            /* return from interrup  */
    137e:	00 13       	reti			

00001380 <OSIntCtxSw>:

.global OSIntCtxSw

OSIntCtxSw:
             
            call      #OSTaskSwHook
    1380:	b0 12 40 15 	call	#0x1540	

            mov.b     &OSPrioHighRdy, r13   /* OSPrioCur = OSPrioHighRdy */
    1384:	5d 42 12 03 	mov.b	&0x0312,r13	
            mov.b     r13, &OSPrioCur       
    1388:	c2 4d 26 03 	mov.b	r13,	&0x0326	
                          
            mov.w     &OSTCBHighRdy, r13    /* OSTCBCur  = OSTCBHighRdy  */
    138c:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w     r13, &OSTCBCur
    1390:	82 4d 88 03 	mov	r13,	&0x0388	
                          
            mov.w     @r13, r1              /* SP        = OSTCBHighRdy->OSTCBStkPtr */
    1394:	21 4d       	mov	@r13,	r1	
             
            POPALL							/* Restore the registers.  */
    1396:	3f 41       	pop	r15		
    1398:	3e 41       	pop	r14		
    139a:	3d 41       	pop	r13		
    139c:	3c 41       	pop	r12		
    139e:	3b 41       	pop	r11		
    13a0:	3a 41       	pop	r10		
    13a2:	39 41       	pop	r9		
    13a4:	38 41       	pop	r8		
    13a6:	37 41       	pop	r7		
    13a8:	36 41       	pop	r6		
    13aa:	35 41       	pop	r5		
    13ac:	34 41       	pop	r4		
             
            reti                            /* return from interrup */
    13ae:	00 13       	reti			

000013b0 <vector_ffec>:
;********************************************************************************************************
*/

interrupt(TIMERA0_VECTOR)
TA0_ISR:                                    /* TIMERA0 timer ISR */
            PUSHALL
    13b0:	04 12       	push	r4		
    13b2:	05 12       	push	r5		
    13b4:	06 12       	push	r6		
    13b6:	07 12       	push	r7		
    13b8:	08 12       	push	r8		
    13ba:	09 12       	push	r9		
    13bc:	0a 12       	push	r10		
    13be:	0b 12       	push	r11		
    13c0:	0c 12       	push	r12		
    13c2:	0d 12       	push	r13		
    13c4:	0e 12       	push	r14		
    13c6:	0f 12       	push	r15		
                        
            add.w	 #2304, &TACCR0			/* Reset the Timer Period*/
    13c8:	b2 50 00 09 	add	#2304,	&0x0172	;#0x0900
    13cc:	72 01 
                         
            cmp.b    #0, &OSIntNesting      /* if (OSIntNesting == 0)  */
    13ce:	c2 93 86 03 	tst.b	&0x0386	
            jne      L1
    13d2:	06 20       	jnz	$+14     	;abs 0x13e0
                               
            mov.w    &OSTCBCur, r13         /* save task stack */
    13d4:	1d 42 88 03 	mov	&0x0388,r13	
            mov.w    r1, 0(r13)
    13d8:	8d 41 00 00 	mov	r1,	0(r13)	;0x0000(r13)

            mov.w    &OSISRStkPtr, r1       /* load interrupt stack  */
    13dc:	11 42 0a 03 	mov	&0x030a,r1	

000013e0 <L1>:

L1:
            inc.b    &OSIntNesting          /* increase OSIntNesting */
    13e0:	d2 53 86 03 	inc.b	&0x0386	
             
            EINT                           /* enable general interrupt to allow for interrupt nesting */
    13e4:	32 d2       	eint			

            call     #OSTimeTick            /* call ticks routine       */
    13e6:	b0 12 de 17 	call	#0x17de	

            DINT                           /* IMPORTANT: disable general interrupt BEFORE calling OSIntExit() */
    13ea:	32 c2       	dint			

            call     #OSIntExit             /* call ticks routine */
    13ec:	b0 12 b6 16 	call	#0x16b6	

            cmp.b    #0, &OSIntNesting      /* if (OSIntNesting == 0) */ 
    13f0:	c2 93 86 03 	tst.b	&0x0386	
            jne      L2
    13f4:	03 20       	jnz	$+8      	;abs 0x13fc

            mov.w    &OSTCBHighRdy, r13     /* restore task stack SP */
    13f6:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w    @r13, r1
    13fa:	21 4d       	mov	@r13,	r1	

000013fc <L2>:
                       
L2:
			POPALL
    13fc:	3f 41       	pop	r15		
    13fe:	3e 41       	pop	r14		
    1400:	3d 41       	pop	r13		
    1402:	3c 41       	pop	r12		
    1404:	3b 41       	pop	r11		
    1406:	3a 41       	pop	r10		
    1408:	39 41       	pop	r9		
    140a:	38 41       	pop	r8		
    140c:	37 41       	pop	r7		
    140e:	36 41       	pop	r6		
    1410:	35 41       	pop	r5		
    1412:	34 41       	pop	r4		

            reti                            ; return from interrupt
    1414:	00 13       	reti			

00001416 <OSCPUSaveSR>:
*/

.global OSCPUSaveSR
.type OSCPUSaveSR, @function
OSCPUSaveSR:
            MOV.W    r2,r15			/* gcc returns the value of the sr in r15 */
    1416:	0f 42       	mov	r2,	r15	
            DINT
    1418:	32 c2       	dint			
            RET
    141a:	30 41       	ret			

0000141c <OSCPURestoreSR>:

.global OSCPURestoreSR
.type OSCPURestoreSR, @function
OSCPURestoreSR:
            MOV.W    r15,r2			/* gcc passes the sr in r15 */
    141c:	02 4f       	mov	r15,	r2	
            RET
    141e:	30 41       	ret			

00001420 <OSInitHookBegin>:
* Note(s)    : 1) Interrupts should be disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSInitHookBegin (void)
{
    1420:	04 12       	push	r4		
    1422:	04 41       	mov	r1,	r4	
}
    1424:	34 41       	pop	r4		
    1426:	30 41       	ret			

00001428 <OSInitHookEnd>:
* Note(s)    : 1) Interrupts should be disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSInitHookEnd (void)
{
    1428:	04 12       	push	r4		
    142a:	04 41       	mov	r1,	r4	
}
    142c:	34 41       	pop	r4		
    142e:	30 41       	ret			

00001430 <OSTaskCreateHook>:
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 
void  OSTaskCreateHook (OS_TCB *ptcb)
{
    1430:	04 12       	push	r4		
    1432:	21 83       	decd	r1		
    1434:	04 41       	mov	r1,	r4	
    1436:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
    143a:	21 53       	incd	r1		
    143c:	34 41       	pop	r4		
    143e:	30 41       	ret			

00001440 <OSTaskDelHook>:
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 
void  OSTaskDelHook (OS_TCB *ptcb)
{
    1440:	04 12       	push	r4		
    1442:	21 83       	decd	r1		
    1444:	04 41       	mov	r1,	r4	
    1446:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
    144a:	21 53       	incd	r1		
    144c:	34 41       	pop	r4		
    144e:	30 41       	ret			

00001450 <OSTaskIdleHook>:
* Note(s)    : 1) Interrupts are enabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION >= 251
void  OSTaskIdleHook (void)
{
    1450:	04 12       	push	r4		
    1452:	04 41       	mov	r1,	r4	
#if 0
    LPM0;                                         /* Enter low power mode                              */
#endif    
}
    1454:	34 41       	pop	r4		
    1456:	30 41       	ret			

00001458 <OSTaskStatHook>:
*********************************************************************************************************
*/

#if OS_CPU_HOOKS_EN > 0 
void  OSTaskStatHook (void)
{
    1458:	04 12       	push	r4		
    145a:	04 41       	mov	r1,	r4	
}
    145c:	34 41       	pop	r4		
    145e:	30 41       	ret			

00001460 <OSTaskStkInit>:
*                 }
*********************************************************************************************************
*/

OS_STK  *OSTaskStkInit (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT16U opt)
{
    1460:	04 12       	push	r4		
    1462:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    1466:	04 41       	mov	r1,	r4	
    1468:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    146c:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    1470:	84 4d 06 00 	mov	r13,	6(r4)	;0x0006(r4)
    1474:	84 4c 08 00 	mov	r12,	8(r4)	;0x0008(r4)
    INT16U  *top;


    opt    = opt;                 
    top    = (INT16U *)ptos;
    1478:	94 44 06 00 	mov	6(r4),	0(r4)	;0x0006(r4), 0x0000(r4)
    147c:	00 00 
    top--;  
    147e:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)task;
    1482:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    1486:	2f 44       	mov	@r4,	r15	
    1488:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    top--;
    148c:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)task;                          /* Interrupt return pointer                          */
    1490:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    1494:	2f 44       	mov	@r4,	r15	
    1496:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    top--;
    149a:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0008;                        /* Status register                                   */
    149e:	2f 44       	mov	@r4,	r15	
    14a0:	bf 42 00 00 	mov	#8,	0(r15)	;r2 As==11, 0x0000(r15)
    top--;
    14a4:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0404;
    14a8:	2f 44       	mov	@r4,	r15	
    14aa:	bf 40 04 04 	mov	#1028,	0(r15)	;#0x0404, 0x0000(r15)
    14ae:	00 00 
    top--;
    14b0:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0505;
    14b4:	2f 44       	mov	@r4,	r15	
    14b6:	bf 40 05 05 	mov	#1285,	0(r15)	;#0x0505, 0x0000(r15)
    14ba:	00 00 
    top--;
    14bc:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0606;
    14c0:	2f 44       	mov	@r4,	r15	
    14c2:	bf 40 06 06 	mov	#1542,	0(r15)	;#0x0606, 0x0000(r15)
    14c6:	00 00 
    top--;
    14c8:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0707;
    14cc:	2f 44       	mov	@r4,	r15	
    14ce:	bf 40 07 07 	mov	#1799,	0(r15)	;#0x0707, 0x0000(r15)
    14d2:	00 00 
    top--;
    14d4:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0808;
    14d8:	2f 44       	mov	@r4,	r15	
    14da:	bf 40 08 08 	mov	#2056,	0(r15)	;#0x0808, 0x0000(r15)
    14de:	00 00 
    top--;
    14e0:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0909;
    14e4:	2f 44       	mov	@r4,	r15	
    14e6:	bf 40 09 09 	mov	#2313,	0(r15)	;#0x0909, 0x0000(r15)
    14ea:	00 00 
    top--;
    14ec:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1010;
    14f0:	2f 44       	mov	@r4,	r15	
    14f2:	bf 40 10 10 	mov	#4112,	0(r15)	;#0x1010, 0x0000(r15)
    14f6:	00 00 
    top--;
    14f8:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1111;
    14fc:	2f 44       	mov	@r4,	r15	
    14fe:	bf 40 11 11 	mov	#4369,	0(r15)	;#0x1111, 0x0000(r15)
    1502:	00 00 
    top--;
    1504:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1212;           /* IAR Only */  /* Pass 'p_arg' through register R12                 */
    1508:	2f 44       	mov	@r4,	r15	
    150a:	bf 40 12 12 	mov	#4626,	0(r15)	;#0x1212, 0x0000(r15)
    150e:	00 00 
    top--;
    1510:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1313;
    1514:	2f 44       	mov	@r4,	r15	
    1516:	bf 40 13 13 	mov	#4883,	0(r15)	;#0x1313, 0x0000(r15)
    151a:	00 00 
    top--;
    151c:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1414;                         
    1520:	2f 44       	mov	@r4,	r15	
    1522:	bf 40 14 14 	mov	#5140,	0(r15)	;#0x1414, 0x0000(r15)
    1526:	00 00 
    top--;
    1528:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)p_arg;           /* GCC uses r15 */
    152c:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    1530:	2f 44       	mov	@r4,	r15	
    1532:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    return ((OS_STK *)top);    
    1536:	2f 44       	mov	@r4,	r15	
}
    1538:	31 50 0a 00 	add	#10,	r1	;#0x000a
    153c:	34 41       	pop	r4		
    153e:	30 41       	ret			

00001540 <OSTaskSwHook>:
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0
void  OSTaskSwHook (void)
{
    1540:	04 12       	push	r4		
    1542:	04 41       	mov	r1,	r4	
}
    1544:	34 41       	pop	r4		
    1546:	30 41       	ret			

00001548 <OSTCBInitHook>:
* Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSTCBInitHook (OS_TCB *ptcb)
{
    1548:	04 12       	push	r4		
    154a:	21 83       	decd	r1		
    154c:	04 41       	mov	r1,	r4	
    154e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                                           /* Prevent Compiler warning                 */
}
    1552:	21 53       	incd	r1		
    1554:	34 41       	pop	r4		
    1556:	30 41       	ret			

00001558 <OSTimeTickHook>:
* Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0
void  OSTimeTickHook (void)
{
    1558:	04 12       	push	r4		
    155a:	04 41       	mov	r1,	r4	
}
    155c:	34 41       	pop	r4		
    155e:	30 41       	ret			

00001560 <OSMapTbl>:
    1560:	01 02 04 08 10 20 40 80                             ..... @.

00001568 <OSUnMapTbl>:
    1568:	00 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1578:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1588:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1598:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15a8:	06 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15b8:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15c8:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15d8:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15e8:	07 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15f8:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1608:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1618:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1628:	06 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1638:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1648:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1658:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................

00001668 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
    1668:	04 12       	push	r4		
    166a:	04 41       	mov	r1,	r4	
#if OS_VERSION >= 204
    OSInitHookBegin();                                           /* Call port specific initialization code   */
    166c:	b0 12 20 14 	call	#0x1420	
#endif

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
    1670:	b0 12 4c 1c 	call	#0x1c4c	

    OS_InitRdyList();                                            /* Initialize the Ready List                */
    1674:	b0 12 74 1c 	call	#0x1c74	

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
    1678:	b0 12 ea 1c 	call	#0x1cea	

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
    167c:	b0 12 e2 1b 	call	#0x1be2	

#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
    1680:	b0 12 3c 27 	call	#0x273c	
#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
    1684:	b0 12 50 32 	call	#0x3250	
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
    1688:	b0 12 b6 1c 	call	#0x1cb6	
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
#endif

#if OS_VERSION >= 204
    OSInitHookEnd();                                             /* Call port specific init. code            */
    168c:	b0 12 28 14 	call	#0x1428	
#endif

#if OS_VERSION >= 270 && OS_DEBUG_EN > 0
    OSDebugInit();
#endif
}
    1690:	34 41       	pop	r4		
    1692:	30 41       	ret			

00001694 <OSIntEnter>:
*                 OSIntEnter() is always called with interrupts disabled.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
    1694:	04 12       	push	r4		
    1696:	04 41       	mov	r1,	r4	
    if (OSRunning == TRUE) {
    1698:	5f 42 0d 03 	mov.b	&0x030d,r15	
    169c:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    169e:	09 20       	jnz	$+20     	;abs 0x16b2
        if (OSIntNesting < 255u) {
    16a0:	5f 42 86 03 	mov.b	&0x0386,r15	
    16a4:	7f 93       	cmp.b	#-1,	r15	;r3 As==11
    16a6:	05 24       	jz	$+12     	;abs 0x16b2
            OSIntNesting++;                      /* Increment ISR nesting level                        */
    16a8:	5f 42 86 03 	mov.b	&0x0386,r15	
    16ac:	5f 53       	inc.b	r15		
    16ae:	c2 4f 86 03 	mov.b	r15,	&0x0386	
        }
    }
}
    16b2:	34 41       	pop	r4		
    16b4:	30 41       	ret			

000016b6 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
    16b6:	04 12       	push	r4		
    16b8:	21 82       	sub	#4,	r1	;r2 As==10
    16ba:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    16bc:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSRunning == TRUE) {
    16c0:	5f 42 0d 03 	mov.b	&0x030d,r15	
    16c4:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    16c6:	55 20       	jnz	$+172    	;abs 0x1772
        OS_ENTER_CRITICAL();
    16c8:	b0 12 16 14 	call	#0x1416	
    16cc:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
    16d0:	5f 42 86 03 	mov.b	&0x0386,r15	
    16d4:	4f 93       	tst.b	r15		
    16d6:	05 24       	jz	$+12     	;abs 0x16e2
            OSIntNesting--;
    16d8:	5f 42 86 03 	mov.b	&0x0386,r15	
    16dc:	7f 53       	add.b	#-1,	r15	;r3 As==11
    16de:	c2 4f 86 03 	mov.b	r15,	&0x0386	
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
    16e2:	5f 42 86 03 	mov.b	&0x0386,r15	
    16e6:	4f 93       	tst.b	r15		
    16e8:	41 20       	jnz	$+132    	;abs 0x176c
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
    16ea:	5f 42 0c 03 	mov.b	&0x030c,r15	
    16ee:	4f 93       	tst.b	r15		
    16f0:	3d 20       	jnz	$+124    	;abs 0x176c
                y             = OSUnMapTbl[OSRdyGrp];          
    16f2:	5f 42 7e 03 	mov.b	&0x037e,r15	
    16f6:	7f f3       	and.b	#-1,	r15	;r3 As==11
    16f8:	d4 4f 68 15 	mov.b	5480(r15),2(r4)	;0x1568(r15), 0x0002(r4)
    16fc:	02 00 
                OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
    16fe:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1702:	4f 5f       	rla.b	r15		
    1704:	4f 5f       	rla.b	r15		
    1706:	4f 5f       	rla.b	r15		
    1708:	4e 4f       	mov.b	r15,	r14	
    170a:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    170e:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1712:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1714:	5f 4f 68 15 	mov.b	5480(r15),r15	;0x1568(r15)
    1718:	4f 5e       	add.b	r14,	r15	
    171a:	c2 4f 12 03 	mov.b	r15,	&0x0312	
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
    171e:	5e 42 12 03 	mov.b	&0x0312,r14	
    1722:	5f 42 26 03 	mov.b	&0x0326,r15	
    1726:	4e 9f       	cmp.b	r15,	r14	
    1728:	21 24       	jz	$+68     	;abs 0x176c
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
    172a:	5f 42 12 03 	mov.b	&0x0312,r15	
    172e:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1730:	0f 5f       	rla	r15		
    1732:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    1736:	2f 4f       	mov	@r15,	r15	
    1738:	82 4f 7a 03 	mov	r15,	&0x037a	
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
    173c:	1d 42 7a 03 	mov	&0x037a,r13	
    1740:	1e 4d 22 00 	mov	34(r13),r14	;0x0022(r13)
    1744:	1f 4d 24 00 	mov	36(r13),r15	;0x0024(r13)
    1748:	1e 53       	inc	r14		
    174a:	0f 63       	adc	r15		
    174c:	8d 4e 22 00 	mov	r14,	34(r13)	;0x0022(r13)
    1750:	8d 4f 24 00 	mov	r15,	36(r13)	;0x0024(r13)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
    1754:	1e 42 2c 03 	mov	&0x032c,r14	
    1758:	1f 42 2e 03 	mov	&0x032e,r15	
    175c:	1e 53       	inc	r14		
    175e:	0f 63       	adc	r15		
    1760:	82 4e 2c 03 	mov	r14,	&0x032c	
    1764:	82 4f 2e 03 	mov	r15,	&0x032e	
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
    1768:	b0 12 80 13 	call	#0x1380	
                }
            }
        }
        OS_EXIT_CRITICAL();
    176c:	2f 44       	mov	@r4,	r15	
    176e:	b0 12 1c 14 	call	#0x141c	
    }
}
    1772:	21 52       	add	#4,	r1	;r2 As==10
    1774:	34 41       	pop	r4		
    1776:	30 41       	ret			

00001778 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
    1778:	04 12       	push	r4		
    177a:	21 83       	decd	r1		
    177c:	04 41       	mov	r1,	r4	
    INT8U y;
    INT8U x;


    if (OSRunning == FALSE) {
    177e:	5f 42 0d 03 	mov.b	&0x030d,r15	
    1782:	4f 93       	tst.b	r15		
    1784:	29 20       	jnz	$+84     	;abs 0x17d8
        y             = OSUnMapTbl[OSRdyGrp];        /* Find highest priority's task priority number   */
    1786:	5f 42 7e 03 	mov.b	&0x037e,r15	
    178a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    178c:	d4 4f 68 15 	mov.b	5480(r15),1(r4)	;0x1568(r15), 0x0001(r4)
    1790:	01 00 
        x             = OSUnMapTbl[OSRdyTbl[y]];
    1792:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    1796:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    179a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    179c:	d4 4f 68 15 	mov.b	5480(r15),0(r4)	;0x1568(r15), 0x0000(r4)
    17a0:	00 00 
        OSPrioHighRdy = (INT8U)((y << 3) + x);
    17a2:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    17a6:	4f 5f       	rla.b	r15		
    17a8:	4f 5f       	rla.b	r15		
    17aa:	4f 5f       	rla.b	r15		
    17ac:	6f 54       	add.b	@r4,	r15	
    17ae:	c2 4f 12 03 	mov.b	r15,	&0x0312	
        OSPrioCur     = OSPrioHighRdy;
    17b2:	5f 42 12 03 	mov.b	&0x0312,r15	
    17b6:	c2 4f 26 03 	mov.b	r15,	&0x0326	
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
    17ba:	5f 42 12 03 	mov.b	&0x0312,r15	
    17be:	7f f3       	and.b	#-1,	r15	;r3 As==11
    17c0:	0f 5f       	rla	r15		
    17c2:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    17c6:	2f 4f       	mov	@r15,	r15	
    17c8:	82 4f 7a 03 	mov	r15,	&0x037a	
        OSTCBCur      = OSTCBHighRdy;
    17cc:	1f 42 7a 03 	mov	&0x037a,r15	
    17d0:	82 4f 88 03 	mov	r15,	&0x0388	
        OSStartHighRdy();                            /* Execute target specific code to start task     */
    17d4:	b0 12 02 13 	call	#0x1302	
    }
}
    17d8:	21 53       	incd	r1		
    17da:	34 41       	pop	r4		
    17dc:	30 41       	ret			

000017de <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
    17de:	04 12       	push	r4		
    17e0:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    17e4:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                     */
    17e6:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif
#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
    17ea:	b0 12 58 15 	call	#0x1558	
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
    OSTime++;
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == TRUE) {
    17ee:	5f 42 0d 03 	mov.b	&0x030d,r15	
    17f2:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    17f4:	89 20       	jnz	$+276    	;abs 0x1908
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
    17f6:	5f 42 2a 03 	mov.b	&0x032a,r15	
    17fa:	7f f3       	and.b	#-1,	r15	;r3 As==11
    17fc:	1f 93       	cmp	#1,	r15	;r3 As==01
    17fe:	07 24       	jz	$+16     	;abs 0x180e
    1800:	2f 93       	cmp	#2,	r15	;r3 As==10
    1802:	08 24       	jz	$+18     	;abs 0x1814
    1804:	0f 93       	tst	r15		
    1806:	0b 20       	jnz	$+24     	;abs 0x181e
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = TRUE;
    1808:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    180c:	0c 3c       	jmp	$+26     	;abs 0x1826
                 break;

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = FALSE;                             /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
    180e:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    1812:	09 3c       	jmp	$+20     	;abs 0x1826
                 break;

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = TRUE;                   /*      ... step command from uC/OS-View        */
    1814:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
                 OSTickStepState = OS_TICK_STEP_WAIT;
    1818:	d2 43 2a 03 	mov.b	#1,	&0x032a	;r3 As==01
    181c:	04 3c       	jmp	$+10     	;abs 0x1826
                 break;

            default:                                       /* Invalid case, correct situation              */
                 step            = TRUE;
    181e:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
                 OSTickStepState = OS_TICK_STEP_DIS;
    1822:	c2 43 2a 03 	mov.b	#0,	&0x032a	;r3 As==00
                 break;
        }
        if (step == FALSE) {                               /* Return if waiting for step command           */
    1826:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    182a:	6d 24       	jz	$+220    	;abs 0x1906
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
    182c:	94 42 28 03 	mov	&0x0328,4(r4)	;0x0004(r4)
    1830:	04 00 
    1832:	61 3c       	jmp	$+196    	;abs 0x18f6
        while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {          /* Go through all TCBs in TCB list              */
            OS_ENTER_CRITICAL();
    1834:	b0 12 16 14 	call	#0x1416	
    1838:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
    183c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1840:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    1844:	0f 93       	tst	r15		
    1846:	4f 24       	jz	$+160    	;abs 0x18e6
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
    1848:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    184c:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    1850:	0e 4f       	mov	r15,	r14	
    1852:	3e 53       	add	#-1,	r14	;r3 As==11
    1854:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1858:	8f 4e 18 00 	mov	r14,	24(r15)	;0x0018(r15)
    185c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1860:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    1864:	0f 93       	tst	r15		
    1866:	3f 20       	jnz	$+128    	;abs 0x18e6
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
    1868:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    186c:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1870:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1872:	3f f0 37 00 	and	#55,	r15	;#0x0037
    1876:	10 24       	jz	$+34     	;abs 0x1898
                        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag   */
    1878:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    187c:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1880:	4e 4f       	mov.b	r15,	r14	
    1882:	7e f0 c8 ff 	and.b	#-56,	r14	;#0xffc8
    1886:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    188a:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
                        ptcb->OSTCBPendTO  = TRUE;                             /* Indicate PEND timeout    */
    188e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1892:	df 43 1b 00 	mov.b	#1,	27(r15)	;r3 As==01, 0x001b(r15)
    1896:	04 3c       	jmp	$+10     	;abs 0x18a0
                    } else {
                        ptcb->OSTCBPendTO  = FALSE;
    1898:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    189c:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
    18a0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18a4:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    18a8:	7f f3       	and.b	#-1,	r15	;r3 As==11
    18aa:	3f f2       	and	#8,	r15	;r2 As==11
    18ac:	1c 20       	jnz	$+58     	;abs 0x18e6
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
    18ae:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18b2:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    18b6:	5f 42 7e 03 	mov.b	&0x037e,r15	
    18ba:	4f de       	bis.b	r14,	r15	
    18bc:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    18c0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18c4:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    18c8:	4d 4f       	mov.b	r15,	r13	
    18ca:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18ce:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    18d2:	7f f3       	and.b	#-1,	r15	;r3 As==11
    18d4:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    18d8:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18dc:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    18e0:	4f de       	bis.b	r14,	r15	
    18e2:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
    18e6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18ea:	94 4f 0e 00 	mov	14(r15),4(r4)	;0x000e(r15), 0x0004(r4)
    18ee:	04 00 
            OS_EXIT_CRITICAL();
    18f0:	2f 44       	mov	@r4,	r15	
    18f2:	b0 12 1c 14 	call	#0x141c	
        if (step == FALSE) {                               /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {          /* Go through all TCBs in TCB list              */
    18f6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18fa:	5f 4f 1c 00 	mov.b	28(r15),r15	;0x001c(r15)
    18fe:	7f 90 14 00 	cmp.b	#20,	r15	;#0x0014
    1902:	98 23       	jnz	$-206    	;abs 0x1834
    1904:	01 3c       	jmp	$+4      	;abs 0x1908
                 step            = TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == FALSE) {                               /* Return if waiting for step command           */
            return;
    1906:	03 43       	nop			
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
    1908:	31 50 06 00 	add	#6,	r1	;#0x0006
    190c:	34 41       	pop	r4		
    190e:	30 41       	ret			

00001910 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
    1910:	04 12       	push	r4		
    1912:	04 41       	mov	r1,	r4	
    return (OS_VERSION);
    1914:	3f 40 14 01 	mov	#276,	r15	;#0x0114
}
    1918:	34 41       	pop	r4		
    191a:	30 41       	ret			

0000191c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *msg, INT8U msk)
{
    191c:	04 12       	push	r4		
    191e:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    1922:	04 41       	mov	r1,	r4	
    1924:	84 4f 08 00 	mov	r15,	8(r4)	;0x0008(r4)
    1928:	84 4e 0a 00 	mov	r14,	10(r4)	;0x000a(r4)
    192c:	c4 4d 0c 00 	mov.b	r13,	12(r4)	;0x000c(r4)
    INT8U   bitx;
    INT8U   bity;
    INT8U   prio;


    y                      = OSUnMapTbl[pevent->OSEventGrp];   /* Find HPT waiting for message         */
    1930:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1934:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    1938:	7f f3       	and.b	#-1,	r15	;r3 As==11
    193a:	d4 4f 68 15 	mov.b	5480(r15),3(r4)	;0x1568(r15), 0x0003(r4)
    193e:	03 00 
    bity                   = OSMapTbl[y];
    1940:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    1944:	d4 4f 60 15 	mov.b	5472(r15),1(r4)	;0x1560(r15), 0x0001(r4)
    1948:	01 00 
    x                      = OSUnMapTbl[pevent->OSEventTbl[y]];
    194a:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    194e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1952:	0f 5e       	add	r14,	r15	
    1954:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1958:	6f 4f       	mov.b	@r15,	r15	
    195a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    195c:	d4 4f 68 15 	mov.b	5480(r15),4(r4)	;0x1568(r15), 0x0004(r4)
    1960:	04 00 
    bitx                   = OSMapTbl[x];
    1962:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    1966:	d4 4f 60 15 	mov.b	5472(r15),2(r4)	;0x1560(r15), 0x0002(r4)
    196a:	02 00 
    prio                   = (INT8U)((y << 3) + x);     /* Find priority of task getting the msg       */
    196c:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    1970:	4f 5f       	rla.b	r15		
    1972:	4f 5f       	rla.b	r15		
    1974:	4f 5f       	rla.b	r15		
    1976:	4e 4f       	mov.b	r15,	r14	
    1978:	5e 54 04 00 	add.b	4(r4),	r14	;0x0004(r4)
    197c:	c4 4e 00 00 	mov.b	r14,	0(r4)	;0x0000(r4)
    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
    1980:	5d 44 03 00 	mov.b	3(r4),	r13	;0x0003(r4)
    1984:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    1988:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    198c:	0f 5e       	add	r14,	r15	
    198e:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1992:	6f 4f       	mov.b	@r15,	r15	
    1994:	4e 4f       	mov.b	r15,	r14	
    1996:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    199a:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    199c:	4f fe       	and.b	r14,	r15	
    199e:	4e 4f       	mov.b	r15,	r14	
    19a0:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    19a4:	0f 5d       	add	r13,	r15	
    19a6:	3f 50 06 00 	add	#6,	r15	;#0x0006
    19aa:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    if (pevent->OSEventTbl[y] == 0x00) {                
    19ae:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    19b2:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    19b6:	0f 5e       	add	r14,	r15	
    19b8:	3f 50 06 00 	add	#6,	r15	;#0x0006
    19bc:	6f 4f       	mov.b	@r15,	r15	
    19be:	4f 93       	tst.b	r15		
    19c0:	0e 20       	jnz	$+30     	;abs 0x19de
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
    19c2:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    19c6:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    19ca:	4e 4f       	mov.b	r15,	r14	
    19cc:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    19d0:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    19d2:	4f fe       	and.b	r14,	r15	
    19d4:	4e 4f       	mov.b	r15,	r14	
    19d6:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    19da:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
    }
    ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
    19de:	6f 44       	mov.b	@r4,	r15	
    19e0:	0f 5f       	rla	r15		
    19e2:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    19e6:	a4 4f 06 00 	mov	@r15,	6(r4)	;0x0006(r4)
    ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
    19ea:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19ee:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)
    ptcb->OSTCBEventPtr  = (OS_EVENT *)0;               /* Unlink ECB from this task                   */
    19f2:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19f6:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg       = msg;                         /* Send message directly to waiting task       */
    19fa:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19fe:	9f 44 0a 00 	mov	10(r4),	20(r15)	;0x000a(r4), 0x0014(r15)
    1a02:	14 00 
#else
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = FALSE;                       /* Cancel 'any' timeout because of post        */
    1a04:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a08:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
    1a0c:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a10:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1a14:	4e 4f       	mov.b	r15,	r14	
    1a16:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    1a1a:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1a1c:	4f fe       	and.b	r14,	r15	
    1a1e:	4e 4f       	mov.b	r15,	r14	
    1a20:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a24:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {               /* See if task is ready (could be susp'd)      */
    1a28:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a2c:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1a30:	4f 93       	tst.b	r15		
    1a32:	10 20       	jnz	$+34     	;abs 0x1a54
        OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
    1a34:	5f 42 7e 03 	mov.b	&0x037e,r15	
    1a38:	5f d4 01 00 	bis.b	1(r4),	r15	;0x0001(r4)
    1a3c:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[y]     |=  bitx;
    1a40:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    1a44:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    1a48:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1a4c:	5f d4 02 00 	bis.b	2(r4),	r15	;0x0002(r4)
    1a50:	ce 4f 80 03 	mov.b	r15,	896(r14);0x0380(r14)
    }
    return (prio);
    1a54:	6f 44       	mov.b	@r4,	r15	
}
    1a56:	31 50 0e 00 	add	#14,	r1	;#0x000e
    1a5a:	34 41       	pop	r4		
    1a5c:	30 41       	ret			

00001a5e <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    1a5e:	04 12       	push	r4		
    1a60:	21 82       	sub	#4,	r1	;r2 As==10
    1a62:	04 41       	mov	r1,	r4	
    1a64:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    1a68:	1f 42 88 03 	mov	&0x0388,r15	
    1a6c:	9f 44 02 00 	mov	2(r4),	18(r15)	;0x0002(r4), 0x0012(r15)
    1a70:	12 00 
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    1a72:	1f 42 88 03 	mov	&0x0388,r15	
    1a76:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    1a7a:	00 00 
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
    1a7c:	6d 44       	mov.b	@r4,	r13	
    1a7e:	6f 44       	mov.b	@r4,	r15	
    1a80:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1a84:	4e 4f       	mov.b	r15,	r14	
    1a86:	1f 42 88 03 	mov	&0x0388,r15	
    1a8a:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1a8e:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1a90:	4f fe       	and.b	r14,	r15	
    1a92:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
    if (OSRdyTbl[y] == 0x00) {                   
    1a96:	6f 44       	mov.b	@r4,	r15	
    1a98:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1a9c:	4f 93       	tst.b	r15		
    1a9e:	0b 20       	jnz	$+24     	;abs 0x1ab6
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
    1aa0:	1f 42 88 03 	mov	&0x0388,r15	
    1aa4:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1aa8:	4e 4f       	mov.b	r15,	r14	
    1aaa:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    1aac:	5f 42 7e 03 	mov.b	&0x037e,r15	
    1ab0:	4f fe       	and.b	r14,	r15	
    1ab2:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
    1ab6:	1f 42 88 03 	mov	&0x0388,r15	
    1aba:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1abe:	4d 4f       	mov.b	r15,	r13	
    1ac0:	1f 42 88 03 	mov	&0x0388,r15	
    1ac4:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1ac8:	4e 4f       	mov.b	r15,	r14	
    1aca:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ace:	0f 5e       	add	r14,	r15	
    1ad0:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1ad4:	6e 4f       	mov.b	@r15,	r14	
    1ad6:	1f 42 88 03 	mov	&0x0388,r15	
    1ada:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1ade:	4e df       	bis.b	r15,	r14	
    1ae0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ae4:	0f 5d       	add	r13,	r15	
    1ae6:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1aea:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
    1aee:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1af2:	5e 4f 01 00 	mov.b	1(r15),	r14	;0x0001(r15)
    1af6:	1f 42 88 03 	mov	&0x0388,r15	
    1afa:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1afe:	4e df       	bis.b	r15,	r14	
    1b00:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b04:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
}
    1b08:	21 52       	add	#4,	r1	;r2 As==10
    1b0a:	34 41       	pop	r4		
    1b0c:	30 41       	ret			

00001b0e <OS_EventTO>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTO (OS_EVENT *pevent)
{
    1b0e:	04 12       	push	r4		
    1b10:	21 82       	sub	#4,	r1	;r2 As==10
    1b12:	04 41       	mov	r1,	r4	
    1b14:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  y;


    y                      = OSTCBCur->OSTCBY;
    1b18:	1f 42 88 03 	mov	&0x0388,r15	
    1b1c:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    1b20:	00 00 
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
    1b22:	6d 44       	mov.b	@r4,	r13	
    1b24:	6e 44       	mov.b	@r4,	r14	
    1b26:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b2a:	0f 5e       	add	r14,	r15	
    1b2c:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b30:	6f 4f       	mov.b	@r15,	r15	
    1b32:	4e 4f       	mov.b	r15,	r14	
    1b34:	1f 42 88 03 	mov	&0x0388,r15	
    1b38:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1b3c:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1b3e:	4f fe       	and.b	r14,	r15	
    1b40:	4e 4f       	mov.b	r15,	r14	
    1b42:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b46:	0f 5d       	add	r13,	r15	
    1b48:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b4c:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    if (pevent->OSEventTbl[y] == 0x00) {
    1b50:	6e 44       	mov.b	@r4,	r14	
    1b52:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b56:	0f 5e       	add	r14,	r15	
    1b58:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b5c:	6f 4f       	mov.b	@r15,	r15	
    1b5e:	4f 93       	tst.b	r15		
    1b60:	10 20       	jnz	$+34     	;abs 0x1b82
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
    1b62:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b66:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    1b6a:	4e 4f       	mov.b	r15,	r14	
    1b6c:	1f 42 88 03 	mov	&0x0388,r15	
    1b70:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1b74:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1b76:	4f fe       	and.b	r14,	r15	
    1b78:	4e 4f       	mov.b	r15,	r14	
    1b7a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b7e:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
    }
    OSTCBCur->OSTCBPendTO   = FALSE;                   /* Clear the Pend Timeout flag                  */
    1b82:	1f 42 88 03 	mov	&0x0388,r15	
    1b86:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
    1b8a:	1f 42 88 03 	mov	&0x0388,r15	
    1b8e:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
    1b92:	1f 42 88 03 	mov	&0x0388,r15	
    1b96:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
}
    1b9a:	21 52       	add	#4,	r1	;r2 As==10
    1b9c:	34 41       	pop	r4		
    1b9e:	30 41       	ret			

00001ba0 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
    1ba0:	04 12       	push	r4		
    1ba2:	21 82       	sub	#4,	r1	;r2 As==10
    1ba4:	04 41       	mov	r1,	r4	
    1ba6:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  *ptbl;


    pevent->OSEventGrp = 0x00;                   /* No task waiting on event                           */
    1baa:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bae:	cf 43 01 00 	mov.b	#0,	1(r15)	;r3 As==00, 0x0001(r15)
    ptbl               = &pevent->OSEventTbl[0];
    1bb2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bb6:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1bba:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)

#if OS_EVENT_TBL_SIZE > 0
    *ptbl++            = 0x00;
    1bbe:	2f 44       	mov	@r4,	r15	
    1bc0:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1bc4:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 1
    *ptbl++            = 0x00;
    1bc8:	2f 44       	mov	@r4,	r15	
    1bca:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1bce:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 2
    *ptbl++            = 0x00;
    1bd2:	2f 44       	mov	@r4,	r15	
    1bd4:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1bd8:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 7
    *ptbl              = 0x00;
#endif
}
    1bdc:	21 52       	add	#4,	r1	;r2 As==10
    1bde:	34 41       	pop	r4		
    1be0:	30 41       	ret			

00001be2 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
    1be2:	04 12       	push	r4		
    1be4:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1be8:	04 41       	mov	r1,	r4	
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    1bea:	3f 40 0a 04 	mov	#1034,	r15	;#0x040a
    1bee:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    1bf2:	b0 12 56 1d 	call	#0x1d56	
    pevent1 = &OSEventTbl[0];
    1bf6:	b4 40 0a 04 	mov	#1034,	2(r4)	;#0x040a, 0x0002(r4)
    1bfa:	02 00 
    pevent2 = &OSEventTbl[1];
    1bfc:	b4 40 14 04 	mov	#1044,	0(r4)	;#0x0414, 0x0000(r4)
    1c00:	00 00 
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
    1c02:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    1c06:	10 3c       	jmp	$+34     	;abs 0x1c28
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
    1c08:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1c0c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        pevent1->OSEventPtr     = pevent2;
    1c10:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1c14:	af 44 04 00 	mov	@r4,	4(r15)	;0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
    1c18:	b4 50 0a 00 	add	#10,	2(r4)	;#0x000a, 0x0002(r4)
    1c1c:	02 00 
        pevent2++;
    1c1e:	b4 50 0a 00 	add	#10,	0(r4)	;#0x000a, 0x0000(r4)
    1c22:	00 00 


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
    1c24:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    1c28:	a4 92 04 00 	cmp	#4,	4(r4)	;r2 As==10, 0x0004(r4)
    1c2c:	ed 2b       	jnc	$-36     	;abs 0x1c08
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
    1c2e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1c32:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
    1c36:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1c3a:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';                  
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
#endif
    OSEventFreeList                 = &OSEventTbl[0];
    1c3e:	b2 40 0a 04 	mov	#1034,	&0x0384	;#0x040a
    1c42:	84 03 
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
    1c44:	31 50 06 00 	add	#6,	r1	;#0x0006
    1c48:	34 41       	pop	r4		
    1c4a:	30 41       	ret			

00001c4c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
    1c4c:	04 12       	push	r4		
    1c4e:	04 41       	mov	r1,	r4	
#if OS_TIME_GET_SET_EN > 0   
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
    1c50:	c2 43 86 03 	mov.b	#0,	&0x0386	;r3 As==00
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
    1c54:	c2 43 0c 03 	mov.b	#0,	&0x030c	;r3 As==00

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
    1c58:	c2 43 32 03 	mov.b	#0,	&0x0332	;r3 As==00

    OSRunning     = FALSE;                                 /* Indicate that multitasking not started   */
    1c5c:	c2 43 0d 03 	mov.b	#0,	&0x030d	;r3 As==00
    
    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
    1c60:	82 43 2c 03 	mov	#0,	&0x032c	;r3 As==00
    1c64:	82 43 2e 03 	mov	#0,	&0x032e	;r3 As==00
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
    1c68:	82 43 0e 03 	mov	#0,	&0x030e	;r3 As==00
    1c6c:	82 43 10 03 	mov	#0,	&0x0310	;r3 As==00
#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
    OSIdleCtrMax  = 0L;
    OSStatRdy     = FALSE;                                 /* Statistic task is not ready              */
#endif
}
    1c70:	34 41       	pop	r4		
    1c72:	30 41       	ret			

00001c74 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
    1c74:	04 12       	push	r4		
    1c76:	21 82       	sub	#4,	r1	;r2 As==10
    1c78:	04 41       	mov	r1,	r4	
    INT8U    i;
    INT8U   *prdytbl;


    OSRdyGrp      = 0x00;                                  /* Clear the ready list                     */
    1c7a:	c2 43 7e 03 	mov.b	#0,	&0x037e	;r3 As==00
    prdytbl       = &OSRdyTbl[0];
    1c7e:	b4 40 80 03 	mov	#896,	0(r4)	;#0x0380, 0x0000(r4)
    1c82:	00 00 
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
    1c84:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    1c88:	07 3c       	jmp	$+16     	;abs 0x1c98
        *prdytbl++ = 0x00;
    1c8a:	2f 44       	mov	@r4,	r15	
    1c8c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1c90:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    INT8U   *prdytbl;


    OSRdyGrp      = 0x00;                                  /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
    1c94:	d4 53 02 00 	inc.b	2(r4)		;0x0002(r4)
    1c98:	f4 90 03 00 	cmp.b	#3,	2(r4)	;#0x0003, 0x0002(r4)
    1c9c:	02 00 
    1c9e:	f5 2b       	jnc	$-20     	;abs 0x1c8a
        *prdytbl++ = 0x00;
    }

    OSPrioCur     = 0;
    1ca0:	c2 43 26 03 	mov.b	#0,	&0x0326	;r3 As==00
    OSPrioHighRdy = 0;
    1ca4:	c2 43 12 03 	mov.b	#0,	&0x0312	;r3 As==00

    OSTCBHighRdy  = (OS_TCB *)0;                                 
    1ca8:	82 43 7a 03 	mov	#0,	&0x037a	;r3 As==00
    OSTCBCur      = (OS_TCB *)0;
    1cac:	82 43 88 03 	mov	#0,	&0x0388	;r3 As==00
}
    1cb0:	21 52       	add	#4,	r1	;r2 As==10
    1cb2:	34 41       	pop	r4		
    1cb4:	30 41       	ret			

00001cb6 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
    1cb6:	04 12       	push	r4		
    1cb8:	04 41       	mov	r1,	r4	
#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
    1cba:	7e 40 14 00 	mov.b	#20,	r14	;#0x0014
    1cbe:	3f 40 08 04 	mov	#1032,	r15	;#0x0408
    1cc2:	30 12 03 00 	push	#3		;#0x0003
    1cc6:	03 12       	push	#0		;r3 As==00
    1cc8:	03 12       	push	#0		;r3 As==00
    1cca:	30 12 40 00 	push	#64		;#0x0040
    1cce:	30 12 8a 03 	push	#906		;#0x038a
    1cd2:	33 12       	push	#-1		;r3 As==11
    1cd4:	4c 4e       	mov.b	r14,	r12	
    1cd6:	0d 4f       	mov	r15,	r13	
    1cd8:	0e 43       	clr	r14		
    1cda:	3f 40 64 1e 	mov	#7780,	r15	;#0x1e64
    1cde:	b0 12 1e 38 	call	#0x381e	
    1ce2:	31 50 0c 00 	add	#12,	r1	;#0x000c
                       (void *)0,
                       &OSTaskIdleStk[0],
                       OS_IDLE_PRIO);
    #endif
#endif
}
    1ce6:	34 41       	pop	r4		
    1ce8:	30 41       	ret			

00001cea <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
    1cea:	04 12       	push	r4		
    1cec:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1cf0:	04 41       	mov	r1,	r4	
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    1cf2:	3f 40 3c 04 	mov	#1084,	r15	;#0x043c
    1cf6:	3e 40 38 01 	mov	#312,	r14	;#0x0138
    1cfa:	b0 12 56 1d 	call	#0x1d56	
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    1cfe:	3f 40 76 05 	mov	#1398,	r15	;#0x0576
    1d02:	3e 40 2a 00 	mov	#42,	r14	;#0x002a
    1d06:	b0 12 56 1d 	call	#0x1d56	
    ptcb1 = &OSTCBTbl[0];
    1d0a:	b4 40 3c 04 	mov	#1084,	2(r4)	;#0x043c, 0x0002(r4)
    1d0e:	02 00 
    ptcb2 = &OSTCBTbl[1];
    1d10:	b4 40 70 04 	mov	#1136,	0(r4)	;#0x0470, 0x0000(r4)
    1d14:	00 00 
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
    1d16:	c4 43 04 00 	mov.b	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    1d1a:	0c 3c       	jmp	$+26     	;abs 0x1d34
        ptcb1->OSTCBNext = ptcb2;
    1d1c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1d20:	af 44 0e 00 	mov	@r4,	14(r15)	;0x000e(r15)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
    1d24:	b4 50 34 00 	add	#52,	2(r4)	;#0x0034, 0x0002(r4)
    1d28:	02 00 
        ptcb2++;
    1d2a:	b4 50 34 00 	add	#52,	0(r4)	;#0x0034, 0x0000(r4)
    1d2e:	00 00 

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
    1d30:	d4 53 04 00 	inc.b	4(r4)		;0x0004(r4)
    1d34:	f4 90 05 00 	cmp.b	#5,	4(r4)	;#0x0005, 0x0004(r4)
    1d38:	04 00 
    1d3a:	f0 2b       	jnc	$-30     	;abs 0x1d1c
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
    1d3c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1d40:	8f 43 0e 00 	mov	#0,	14(r15)	;r3 As==00, 0x000e(r15)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
    1d44:	82 43 28 03 	mov	#0,	&0x0328	;r3 As==00
    OSTCBFreeList           = &OSTCBTbl[0];
    1d48:	b2 40 3c 04 	mov	#1084,	&0x0330	;#0x043c
    1d4c:	30 03 
}
    1d4e:	31 50 06 00 	add	#6,	r1	;#0x0006
    1d52:	34 41       	pop	r4		
    1d54:	30 41       	ret			

00001d56 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    1d56:	04 12       	push	r4		
    1d58:	21 82       	sub	#4,	r1	;r2 As==10
    1d5a:	04 41       	mov	r1,	r4	
    1d5c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    1d60:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    1d64:	07 3c       	jmp	$+16     	;abs 0x1d74
    while (size > 0) {
        *pdest++ = (INT8U)0;
    1d66:	2f 44       	mov	@r4,	r15	
    1d68:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1d6c:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
        size--;
    1d70:	b4 53 02 00 	add	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
    1d74:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    1d78:	f6 23       	jnz	$-18     	;abs 0x1d66
        *pdest++ = (INT8U)0;
        size--;
    }
}
    1d7a:	21 52       	add	#4,	r1	;r2 As==10
    1d7c:	34 41       	pop	r4		
    1d7e:	30 41       	ret			

00001d80 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    1d80:	04 12       	push	r4		
    1d82:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1d86:	04 41       	mov	r1,	r4	
    1d88:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    1d8c:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    1d90:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
    1d94:	0c 3c       	jmp	$+26     	;abs 0x1dae
    while (size > 0) {
        *pdest++ = *psrc++;
    1d96:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1d9a:	6e 4f       	mov.b	@r15,	r14	
    1d9c:	2f 44       	mov	@r4,	r15	
    1d9e:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    1da2:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    1da6:	94 53 02 00 	inc	2(r4)		;0x0002(r4)
        size--;
    1daa:	b4 53 04 00 	add	#-1,	4(r4)	;r3 As==11, 0x0004(r4)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
    1dae:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    1db2:	f1 23       	jnz	$-28     	;abs 0x1d96
        *pdest++ = *psrc++;
        size--;
    }
}
    1db4:	31 50 06 00 	add	#6,	r1	;#0x0006
    1db8:	34 41       	pop	r4		
    1dba:	30 41       	ret			

00001dbc <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
    1dbc:	04 12       	push	r4		
    1dbe:	21 82       	sub	#4,	r1	;r2 As==10
    1dc0:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    1dc2:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    1dc6:	b0 12 16 14 	call	#0x1416	
    1dca:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
    1dce:	5f 42 86 03 	mov.b	&0x0386,r15	
    1dd2:	4f 93       	tst.b	r15		
    1dd4:	41 20       	jnz	$+132    	;abs 0x1e58
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
    1dd6:	5f 42 0c 03 	mov.b	&0x030c,r15	
    1dda:	4f 93       	tst.b	r15		
    1ddc:	3d 20       	jnz	$+124    	;abs 0x1e58
            y             = OSUnMapTbl[OSRdyGrp];      /* Get pointer to HPT ready to run              */
    1dde:	5f 42 7e 03 	mov.b	&0x037e,r15	
    1de2:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1de4:	d4 4f 68 15 	mov.b	5480(r15),2(r4)	;0x1568(r15), 0x0002(r4)
    1de8:	02 00 
            OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
    1dea:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1dee:	4f 5f       	rla.b	r15		
    1df0:	4f 5f       	rla.b	r15		
    1df2:	4f 5f       	rla.b	r15		
    1df4:	4e 4f       	mov.b	r15,	r14	
    1df6:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1dfa:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1dfe:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1e00:	5f 4f 68 15 	mov.b	5480(r15),r15	;0x1568(r15)
    1e04:	4f 5e       	add.b	r14,	r15	
    1e06:	c2 4f 12 03 	mov.b	r15,	&0x0312	
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
    1e0a:	5e 42 12 03 	mov.b	&0x0312,r14	
    1e0e:	5f 42 26 03 	mov.b	&0x0326,r15	
    1e12:	4e 9f       	cmp.b	r15,	r14	
    1e14:	21 24       	jz	$+68     	;abs 0x1e58
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
    1e16:	5f 42 12 03 	mov.b	&0x0312,r15	
    1e1a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1e1c:	0f 5f       	rla	r15		
    1e1e:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    1e22:	2f 4f       	mov	@r15,	r15	
    1e24:	82 4f 7a 03 	mov	r15,	&0x037a	
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
    1e28:	1d 42 7a 03 	mov	&0x037a,r13	
    1e2c:	1e 4d 22 00 	mov	34(r13),r14	;0x0022(r13)
    1e30:	1f 4d 24 00 	mov	36(r13),r15	;0x0024(r13)
    1e34:	1e 53       	inc	r14		
    1e36:	0f 63       	adc	r15		
    1e38:	8d 4e 22 00 	mov	r14,	34(r13)	;0x0022(r13)
    1e3c:	8d 4f 24 00 	mov	r15,	36(r13)	;0x0024(r13)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
    1e40:	1e 42 2c 03 	mov	&0x032c,r14	
    1e44:	1f 42 2e 03 	mov	&0x032e,r15	
    1e48:	1e 53       	inc	r14		
    1e4a:	0f 63       	adc	r15		
    1e4c:	82 4e 2c 03 	mov	r14,	&0x032c	
    1e50:	82 4f 2e 03 	mov	r15,	&0x032e	
                OS_TASK_SW();                          /* Perform a context switch                     */
    1e54:	b0 12 2e 13 	call	#0x132e	
            }
        }
    }
    OS_EXIT_CRITICAL();
    1e58:	2f 44       	mov	@r4,	r15	
    1e5a:	b0 12 1c 14 	call	#0x141c	
}
    1e5e:	21 52       	add	#4,	r1	;r2 As==10
    1e60:	34 41       	pop	r4		
    1e62:	30 41       	ret			

00001e64 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *parg)
{
    1e64:	04 12       	push	r4		
    1e66:	21 82       	sub	#4,	r1	;r2 As==10
    1e68:	04 41       	mov	r1,	r4	
    1e6a:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    1e6e:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    parg   = parg;                               /* Prevent compiler warning for not using 'parg'      */
    for (;;) {
        OS_ENTER_CRITICAL();
    1e72:	b0 12 16 14 	call	#0x1416	
    1e76:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        OSIdleCtr++;
    1e7a:	1e 42 0e 03 	mov	&0x030e,r14	
    1e7e:	1f 42 10 03 	mov	&0x0310,r15	
    1e82:	1e 53       	inc	r14		
    1e84:	0f 63       	adc	r15		
    1e86:	82 4e 0e 03 	mov	r14,	&0x030e	
    1e8a:	82 4f 10 03 	mov	r15,	&0x0310	
        OS_EXIT_CRITICAL();
    1e8e:	2f 44       	mov	@r4,	r15	
    1e90:	b0 12 1c 14 	call	#0x141c	
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
    1e94:	b0 12 50 14 	call	#0x1450	
    1e98:	ec 3f       	jmp	$-38     	;abs 0x1e72

00001e9a <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
    1e9a:	04 12       	push	r4		
    1e9c:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    1ea0:	04 41       	mov	r1,	r4	
    1ea2:	c4 4f 04 00 	mov.b	r15,	4(r4)	;0x0004(r4)
    1ea6:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    1eaa:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
    1eae:	84 4c 0a 00 	mov	r12,	10(r4)	;0x000a(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    1eb2:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    1eb6:	b0 12 16 14 	call	#0x1416	
    1eba:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    1ebe:	94 42 30 03 	mov	&0x0330,2(r4)	;0x0002(r4)
    1ec2:	02 00 
    if (ptcb != (OS_TCB *)0) {
    1ec4:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    1ec8:	d7 24       	jz	$+432    	;abs 0x2078
        OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
    1eca:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ece:	1f 4f 0e 00 	mov	14(r15),r15	;0x000e(r15)
    1ed2:	82 4f 30 03 	mov	r15,	&0x0330	
        OS_EXIT_CRITICAL();
    1ed6:	2f 44       	mov	@r4,	r15	
    1ed8:	b0 12 1c 14 	call	#0x141c	
        ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
    1edc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ee0:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    1ee4:	00 00 
        ptcb->OSTCBPrio      = prio;                       /* Load task priority into TCB              */
    1ee6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1eea:	df 44 04 00 	mov.b	4(r4),	28(r15)	;0x0004(r4), 0x001c(r15)
    1eee:	1c 00 
        ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
    1ef0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ef4:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
        ptcb->OSTCBPendTO    = FALSE;                      /* Clear the Pend timeout flag              */
    1ef8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1efc:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
        ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */
    1f00:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f04:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
    1f08:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f0c:	9f 44 14 00 	mov	20(r4),	2(r15)	;0x0014(r4), 0x0002(r15)
    1f10:	02 00 
        ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
    1f12:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f16:	9f 44 10 00 	mov	16(r4),	6(r15)	;0x0010(r4), 0x0006(r15)
    1f1a:	06 00 
    1f1c:	9f 44 12 00 	mov	18(r4),	8(r15)	;0x0012(r4), 0x0008(r15)
    1f20:	08 00 
        ptcb->OSTCBStkBottom = pbos;                       /* Store pointer to bottom of stack         */
    1f22:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f26:	9f 44 08 00 	mov	8(r4),	4(r15)	;0x0008(r4), 0x0004(r15)
    1f2a:	04 00 
        ptcb->OSTCBOpt       = opt;                        /* Store task options                       */
    1f2c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f30:	9f 44 16 00 	mov	22(r4),	10(r15)	;0x0016(r4), 0x000a(r15)
    1f34:	0a 00 
        ptcb->OSTCBId        = id;                         /* Store task ID                            */
    1f36:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f3a:	9f 44 0a 00 	mov	10(r4),	12(r15)	;0x000a(r4), 0x000c(r15)
    1f3e:	0c 00 

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq    = OS_NO_ERR;
#endif

        ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
    1f40:	5e 44 04 00 	mov.b	4(r4),	r14	;0x0004(r4)
    1f44:	12 c3       	clrc			
    1f46:	4e 10       	rrc.b	r14		
    1f48:	4e 11       	rra.b	r14		
    1f4a:	4e 11       	rra.b	r14		
    1f4c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f50:	cf 4e 1e 00 	mov.b	r14,	30(r15)	;0x001e(r15)
        ptcb->OSTCBBitY      = OSMapTbl[ptcb->OSTCBY];
    1f54:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f58:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1f5c:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1f5e:	5e 4f 60 15 	mov.b	5472(r15),r14	;0x1560(r15)
    1f62:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f66:	cf 4e 20 00 	mov.b	r14,	32(r15)	;0x0020(r15)
        ptcb->OSTCBX         = (INT8U)(prio & 0x07);
    1f6a:	5e 44 04 00 	mov.b	4(r4),	r14	;0x0004(r4)
    1f6e:	7e f0 07 00 	and.b	#7,	r14	;#0x0007
    1f72:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f76:	cf 4e 1d 00 	mov.b	r14,	29(r15)	;0x001d(r15)
        ptcb->OSTCBBitX      = OSMapTbl[ptcb->OSTCBX];
    1f7a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f7e:	5f 4f 1d 00 	mov.b	29(r15),r15	;0x001d(r15)
    1f82:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1f84:	5e 4f 60 15 	mov.b	5472(r15),r14	;0x1560(r15)
    1f88:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f8c:	cf 4e 1f 00 	mov.b	r14,	31(r15)	;0x001f(r15)

#if OS_EVENT_EN
        ptcb->OSTCBEventPtr  = (OS_EVENT *)0;              /* Task is not pending on an event          */
    1f90:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f94:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
    1f98:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f9c:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
    1fa0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fa4:	8f 43 22 00 	mov	#0,	34(r15)	;r3 As==00, 0x0022(r15)
    1fa8:	8f 43 24 00 	mov	#0,	36(r15)	;r3 As==00, 0x0024(r15)
        ptcb->OSTCBCyclesStart = 0L;
    1fac:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fb0:	8f 43 2a 00 	mov	#0,	42(r15)	;r3 As==00, 0x002a(r15)
    1fb4:	8f 43 2c 00 	mov	#0,	44(r15)	;r3 As==00, 0x002c(r15)
        ptcb->OSTCBCyclesTot   = 0L;
    1fb8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fbc:	8f 43 26 00 	mov	#0,	38(r15)	;r3 As==00, 0x0026(r15)
    1fc0:	8f 43 28 00 	mov	#0,	40(r15)	;r3 As==00, 0x0028(r15)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
    1fc4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fc8:	8f 43 2e 00 	mov	#0,	46(r15)	;r3 As==00, 0x002e(r15)
        ptcb->OSTCBStkUsed     = 0L;
    1fcc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fd0:	8f 43 30 00 	mov	#0,	48(r15)	;r3 As==00, 0x0030(r15)
    1fd4:	8f 43 32 00 	mov	#0,	50(r15)	;r3 As==00, 0x0032(r15)
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif

#if OS_VERSION >= 204
        OSTCBInitHook(ptcb);
    1fd8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fdc:	b0 12 48 15 	call	#0x1548	
#endif

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
    1fe0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fe4:	b0 12 30 14 	call	#0x1430	
        
        OS_ENTER_CRITICAL();
    1fe8:	b0 12 16 14 	call	#0x1416	
    1fec:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        OSTCBPrioTbl[prio] = ptcb;
    1ff0:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    1ff4:	0f 5f       	rla	r15		
    1ff6:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    1ffa:	9f 44 02 00 	mov	2(r4),	0(r15)	;0x0002(r4), 0x0000(r15)
    1ffe:	00 00 
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
    2000:	1e 42 28 03 	mov	&0x0328,r14	
    2004:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2008:	8f 4e 0e 00 	mov	r14,	14(r15)	;0x000e(r15)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
    200c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2010:	8f 43 10 00 	mov	#0,	16(r15)	;r3 As==00, 0x0010(r15)
        if (OSTCBList != (OS_TCB *)0) {
    2014:	1f 42 28 03 	mov	&0x0328,r15	
    2018:	0f 93       	tst	r15		
    201a:	05 24       	jz	$+12     	;abs 0x2026
            OSTCBList->OSTCBPrev = ptcb;
    201c:	1f 42 28 03 	mov	&0x0328,r15	
    2020:	9f 44 02 00 	mov	2(r4),	16(r15)	;0x0002(r4), 0x0010(r15)
    2024:	10 00 
        }
        OSTCBList               = ptcb;
    2026:	92 44 02 00 	mov	2(r4),	&0x0328	;0x0002(r4)
    202a:	28 03 
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
    202c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2030:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    2034:	5f 42 7e 03 	mov.b	&0x037e,r15	
    2038:	4f de       	bis.b	r14,	r15	
    203a:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    203e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2042:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    2046:	4d 4f       	mov.b	r15,	r13	
    2048:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    204c:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    2050:	7f f3       	and.b	#-1,	r15	;r3 As==11
    2052:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    2056:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    205a:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    205e:	4f de       	bis.b	r14,	r15	
    2060:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
    2064:	5f 42 32 03 	mov.b	&0x0332,r15	
    2068:	5f 53       	inc.b	r15		
    206a:	c2 4f 32 03 	mov.b	r15,	&0x0332	
        OS_EXIT_CRITICAL();
    206e:	2f 44       	mov	@r4,	r15	
    2070:	b0 12 1c 14 	call	#0x141c	
        return (OS_NO_ERR);
    2074:	4f 43       	clr.b	r15		
    2076:	05 3c       	jmp	$+12     	;abs 0x2082
    }
    OS_EXIT_CRITICAL();
    2078:	2f 44       	mov	@r4,	r15	
    207a:	b0 12 1c 14 	call	#0x141c	
    return (OS_NO_MORE_TCB);
    207e:	7f 40 46 00 	mov.b	#70,	r15	;#0x0046
}
    2082:	31 50 0c 00 	add	#12,	r1	;#0x000c
    2086:	34 41       	pop	r4		
    2088:	30 41       	ret			

0000208a <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *err)
{
    208a:	04 12       	push	r4		
    208c:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    2090:	04 41       	mov	r1,	r4	
    2092:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2096:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    209a:	c4 4d 0a 00 	mov.b	r13,	10(r4)	;0x000a(r4)
    209e:	84 4c 0c 00 	mov	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    20a2:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
    20a6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    20aa:	6f 4f       	mov.b	@r15,	r15	
    20ac:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    20b0:	06 24       	jz	$+14     	;abs 0x20be
        *err = OS_ERR_EVENT_TYPE;
    20b2:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    20b6:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    20ba:	0f 43       	clr	r15		
    20bc:	77 3c       	jmp	$+240    	;abs 0x21ac
    }
    if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
    20be:	5f 44 0a 00 	mov.b	10(r4),	r15	;0x000a(r4)
    20c2:	4f 93       	tst.b	r15		
    20c4:	06 34       	jge	$+14     	;abs 0x20d2
        wait_type &= ~OS_FLAG_CONSUME;
    20c6:	f4 f0 7f 00 	and.b	#127,	10(r4)	;#0x007f, 0x000a(r4)
    20ca:	0a 00 
        consume    = TRUE;
    20cc:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    20d0:	02 3c       	jmp	$+6      	;abs 0x20d6
    } else {
        consume    = FALSE;
    20d2:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    }
/*$PAGE*/
    *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwise.  */
    20d6:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    20da:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OS_ENTER_CRITICAL();
    20de:	b0 12 16 14 	call	#0x1416	
    20e2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (wait_type) {
    20e6:	5f 44 0a 00 	mov.b	10(r4),	r15	;0x000a(r4)
    20ea:	2f 93       	cmp	#2,	r15	;r3 As==10
    20ec:	04 24       	jz	$+10     	;abs 0x20f6
    20ee:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    20f2:	29 24       	jz	$+84     	;abs 0x2146
    20f4:	4f 3c       	jmp	$+160    	;abs 0x2194
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    20f6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    20fa:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    20fe:	0e 4f       	mov	r15,	r14	
    2100:	1e f4 08 00 	and	8(r4),	r14	;0x0008(r4)
    2104:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    2108:	94 94 08 00 	cmp	8(r4),	4(r4)	;0x0008(r4), 0x0004(r4)
    210c:	04 00 
    210e:	10 20       	jnz	$+34     	;abs 0x2130
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    2110:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2114:	13 20       	jnz	$+40     	;abs 0x213c
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    2116:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    211a:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    211e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2122:	3f e3       	inv	r15		
    2124:	0e ff       	and	r15,	r14	
    2126:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    212a:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    212e:	07 3c       	jmp	$+16     	;abs 0x213e
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
    2130:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2134:	ff 40 98 ff 	mov.b	#-104,	0(r15)	;#0xff98, 0x0000(r15)
    2138:	00 00 
    213a:	01 3c       	jmp	$+4      	;abs 0x213e
    switch (wait_type) {
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    213c:	03 43       	nop			
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
    213e:	2f 44       	mov	@r4,	r15	
    2140:	b0 12 1c 14 	call	#0x141c	
    2144:	31 3c       	jmp	$+100    	;abs 0x21a8
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    2146:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    214a:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    214e:	0e 4f       	mov	r15,	r14	
    2150:	1e f4 08 00 	and	8(r4),	r14	;0x0008(r4)
    2154:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    2158:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    215c:	10 24       	jz	$+34     	;abs 0x217e
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    215e:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2162:	13 20       	jnz	$+40     	;abs 0x218a
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    2164:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2168:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    216c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2170:	3f e3       	inv	r15		
    2172:	0e ff       	and	r15,	r14	
    2174:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2178:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    217c:	07 3c       	jmp	$+16     	;abs 0x218c
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
    217e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2182:	ff 40 98 ff 	mov.b	#-104,	0(r15)	;#0xff98, 0x0000(r15)
    2186:	00 00 
    2188:	01 3c       	jmp	$+4      	;abs 0x218c

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    218a:	03 43       	nop			
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
    218c:	2f 44       	mov	@r4,	r15	
    218e:	b0 12 1c 14 	call	#0x141c	
    2192:	0a 3c       	jmp	$+22     	;abs 0x21a8
             OS_EXIT_CRITICAL();
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
    2194:	2f 44       	mov	@r4,	r15	
    2196:	b0 12 1c 14 	call	#0x141c	
             flags_rdy = (OS_FLAGS)0;
    219a:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
             *err      = OS_FLAG_ERR_WAIT_TYPE;
    219e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    21a2:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    21a6:	00 00 
             break;
    }
    return (flags_rdy);
    21a8:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    21ac:	31 50 0e 00 	add	#14,	r1	;#0x000e
    21b0:	34 41       	pop	r4		
    21b2:	30 41       	ret			

000021b4 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *err)
{
    21b4:	04 12       	push	r4		
    21b6:	31 82       	sub	#8,	r1	;r2 As==11
    21b8:	04 41       	mov	r1,	r4	
    21ba:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    21be:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr;



    cpu_sr = 0;                                     /* Prevent compiler warning                        */
    21c2:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
    21c6:	5f 42 86 03 	mov.b	&0x0386,r15	
    21ca:	4f 93       	tst.b	r15		
    21cc:	07 24       	jz	$+16     	;abs 0x21dc
        *err = OS_ERR_CREATE_ISR;                   /* ... can't CREATE from an ISR                    */
    21ce:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    21d2:	ff 40 8d ff 	mov.b	#-115,	0(r15)	;#0xff8d, 0x0000(r15)
    21d6:	00 00 
        return ((OS_FLAG_GRP *)0);
    21d8:	0f 43       	clr	r15		
    21da:	30 3c       	jmp	$+98     	;abs 0x223c
    }
    OS_ENTER_CRITICAL();
    21dc:	b0 12 16 14 	call	#0x1416	
    21e0:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
    21e4:	94 42 74 05 	mov	&0x0574,2(r4)	;0x0002(r4)
    21e8:	02 00 
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
    21ea:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    21ee:	1c 24       	jz	$+58     	;abs 0x2228
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
    21f0:	1f 42 74 05 	mov	&0x0574,r15	
    21f4:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    21f8:	82 4f 74 05 	mov	r15,	&0x0574	
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
    21fc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2200:	ff 40 05 00 	mov.b	#5,	0(r15)	;#0x0005, 0x0000(r15)
    2204:	00 00 
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
    2206:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    220a:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    220e:	04 00 
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
    2210:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2214:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        OS_EXIT_CRITICAL();
    2218:	2f 44       	mov	@r4,	r15	
    221a:	b0 12 1c 14 	call	#0x141c	
        *err                 = OS_NO_ERR;
    221e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2222:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    2226:	08 3c       	jmp	$+18     	;abs 0x2238
    } else {
        OS_EXIT_CRITICAL();
    2228:	2f 44       	mov	@r4,	r15	
    222a:	b0 12 1c 14 	call	#0x141c	
        *err                 = OS_FLAG_GRP_DEPLETED;
    222e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2232:	ff 40 9a ff 	mov.b	#-102,	0(r15)	;#0xff9a, 0x0000(r15)
    2236:	00 00 
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
    2238:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    223c:	31 52       	add	#8,	r1	;r2 As==11
    223e:	34 41       	pop	r4		
    2240:	30 41       	ret			

00002242 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *err)
{
    2242:	04 12       	push	r4		
    2244:	31 50 e6 ff 	add	#-26,	r1	;#0xffe6
    2248:	04 41       	mov	r1,	r4	
    224a:	84 4f 12 00 	mov	r15,	18(r4)	;0x0012(r4)
    224e:	84 4e 14 00 	mov	r14,	20(r4)	;0x0014(r4)
    2252:	c4 4d 16 00 	mov.b	r13,	22(r4)	;0x0016(r4)
    2256:	84 4c 18 00 	mov	r12,	24(r4)	;0x0018(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    225a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
    225e:	5f 42 86 03 	mov.b	&0x0386,r15	
    2262:	4f 93       	tst.b	r15		
    2264:	06 24       	jz	$+14     	;abs 0x2272
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
    2266:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    226a:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((OS_FLAGS)0);
    226e:	0f 43       	clr	r15		
    2270:	fd 3c       	jmp	$+508    	;abs 0x246c
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
    2272:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2276:	6f 4f       	mov.b	@r15,	r15	
    2278:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    227c:	06 24       	jz	$+14     	;abs 0x228a
        *err = OS_ERR_EVENT_TYPE;
    227e:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2282:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    2286:	0f 43       	clr	r15		
    2288:	f1 3c       	jmp	$+484    	;abs 0x246c
    }
    if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
    228a:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    228e:	4f 93       	tst.b	r15		
    2290:	06 34       	jge	$+14     	;abs 0x229e
        wait_type &= ~OS_FLAG_CONSUME;
    2292:	f4 f0 7f 00 	and.b	#127,	22(r4)	;#0x007f, 0x0016(r4)
    2296:	16 00 
        consume    = TRUE;
    2298:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    229c:	02 3c       	jmp	$+6      	;abs 0x22a2
    } else {
        consume    = FALSE;
    229e:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    22a2:	b0 12 16 14 	call	#0x1416	
    22a6:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (wait_type) {
    22aa:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    22ae:	2f 93       	cmp	#2,	r15	;r3 As==10
    22b0:	04 24       	jz	$+10     	;abs 0x22ba
    22b2:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    22b6:	3e 24       	jz	$+126    	;abs 0x2334
    22b8:	79 3c       	jmp	$+244    	;abs 0x23ac
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    22ba:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22be:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    22c2:	0e 4f       	mov	r15,	r14	
    22c4:	1e f4 14 00 	and	20(r4),	r14	;0x0014(r4)
    22c8:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    22cc:	94 94 14 00 	cmp	20(r4),	4(r4)	;0x0014(r4), 0x0004(r4)
    22d0:	04 00 
    22d2:	1e 20       	jnz	$+62     	;abs 0x2310
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    22d4:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    22d8:	0c 20       	jnz	$+26     	;abs 0x22f2
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    22da:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22de:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    22e2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    22e6:	3f e3       	inv	r15		
    22e8:	0e ff       	and	r15,	r14	
    22ea:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22ee:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    22f2:	1f 42 88 03 	mov	&0x0388,r15	
    22f6:	9f 44 04 00 	mov	4(r4),	22(r15)	;0x0004(r4), 0x0016(r15)
    22fa:	16 00 
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    22fc:	2f 44       	mov	@r4,	r15	
    22fe:	b0 12 1c 14 	call	#0x141c	
                 *err                    = OS_NO_ERR;
    2302:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2306:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
                 return (flags_rdy);
    230a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    230e:	ae 3c       	jmp	$+350    	;abs 0x246c
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    2310:	5c 44 16 00 	mov.b	22(r4),	r12	;0x0016(r4)
    2314:	1d 44 14 00 	mov	20(r4),	r13	;0x0014(r4)
    2318:	0e 44       	mov	r4,	r14	
    231a:	3e 50 06 00 	add	#6,	r14	;#0x0006
    231e:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2322:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    2326:	b0 12 42 26 	call	#0x2642	
    232a:	21 53       	incd	r1		
                 OS_EXIT_CRITICAL();
    232c:	2f 44       	mov	@r4,	r15	
    232e:	b0 12 1c 14 	call	#0x141c	
    2332:	49 3c       	jmp	$+148    	;abs 0x23c6
             }
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    2334:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2338:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    233c:	0e 4f       	mov	r15,	r14	
    233e:	1e f4 14 00 	and	20(r4),	r14	;0x0014(r4)
    2342:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    2346:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    234a:	1e 24       	jz	$+62     	;abs 0x2388
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    234c:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2350:	0c 20       	jnz	$+26     	;abs 0x236a
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    2352:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2356:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    235a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    235e:	3f e3       	inv	r15		
    2360:	0e ff       	and	r15,	r14	
    2362:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2366:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    236a:	1f 42 88 03 	mov	&0x0388,r15	
    236e:	9f 44 04 00 	mov	4(r4),	22(r15)	;0x0004(r4), 0x0016(r15)
    2372:	16 00 
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    2374:	2f 44       	mov	@r4,	r15	
    2376:	b0 12 1c 14 	call	#0x141c	
                 *err                    = OS_NO_ERR;
    237a:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    237e:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
                 return (flags_rdy);
    2382:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2386:	72 3c       	jmp	$+230    	;abs 0x246c
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    2388:	5c 44 16 00 	mov.b	22(r4),	r12	;0x0016(r4)
    238c:	1d 44 14 00 	mov	20(r4),	r13	;0x0014(r4)
    2390:	0e 44       	mov	r4,	r14	
    2392:	3e 50 06 00 	add	#6,	r14	;#0x0006
    2396:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    239a:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    239e:	b0 12 42 26 	call	#0x2642	
    23a2:	21 53       	incd	r1		
                 OS_EXIT_CRITICAL();
    23a4:	2f 44       	mov	@r4,	r15	
    23a6:	b0 12 1c 14 	call	#0x141c	
    23aa:	0d 3c       	jmp	$+28     	;abs 0x23c6
             }
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
    23ac:	2f 44       	mov	@r4,	r15	
    23ae:	b0 12 1c 14 	call	#0x141c	
             flags_rdy = (OS_FLAGS)0;
    23b2:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
             *err      = OS_FLAG_ERR_WAIT_TYPE;
    23b6:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    23ba:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    23be:	00 00 
             return (flags_rdy);
    23c0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    23c4:	53 3c       	jmp	$+168    	;abs 0x246c
    }
    OS_Sched();                                            /* Find next HPT ready to run               */
    23c6:	b0 12 bc 1d 	call	#0x1dbc	
    OS_ENTER_CRITICAL();
    23ca:	b0 12 16 14 	call	#0x1416	
    23ce:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {                   /* Have we timed-out?                       */
    23d2:	1f 42 88 03 	mov	&0x0388,r15	
    23d6:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    23da:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    23dc:	1a 20       	jnz	$+54     	;abs 0x2412
        OSTCBCur->OSTCBPendTO = FALSE;
    23de:	1f 42 88 03 	mov	&0x0388,r15	
    23e2:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
        OS_FlagUnlink(&node);
    23e6:	0f 44       	mov	r4,	r15	
    23e8:	3f 50 06 00 	add	#6,	r15	;#0x0006
    23ec:	b0 12 4e 28 	call	#0x284e	
        OSTCBCur->OSTCBStat   = OS_STAT_RDY;               /* Yes, make task ready-to-run              */
    23f0:	1f 42 88 03 	mov	&0x0388,r15	
    23f4:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
        OS_EXIT_CRITICAL();
    23f8:	2f 44       	mov	@r4,	r15	
    23fa:	b0 12 1c 14 	call	#0x141c	
        flags_rdy             = (OS_FLAGS)0;
    23fe:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
        *err                  = OS_TIMEOUT;                /* Indicate that we timed-out waiting       */
    2402:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2406:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    240a:	00 00 
        return (flags_rdy);
    240c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2410:	2d 3c       	jmp	$+92     	;abs 0x246c
    } 
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
    2412:	1f 42 88 03 	mov	&0x0388,r15	
    2416:	94 4f 16 00 	mov	22(r15),4(r4)	;0x0016(r15), 0x0004(r4)
    241a:	04 00 
    if (consume == TRUE) {                                 /* See if we need to consume the flags      */
    241c:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2420:	1c 20       	jnz	$+58     	;abs 0x245a
        switch (wait_type) {
    2422:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    2426:	2f 83       	decd	r15		
    2428:	2f 93       	cmp	#2,	r15	;r3 As==10
    242a:	0d 2c       	jc	$+28     	;abs 0x2446
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
    242c:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2430:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2434:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2438:	3f e3       	inv	r15		
    243a:	0e ff       	and	r15,	r14	
    243c:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2440:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    2444:	0a 3c       	jmp	$+22     	;abs 0x245a
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
    2446:	2f 44       	mov	@r4,	r15	
    2448:	b0 12 1c 14 	call	#0x141c	
                 *err = OS_FLAG_ERR_WAIT_TYPE;
    244c:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2450:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    2454:	00 00 
                 return ((OS_FLAGS)0);
    2456:	0f 43       	clr	r15		
    2458:	09 3c       	jmp	$+20     	;abs 0x246c
        }
    }
    OS_EXIT_CRITICAL();
    245a:	2f 44       	mov	@r4,	r15	
    245c:	b0 12 1c 14 	call	#0x141c	
    *err = OS_NO_ERR;                                      /* Event(s) must have occurred              */
    2460:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2464:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (flags_rdy);
    2468:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    246c:	31 50 1a 00 	add	#26,	r1	;#0x001a
    2470:	34 41       	pop	r4		
    2472:	30 41       	ret			

00002474 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
    2474:	04 12       	push	r4		
    2476:	21 82       	sub	#4,	r1	;r2 As==10
    2478:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    247a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    247e:	b0 12 16 14 	call	#0x1416	
    2482:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    flags = OSTCBCur->OSTCBFlagsRdy;
    2486:	1f 42 88 03 	mov	&0x0388,r15	
    248a:	94 4f 16 00 	mov	22(r15),2(r4)	;0x0016(r15), 0x0002(r4)
    248e:	02 00 
    OS_EXIT_CRITICAL();
    2490:	2f 44       	mov	@r4,	r15	
    2492:	b0 12 1c 14 	call	#0x141c	
    return (flags);
    2496:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    249a:	21 52       	add	#4,	r1	;r2 As==10
    249c:	34 41       	pop	r4		
    249e:	30 41       	ret			

000024a0 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *err)
{
    24a0:	04 12       	push	r4		
    24a2:	31 50 ec ff 	add	#-20,	r1	;#0xffec
    24a6:	04 41       	mov	r1,	r4	
    24a8:	84 4f 0c 00 	mov	r15,	12(r4)	;0x000c(r4)
    24ac:	84 4e 0e 00 	mov	r14,	14(r4)	;0x000e(r4)
    24b0:	c4 4d 10 00 	mov.b	r13,	16(r4)	;0x0010(r4)
    24b4:	84 4c 12 00 	mov	r12,	18(r4)	;0x0012(r4)
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                      /* Prevent compiler warning                       */
    24b8:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
    24bc:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24c0:	6f 4f       	mov.b	@r15,	r15	
    24c2:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    24c6:	06 24       	jz	$+14     	;abs 0x24d4
        *err = OS_ERR_EVENT_TYPE;
    24c8:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    24cc:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    24d0:	0f 43       	clr	r15		
    24d2:	b3 3c       	jmp	$+360    	;abs 0x263a
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    24d4:	b0 12 16 14 	call	#0x1416	
    24d8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (opt) {
    24dc:	5f 44 10 00 	mov.b	16(r4),	r15	;0x0010(r4)
    24e0:	0f 93       	tst	r15		
    24e2:	03 24       	jz	$+8      	;abs 0x24ea
    24e4:	1f 93       	cmp	#1,	r15	;r3 As==01
    24e6:	0e 24       	jz	$+30     	;abs 0x2504
    24e8:	19 3c       	jmp	$+52     	;abs 0x251c
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
    24ea:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24ee:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    24f2:	1f 44 0e 00 	mov	14(r4),	r15	;0x000e(r4)
    24f6:	3f e3       	inv	r15		
    24f8:	0e ff       	and	r15,	r14	
    24fa:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24fe:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    2502:	16 3c       	jmp	$+46     	;abs 0x2530
             break;

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
    2504:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2508:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    250c:	0e 4f       	mov	r15,	r14	
    250e:	1e d4 0e 00 	bis	14(r4),	r14	;0x000e(r4)
    2512:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2516:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    251a:	0a 3c       	jmp	$+22     	;abs 0x2530
             break;

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
    251c:	2f 44       	mov	@r4,	r15	
    251e:	b0 12 1c 14 	call	#0x141c	
             *err = OS_FLAG_INVALID_OPT;
    2522:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2526:	ff 40 99 ff 	mov.b	#-103,	0(r15)	;#0xff99, 0x0000(r15)
    252a:	00 00 
             return ((OS_FLAGS)0);
    252c:	0f 43       	clr	r15		
    252e:	85 3c       	jmp	$+268    	;abs 0x263a
    }
    sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
    2530:	c4 43 08 00 	mov.b	#0,	8(r4)	;r3 As==00, 0x0008(r4)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    2534:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2538:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    253c:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)
    2540:	5f 3c       	jmp	$+192    	;abs 0x2600
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
        switch (pnode->OSFlagNodeWaitType) {
    2542:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2546:	5f 4f 0a 00 	mov.b	10(r15),r15	;0x000a(r15)
    254a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    254c:	2f 93       	cmp	#2,	r15	;r3 As==10
    254e:	04 24       	jz	$+10     	;abs 0x2558
    2550:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    2554:	22 24       	jz	$+70     	;abs 0x259a
    2556:	3e 3c       	jmp	$+126    	;abs 0x25d4
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
    2558:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    255c:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2560:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2564:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2568:	0d 4e       	mov	r14,	r13	
    256a:	0d ff       	and	r15,	r13	
    256c:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
    2570:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2574:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2578:	1f 94 04 00 	cmp	4(r4),	r15	;0x0004(r4)
    257c:	35 20       	jnz	$+108    	;abs 0x25e8
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    257e:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2582:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2586:	b0 12 a6 27 	call	#0x27a6	
    258a:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
                     if (rdy == TRUE) {                     
    258e:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2592:	2c 20       	jnz	$+90     	;abs 0x25ec
                         sched = TRUE;                        /* When done we will reschedule          */
    2594:	d4 43 08 00 	mov.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    2598:	2e 3c       	jmp	$+94     	;abs 0x25f6
                     }
                 }
                 break;

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
    259a:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    259e:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    25a2:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    25a6:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    25aa:	0d 4e       	mov	r14,	r13	
    25ac:	0d ff       	and	r15,	r13	
    25ae:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
                 if (flags_rdy != (OS_FLAGS)0) {
    25b2:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    25b6:	1c 24       	jz	$+58     	;abs 0x25f0
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    25b8:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    25bc:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    25c0:	b0 12 a6 27 	call	#0x27a6	
    25c4:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
                     if (rdy == TRUE) {                      
    25c8:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    25cc:	13 20       	jnz	$+40     	;abs 0x25f4
                         sched = TRUE;                        /* When done we will reschedule          */
    25ce:	d4 43 08 00 	mov.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    25d2:	11 3c       	jmp	$+36     	;abs 0x25f6
                     }
                 }
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
    25d4:	2f 44       	mov	@r4,	r15	
    25d6:	b0 12 1c 14 	call	#0x141c	
                 *err = OS_FLAG_ERR_WAIT_TYPE;
    25da:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    25de:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    25e2:	00 00 
                 return ((OS_FLAGS)0);
    25e4:	0f 43       	clr	r15		
    25e6:	29 3c       	jmp	$+84     	;abs 0x263a
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                     
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
    25e8:	03 43       	nop			
    25ea:	05 3c       	jmp	$+12     	;abs 0x25f6
    25ec:	03 43       	nop			
    25ee:	03 3c       	jmp	$+8      	;abs 0x25f6
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                      
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
    25f0:	03 43       	nop			
    25f2:	01 3c       	jmp	$+4      	;abs 0x25f6
    25f4:	03 43       	nop			
            default:
                 OS_EXIT_CRITICAL();
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    25f6:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    25fa:	2f 4f       	mov	@r15,	r15	
    25fc:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)
             *err = OS_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
    2600:	84 93 0a 00 	tst	10(r4)		;0x000a(r4)
    2604:	9e 23       	jnz	$-194    	;abs 0x2542
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    2606:	2f 44       	mov	@r4,	r15	
    2608:	b0 12 1c 14 	call	#0x141c	
    if (sched == TRUE) {
    260c:	d4 93 08 00 	cmp.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    2610:	02 20       	jnz	$+6      	;abs 0x2616
        OS_Sched();
    2612:	b0 12 bc 1d 	call	#0x1dbc	
    }
    OS_ENTER_CRITICAL();
    2616:	b0 12 16 14 	call	#0x1416	
    261a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    flags_cur = pgrp->OSFlagFlags;
    261e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2622:	94 4f 04 00 	mov	4(r15),	6(r4)	;0x0004(r15), 0x0006(r4)
    2626:	06 00 
    OS_EXIT_CRITICAL();
    2628:	2f 44       	mov	@r4,	r15	
    262a:	b0 12 1c 14 	call	#0x141c	
    *err      = OS_NO_ERR;
    262e:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2632:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (flags_cur);
    2636:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
}
    263a:	31 50 14 00 	add	#20,	r1	;#0x0014
    263e:	34 41       	pop	r4		
    2640:	30 41       	ret			

00002642 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
    2642:	04 12       	push	r4		
    2644:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    2648:	04 41       	mov	r1,	r4	
    264a:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    264e:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    2652:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
    2656:	c4 4c 0a 00 	mov.b	r12,	10(r4)	;0x000a(r4)
    OS_FLAG_NODE  *pnode_next;
	INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
    265a:	1f 42 88 03 	mov	&0x0388,r15	
    265e:	1e 42 88 03 	mov	&0x0388,r14	
    2662:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    2666:	7e d0 20 00 	bis.b	#32,	r14	;#0x0020
    266a:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO     = FALSE;
    266e:	1f 42 88 03 	mov	&0x0388,r15	
    2672:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
    2676:	1f 42 88 03 	mov	&0x0388,r15	
    267a:	9f 44 10 00 	mov	16(r4),	24(r15)	;0x0010(r4), 0x0018(r15)
    267e:	18 00 
    OSTCBCur->OSTCBEventPtr   = (OS_EVENT *)0;
    2680:	1f 42 88 03 	mov	&0x0388,r15	
    2684:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
    2688:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    268c:	9f 44 08 00 	mov	8(r4),	8(r15)	;0x0008(r4), 0x0008(r15)
    2690:	08 00 
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
    2692:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2696:	df 44 0a 00 	mov.b	10(r4),	10(r15)	;0x000a(r4), 0x000a(r15)
    269a:	0a 00 
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
    269c:	1e 42 88 03 	mov	&0x0388,r14	
    26a0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    26a4:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
    26a8:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    26ac:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    26b0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    26b4:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    pnode->OSFlagNodePrev     = (void *)0;
    26b8:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    26bc:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
    26c0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    26c4:	9f 44 04 00 	mov	4(r4),	6(r15)	;0x0004(r4), 0x0006(r15)
    26c8:	06 00 
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    26ca:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    26ce:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    26d2:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
    26d6:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    26da:	05 24       	jz	$+12     	;abs 0x26e6
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
    26dc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    26e0:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    26e4:	02 00 
    }
    pgrp->OSFlagWaitList = (void *)pnode;
    26e6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    26ea:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    26ee:	02 00 
                                                      
    y            =  OSTCBCur->OSTCBY;		 	      /* Suspend current task until flag(s) received   */
    26f0:	1f 42 88 03 	mov	&0x0388,r15	
    26f4:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    26f8:	00 00 
	OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
    26fa:	6d 44       	mov.b	@r4,	r13	
    26fc:	6f 44       	mov.b	@r4,	r15	
    26fe:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    2702:	4e 4f       	mov.b	r15,	r14	
    2704:	1f 42 88 03 	mov	&0x0388,r15	
    2708:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    270c:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    270e:	4f fe       	and.b	r14,	r15	
    2710:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
    if (OSRdyTbl[y] == 0x00) {
    2714:	6f 44       	mov.b	@r4,	r15	
    2716:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    271a:	4f 93       	tst.b	r15		
    271c:	0b 20       	jnz	$+24     	;abs 0x2734
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
    271e:	1f 42 88 03 	mov	&0x0388,r15	
    2722:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    2726:	4e 4f       	mov.b	r15,	r14	
    2728:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    272a:	5f 42 7e 03 	mov.b	&0x037e,r15	
    272e:	4f fe       	and.b	r14,	r15	
    2730:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
    }
}
    2734:	31 50 0c 00 	add	#12,	r1	;#0x000c
    2738:	34 41       	pop	r4		
    273a:	30 41       	ret			

0000273c <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
    273c:	04 12       	push	r4		
    273e:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2742:	04 41       	mov	r1,	r4	
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    2744:	3f 40 14 03 	mov	#788,	r15	;#0x0314
    2748:	3e 40 12 00 	mov	#18,	r14	;#0x0012
    274c:	b0 12 56 1d 	call	#0x1d56	
    pgrp1 = &OSFlagTbl[0];
    2750:	b4 40 14 03 	mov	#788,	2(r4)	;#0x0314, 0x0002(r4)
    2754:	02 00 
    pgrp2 = &OSFlagTbl[1];
    2756:	b4 40 1a 03 	mov	#794,	0(r4)	;#0x031a, 0x0000(r4)
    275a:	00 00 
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
    275c:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    2760:	10 3c       	jmp	$+34     	;abs 0x2782
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    2762:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2766:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
    276a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    276e:	af 44 02 00 	mov	@r4,	2(r15)	;0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
    2772:	b4 50 06 00 	add	#6,	2(r4)	;#0x0006, 0x0002(r4)
    2776:	02 00 
        pgrp2++;
    2778:	b4 50 06 00 	add	#6,	0(r4)	;#0x0006, 0x0000(r4)
    277c:	00 00 


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
    277e:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    2782:	a4 93 04 00 	cmp	#2,	4(r4)	;r3 As==10, 0x0004(r4)
    2786:	ed 2b       	jnc	$-36     	;abs 0x2762
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    2788:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    278c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    pgrp1->OSFlagWaitList = (void *)0;
    2790:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2794:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
    OSFlagFreeList        = (OS_FLAG_GRP *)&OSFlagTbl[0];
    2798:	b2 40 14 03 	mov	#788,	&0x0574	;#0x0314
    279c:	74 05 
#endif
}
    279e:	31 50 06 00 	add	#6,	r1	;#0x0006
    27a2:	34 41       	pop	r4		
    27a4:	30 41       	ret			

000027a6 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
    27a6:	04 12       	push	r4		
    27a8:	31 82       	sub	#8,	r1	;r2 As==11
    27aa:	04 41       	mov	r1,	r4	
    27ac:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    27b0:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
    27b4:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    27b8:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    27bc:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    ptcb->OSTCBDly      = 0;
    27c0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27c4:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)
    ptcb->OSTCBFlagsRdy = flags_rdy;
    27c8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27cc:	9f 44 06 00 	mov	6(r4),	22(r15)	;0x0006(r4), 0x0016(r15)
    27d0:	16 00 
    ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
    27d2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27d6:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    27da:	4e 4f       	mov.b	r15,	r14	
    27dc:	7e f0 df ff 	and.b	#-33,	r14	;#0xffdf
    27e0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27e4:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    ptcb->OSTCBPendTO   = FALSE;
    27e8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27ec:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
    27f0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27f4:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    27f8:	4f 93       	tst.b	r15		
    27fa:	1f 20       	jnz	$+64     	;abs 0x283a
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
    27fc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2800:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    2804:	5f 42 7e 03 	mov.b	&0x037e,r15	
    2808:	4f de       	bis.b	r14,	r15	
    280a:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    280e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2812:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    2816:	4d 4f       	mov.b	r15,	r13	
    2818:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    281c:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    2820:	7f f3       	and.b	#-1,	r15	;r3 As==11
    2822:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    2826:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    282a:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    282e:	4f de       	bis.b	r14,	r15	
    2830:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        sched                   = TRUE;
    2834:	d4 43 00 00 	mov.b	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    2838:	02 3c       	jmp	$+6      	;abs 0x283e
    } else {
        sched                   = FALSE;
    283a:	c4 43 00 00 	mov.b	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    OS_FlagUnlink(pnode);
    283e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2842:	b0 12 4e 28 	call	#0x284e	
    return (sched);
    2846:	6f 44       	mov.b	@r4,	r15	
}
    2848:	31 52       	add	#8,	r1	;r2 As==11
    284a:	34 41       	pop	r4		
    284c:	30 41       	ret			

0000284e <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
    284e:	04 12       	push	r4		
    2850:	31 82       	sub	#8,	r1	;r2 As==11
    2852:	04 41       	mov	r1,	r4	
    2854:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    2858:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    285c:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    2860:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    2864:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2868:	2f 4f       	mov	@r15,	r15	
    286a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
    286e:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2872:	11 20       	jnz	$+36     	;abs 0x2896
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
    2874:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2878:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    287c:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
    2880:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2884:	af 44 02 00 	mov	@r4,	2(r15)	;0x0002(r15)
        if (pnode_next != (OS_FLAG_NODE *)0) {
    2888:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    288c:	10 24       	jz	$+34     	;abs 0x28ae
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
    288e:	2f 44       	mov	@r4,	r15	
    2890:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    2894:	0d 3c       	jmp	$+28     	;abs 0x28b0
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
    2896:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    289a:	af 44 00 00 	mov	@r4,	0(r15)	;0x0000(r15)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
    289e:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    28a2:	06 24       	jz	$+14     	;abs 0x28b0
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
    28a4:	2f 44       	mov	@r4,	r15	
    28a6:	9f 44 02 00 	mov	2(r4),	2(r15)	;0x0002(r4), 0x0002(r15)
    28aa:	02 00 
    28ac:	01 3c       	jmp	$+4      	;abs 0x28b0
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
    28ae:	03 43       	nop			
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
#endif
}
    28b0:	31 52       	add	#8,	r1	;r2 As==11
    28b2:	34 41       	pop	r4		
    28b4:	30 41       	ret			

000028b6 <OSMboxAccept>:
*********************************************************************************************************
*/

#if OS_MBOX_ACCEPT_EN > 0
void  *OSMboxAccept (OS_EVENT *pevent)
{
    28b6:	04 12       	push	r4		
    28b8:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    28bc:	04 41       	mov	r1,	r4	
    28be:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                               /* Allocate storage for CPU status register  */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                           /* Prevent compiler warning                  */
    28c2:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
    28c6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    28ca:	6f 4f       	mov.b	@r15,	r15	
    28cc:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    28ce:	02 24       	jz	$+6      	;abs 0x28d4
        return ((void *)0);
    28d0:	0f 43       	clr	r15		
    28d2:	12 3c       	jmp	$+38     	;abs 0x28f8
    }
    OS_ENTER_CRITICAL();
    28d4:	b0 12 16 14 	call	#0x1416	
    28d8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    msg                = pevent->OSEventPtr;
    28dc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    28e0:	94 4f 04 00 	mov	4(r15),	2(r4)	;0x0004(r15), 0x0002(r4)
    28e4:	02 00 
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
    28e6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    28ea:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
    OS_EXIT_CRITICAL();
    28ee:	2f 44       	mov	@r4,	r15	
    28f0:	b0 12 1c 14 	call	#0x141c	
    return (msg);                                         /* Return the message received (or NULL)     */
    28f4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    28f8:	31 50 06 00 	add	#6,	r1	;#0x0006
    28fc:	34 41       	pop	r4		
    28fe:	30 41       	ret			

00002900 <OSMboxCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSMboxCreate (void *msg)
{
    2900:	04 12       	push	r4		
    2902:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2906:	04 41       	mov	r1,	r4	
    2908:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    290c:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    2910:	5f 42 86 03 	mov.b	&0x0386,r15	
    2914:	4f 93       	tst.b	r15		
    2916:	02 24       	jz	$+6      	;abs 0x291c
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    2918:	0f 43       	clr	r15		
    291a:	2a 3c       	jmp	$+86     	;abs 0x2970
    }
    OS_ENTER_CRITICAL();
    291c:	b0 12 16 14 	call	#0x1416	
    2920:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
    2924:	94 42 84 03 	mov	&0x0384,2(r4)	;0x0002(r4)
    2928:	02 00 
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
    292a:	1f 42 84 03 	mov	&0x0384,r15	
    292e:	0f 93       	tst	r15		
    2930:	06 24       	jz	$+14     	;abs 0x293e
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    2932:	1f 42 84 03 	mov	&0x0384,r15	
    2936:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    293a:	82 4f 84 03 	mov	r15,	&0x0384	
    }
    OS_EXIT_CRITICAL();
    293e:	2f 44       	mov	@r4,	r15	
    2940:	b0 12 1c 14 	call	#0x141c	
    if (pevent != (OS_EVENT *)0) {
    2944:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2948:	11 24       	jz	$+36     	;abs 0x296c
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
    294a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    294e:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        pevent->OSEventCnt     = 0;
    2952:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2956:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
        pevent->OSEventPtr     = msg;            /* Deposit message in event control block             */
    295a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    295e:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2962:	04 00 
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);
    2964:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2968:	b0 12 a0 1b 	call	#0x1ba0	
    }
    return (pevent);                             /* Return pointer to event control block              */
    296c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    2970:	31 50 06 00 	add	#6,	r1	;#0x0006
    2974:	34 41       	pop	r4		
    2976:	30 41       	ret			

00002978 <OSMboxPend>:
*                            if you didn't pass the proper pointer to the event control block.
*********************************************************************************************************
*/

void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    2978:	04 12       	push	r4		
    297a:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    297e:	04 41       	mov	r1,	r4	
    2980:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2984:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    2988:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    298c:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
    2990:	5f 42 86 03 	mov.b	&0x0386,r15	
    2994:	4f 93       	tst.b	r15		
    2996:	06 24       	jz	$+14     	;abs 0x29a4
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
    2998:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    299c:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((void *)0);
    29a0:	0f 43       	clr	r15		
    29a2:	72 3c       	jmp	$+230    	;abs 0x2a88
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    29a4:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    29a8:	6f 4f       	mov.b	@r15,	r15	
    29aa:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    29ac:	06 24       	jz	$+14     	;abs 0x29ba
        *err = OS_ERR_EVENT_TYPE;
    29ae:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    29b2:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((void *)0);
    29b6:	0f 43       	clr	r15		
    29b8:	67 3c       	jmp	$+208    	;abs 0x2a88
    }
    OS_ENTER_CRITICAL();
    29ba:	b0 12 16 14 	call	#0x1416	
    29be:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    msg = pevent->OSEventPtr;
    29c2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    29c6:	94 4f 04 00 	mov	4(r15),	2(r4)	;0x0004(r15), 0x0002(r4)
    29ca:	02 00 
    if (msg != (void *)0) {                           /* See if there is already a message             */
    29cc:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    29d0:	0e 24       	jz	$+30     	;abs 0x29ee
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
    29d2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    29d6:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
        OS_EXIT_CRITICAL();
    29da:	2f 44       	mov	@r4,	r15	
    29dc:	b0 12 1c 14 	call	#0x141c	
        *err = OS_NO_ERR;
    29e0:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    29e4:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        return (msg);                                 /* Return the message received (or NULL)         */
    29e8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    29ec:	4d 3c       	jmp	$+156    	;abs 0x2a88
    }
    OSTCBCur->OSTCBStat  |= OS_STAT_MBOX;             /* Message not available, task will pend         */
    29ee:	1f 42 88 03 	mov	&0x0388,r15	
    29f2:	1e 42 88 03 	mov	&0x0388,r14	
    29f6:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    29fa:	6e d3       	bis.b	#2,	r14	;r3 As==10
    29fc:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO = FALSE;
    2a00:	1f 42 88 03 	mov	&0x0388,r15	
    2a04:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly    = timeout;                  /* Load timeout in TCB                           */
    2a08:	1f 42 88 03 	mov	&0x0388,r15	
    2a0c:	9f 44 06 00 	mov	6(r4),	24(r15)	;0x0006(r4), 0x0018(r15)
    2a10:	18 00 
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    2a12:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2a16:	b0 12 5e 1a 	call	#0x1a5e	
    OS_EXIT_CRITICAL();
    2a1a:	2f 44       	mov	@r4,	r15	
    2a1c:	b0 12 1c 14 	call	#0x141c	
    OS_Sched();                                       /* Find next highest priority task ready to run  */
    2a20:	b0 12 bc 1d 	call	#0x1dbc	
    OS_ENTER_CRITICAL();
    2a24:	b0 12 16 14 	call	#0x1416	
    2a28:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we were given the message              */
    2a2c:	1f 42 88 03 	mov	&0x0388,r15	
    2a30:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    2a34:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2a36:	0e 20       	jnz	$+30     	;abs 0x2a54
        OS_EventTO(pevent);                           /* Timed out, Make task ready                    */
    2a38:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2a3c:	b0 12 0e 1b 	call	#0x1b0e	
        OS_EXIT_CRITICAL();
    2a40:	2f 44       	mov	@r4,	r15	
    2a42:	b0 12 1c 14 	call	#0x141c	
        *err = OS_TIMEOUT;                            /* Indicate that a timeout occured               */
    2a46:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2a4a:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    2a4e:	00 00 
        return ((void *)0);                           /* Return a NULL message                         */
    2a50:	0f 43       	clr	r15		
    2a52:	1a 3c       	jmp	$+54     	;abs 0x2a88
    }
    msg                     = OSTCBCur->OSTCBMsg;
    2a54:	1f 42 88 03 	mov	&0x0388,r15	
    2a58:	94 4f 14 00 	mov	20(r15),2(r4)	;0x0014(r15), 0x0002(r4)
    2a5c:	02 00 
    OSTCBCur->OSTCBMsg      = (void *)0;              /* Yes, clear message received                   */
    2a5e:	1f 42 88 03 	mov	&0x0388,r15	
    2a62:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    2a66:	1f 42 88 03 	mov	&0x0388,r15	
    2a6a:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;          /* No longer waiting for event                   */
    2a6e:	1f 42 88 03 	mov	&0x0388,r15	
    2a72:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    2a76:	2f 44       	mov	@r4,	r15	
    2a78:	b0 12 1c 14 	call	#0x141c	
    *err                    = OS_NO_ERR;
    2a7c:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2a80:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (msg);                                     /* Return the message received                   */
    2a84:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    2a88:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2a8c:	34 41       	pop	r4		
    2a8e:	30 41       	ret			

00002a90 <OSMboxPost>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_EN > 0
INT8U  OSMboxPost (OS_EVENT *pevent, void *msg)
{
    2a90:	04 12       	push	r4		
    2a92:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2a96:	04 41       	mov	r1,	r4	
    2a98:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    2a9c:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
    

    
    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2aa0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    2aa4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2aa8:	6f 4f       	mov.b	@r15,	r15	
    2aaa:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2aac:	02 24       	jz	$+6      	;abs 0x2ab2
        return (OS_ERR_EVENT_TYPE);
    2aae:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2ab0:	2d 3c       	jmp	$+92     	;abs 0x2b0c
    }
    OS_ENTER_CRITICAL();
    2ab2:	b0 12 16 14 	call	#0x1416	
    2ab6:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                     /* See if any task pending on mailbox        */
    2aba:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2abe:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2ac2:	4f 93       	tst.b	r15		
    2ac4:	0e 24       	jz	$+30     	;abs 0x2ae2
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX); /* Ready HPT waiting on event                */
    2ac6:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2aca:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ace:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2ad0:	b0 12 1c 19 	call	#0x191c	
        OS_EXIT_CRITICAL();
    2ad4:	2f 44       	mov	@r4,	r15	
    2ad6:	b0 12 1c 14 	call	#0x141c	
        OS_Sched();                                   /* Find highest priority task ready to run       */
    2ada:	b0 12 bc 1d 	call	#0x1dbc	
        return (OS_NO_ERR);
    2ade:	4f 43       	clr.b	r15		
    2ae0:	15 3c       	jmp	$+44     	;abs 0x2b0c
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
    2ae2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ae6:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2aea:	0f 93       	tst	r15		
    2aec:	06 24       	jz	$+14     	;abs 0x2afa
        OS_EXIT_CRITICAL();
    2aee:	2f 44       	mov	@r4,	r15	
    2af0:	b0 12 1c 14 	call	#0x141c	
        return (OS_MBOX_FULL);
    2af4:	7f 40 14 00 	mov.b	#20,	r15	;#0x0014
    2af8:	09 3c       	jmp	$+20     	;abs 0x2b0c
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
    2afa:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2afe:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2b02:	04 00 
    OS_EXIT_CRITICAL();
    2b04:	2f 44       	mov	@r4,	r15	
    2b06:	b0 12 1c 14 	call	#0x141c	
    return (OS_NO_ERR);
    2b0a:	4f 43       	clr.b	r15		
}
    2b0c:	31 50 06 00 	add	#6,	r1	;#0x0006
    2b10:	34 41       	pop	r4		
    2b12:	30 41       	ret			

00002b14 <OSMboxPostOpt>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_OPT_EN > 0
INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
    2b14:	04 12       	push	r4		
    2b16:	31 82       	sub	#8,	r1	;r2 As==11
    2b18:	04 41       	mov	r1,	r4	
    2b1a:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    2b1e:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    2b22:	c4 4d 06 00 	mov.b	r13,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2b26:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    2b2a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b2e:	6f 4f       	mov.b	@r15,	r15	
    2b30:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2b32:	02 24       	jz	$+6      	;abs 0x2b38
        return (OS_ERR_EVENT_TYPE);
    2b34:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2b36:	41 3c       	jmp	$+132    	;abs 0x2bba
    }
    OS_ENTER_CRITICAL();
    2b38:	b0 12 16 14 	call	#0x1416	
    2b3c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on mailbox            */
    2b40:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b44:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2b48:	4f 93       	tst.b	r15		
    2b4a:	22 24       	jz	$+70     	;abs 0x2b90
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
    2b4c:	5f 44 06 00 	mov.b	6(r4),	r15	;0x0006(r4)
    2b50:	1f f3       	and	#1,	r15	;r3 As==01
    2b52:	4f 93       	tst.b	r15		
    2b54:	0f 24       	jz	$+32     	;abs 0x2b74
    2b56:	07 3c       	jmp	$+16     	;abs 0x2b66
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on mailbox     */           
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);    
    2b58:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2b5c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b60:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2b62:	b0 12 1c 19 	call	#0x191c	
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on mailbox            */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on mailbox     */           
    2b66:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b6a:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2b6e:	4f 93       	tst.b	r15		
    2b70:	f3 23       	jnz	$-24     	;abs 0x2b58
    2b72:	07 3c       	jmp	$+16     	;abs 0x2b82
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);    
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);  /* No,  Post to HPT waiting on mbox     */
    2b74:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2b78:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b7c:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2b7e:	b0 12 1c 19 	call	#0x191c	
        }
        OS_EXIT_CRITICAL();
    2b82:	2f 44       	mov	@r4,	r15	
    2b84:	b0 12 1c 14 	call	#0x141c	
        OS_Sched();                                            /* Find HPT ready to run                */
    2b88:	b0 12 bc 1d 	call	#0x1dbc	
        return (OS_NO_ERR);
    2b8c:	4f 43       	clr.b	r15		
    2b8e:	15 3c       	jmp	$+44     	;abs 0x2bba
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
    2b90:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b94:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2b98:	0f 93       	tst	r15		
    2b9a:	06 24       	jz	$+14     	;abs 0x2ba8
        OS_EXIT_CRITICAL();
    2b9c:	2f 44       	mov	@r4,	r15	
    2b9e:	b0 12 1c 14 	call	#0x141c	
        return (OS_MBOX_FULL);
    2ba2:	7f 40 14 00 	mov.b	#20,	r15	;#0x0014
    2ba6:	09 3c       	jmp	$+20     	;abs 0x2bba
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
    2ba8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bac:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2bb0:	04 00 
    OS_EXIT_CRITICAL();
    2bb2:	2f 44       	mov	@r4,	r15	
    2bb4:	b0 12 1c 14 	call	#0x141c	
    return (OS_NO_ERR);
    2bb8:	4f 43       	clr.b	r15		
}
    2bba:	31 52       	add	#8,	r1	;r2 As==11
    2bbc:	34 41       	pop	r4		
    2bbe:	30 41       	ret			

00002bc0 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *err)
{
    2bc0:	04 12       	push	r4		
    2bc2:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    2bc6:	04 41       	mov	r1,	r4	
    2bc8:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2bcc:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2bd0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
    2bd4:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2bd8:	6f 4f       	mov.b	@r15,	r15	
    2bda:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    2bdc:	06 24       	jz	$+14     	;abs 0x2bea
        *err = OS_ERR_EVENT_TYPE;
    2bde:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2be2:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((void *)0);
    2be6:	0f 43       	clr	r15		
    2be8:	49 3c       	jmp	$+148    	;abs 0x2c7c
    }
    OS_ENTER_CRITICAL();
    2bea:	b0 12 16 14 	call	#0x1416	
    2bee:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    2bf2:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2bf6:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2bfa:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
    2bfe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c02:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2c06:	0f 93       	tst	r15		
    2c08:	2d 24       	jz	$+92     	;abs 0x2c64
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
    2c0a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c0e:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2c12:	a4 4f 04 00 	mov	@r15,	4(r4)	;0x0004(r4)
    2c16:	0e 4f       	mov	r15,	r14	
    2c18:	2e 53       	incd	r14		
    2c1a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c1e:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
    2c22:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c26:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2c2a:	0e 4f       	mov	r15,	r14	
    2c2c:	3e 53       	add	#-1,	r14	;r3 As==11
    2c2e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c32:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
    2c36:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c3a:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    2c3e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c42:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2c46:	0e 9f       	cmp	r15,	r14	
    2c48:	08 20       	jnz	$+18     	;abs 0x2c5a
            pq->OSQOut = pq->OSQStart;
    2c4a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c4e:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2c52:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c56:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        *err = OS_NO_ERR;
    2c5a:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2c5e:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    2c62:	07 3c       	jmp	$+16     	;abs 0x2c72
    } else {
        *err = OS_Q_EMPTY;
    2c64:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2c68:	ff 40 1f 00 	mov.b	#31,	0(r15)	;#0x001f, 0x0000(r15)
    2c6c:	00 00 
        msg  = (void *)0;                        /* Queue is empty                                     */
    2c6e:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    }
    OS_EXIT_CRITICAL();
    2c72:	2f 44       	mov	@r4,	r15	
    2c74:	b0 12 1c 14 	call	#0x141c	
    return (msg);                                /* Return message received (or NULL)                  */
    2c78:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2c7c:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2c80:	34 41       	pop	r4		
    2c82:	30 41       	ret			

00002c84 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
    2c84:	04 12       	push	r4		
    2c86:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    2c8a:	04 41       	mov	r1,	r4	
    2c8c:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2c90:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2c94:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    2c98:	5f 42 86 03 	mov.b	&0x0386,r15	
    2c9c:	4f 93       	tst.b	r15		
    2c9e:	02 24       	jz	$+6      	;abs 0x2ca4
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    2ca0:	0f 43       	clr	r15		
    2ca2:	6d 3c       	jmp	$+220    	;abs 0x2d7e
    }
    OS_ENTER_CRITICAL();
    2ca4:	b0 12 16 14 	call	#0x1416	
    2ca8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
    2cac:	94 42 84 03 	mov	&0x0384,4(r4)	;0x0004(r4)
    2cb0:	04 00 
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
    2cb2:	1f 42 84 03 	mov	&0x0384,r15	
    2cb6:	0f 93       	tst	r15		
    2cb8:	06 24       	jz	$+14     	;abs 0x2cc6
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    2cba:	1f 42 84 03 	mov	&0x0384,r15	
    2cbe:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2cc2:	82 4f 84 03 	mov	r15,	&0x0384	
    }
    OS_EXIT_CRITICAL();
    2cc6:	2f 44       	mov	@r4,	r15	
    2cc8:	b0 12 1c 14 	call	#0x141c	
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
    2ccc:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    2cd0:	54 24       	jz	$+170    	;abs 0x2d7a
        OS_ENTER_CRITICAL();
    2cd2:	b0 12 16 14 	call	#0x1416	
    2cd6:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
    2cda:	94 42 7c 03 	mov	&0x037c,2(r4)	;0x0002(r4)
    2cde:	02 00 
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
    2ce0:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2ce4:	3c 24       	jz	$+122    	;abs 0x2d5e
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
    2ce6:	1f 42 7c 03 	mov	&0x037c,r15	
    2cea:	2f 4f       	mov	@r15,	r15	
    2cec:	82 4f 7c 03 	mov	r15,	&0x037c	
            OS_EXIT_CRITICAL();
    2cf0:	2f 44       	mov	@r4,	r15	
    2cf2:	b0 12 1c 14 	call	#0x141c	
            pq->OSQStart           = start;               /*      Initialize the queue                 */
    2cf6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cfa:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    2cfe:	02 00 
            pq->OSQEnd             = &start[size];
    2d00:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2d04:	0f 5f       	rla	r15		
    2d06:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    2d0a:	0e 5f       	add	r15,	r14	
    2d0c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d10:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
            pq->OSQIn              = start;
    2d14:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d18:	9f 44 06 00 	mov	6(r4),	6(r15)	;0x0006(r4), 0x0006(r15)
    2d1c:	06 00 
            pq->OSQOut             = start;
    2d1e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d22:	9f 44 06 00 	mov	6(r4),	8(r15)	;0x0006(r4), 0x0008(r15)
    2d26:	08 00 
            pq->OSQSize            = size;
    2d28:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d2c:	9f 44 08 00 	mov	8(r4),	10(r15)	;0x0008(r4), 0x000a(r15)
    2d30:	0a 00 
            pq->OSQEntries         = 0;
    2d32:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d36:	8f 43 0c 00 	mov	#0,	12(r15)	;r3 As==00, 0x000c(r15)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
    2d3a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d3e:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
            pevent->OSEventCnt     = 0;
    2d42:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d46:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
            pevent->OSEventPtr     = pq;
    2d4a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d4e:	9f 44 02 00 	mov	2(r4),	4(r15)	;0x0002(r4), 0x0004(r15)
    2d52:	04 00 
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
            pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
    2d54:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d58:	b0 12 a0 1b 	call	#0x1ba0	
    2d5c:	0e 3c       	jmp	$+30     	;abs 0x2d7a
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
    2d5e:	1e 42 84 03 	mov	&0x0384,r14	
    2d62:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d66:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
            OSEventFreeList    = pevent;
    2d6a:	92 44 04 00 	mov	4(r4),	&0x0384	;0x0004(r4)
    2d6e:	84 03 
            OS_EXIT_CRITICAL();
    2d70:	2f 44       	mov	@r4,	r15	
    2d72:	b0 12 1c 14 	call	#0x141c	
            pevent = (OS_EVENT *)0;
    2d76:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
        }
    }
    return (pevent);
    2d7a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2d7e:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2d82:	34 41       	pop	r4		
    2d84:	30 41       	ret			

00002d86 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
    2d86:	04 12       	push	r4		
    2d88:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2d8c:	04 41       	mov	r1,	r4	
    2d8e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2d92:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
    2d96:	b0 12 16 14 	call	#0x1416	
    2d9a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
    2d9e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2da2:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2da6:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    pq->OSQIn      = pq->OSQStart;
    2daa:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2dae:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2db2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2db6:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    pq->OSQOut     = pq->OSQStart;
    2dba:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2dbe:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2dc2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2dc6:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    pq->OSQEntries = 0;
    2dca:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2dce:	8f 43 0c 00 	mov	#0,	12(r15)	;r3 As==00, 0x000c(r15)
    OS_EXIT_CRITICAL();
    2dd2:	2f 44       	mov	@r4,	r15	
    2dd4:	b0 12 1c 14 	call	#0x141c	
    return (OS_NO_ERR);
    2dd8:	4f 43       	clr.b	r15		
}
    2dda:	31 50 06 00 	add	#6,	r1	;#0x0006
    2dde:	34 41       	pop	r4		
    2de0:	30 41       	ret			

00002de2 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    2de2:	04 12       	push	r4		
    2de4:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    2de8:	04 41       	mov	r1,	r4	
    2dea:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2dee:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    2df2:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2df6:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    2dfa:	5f 42 86 03 	mov.b	&0x0386,r15	
    2dfe:	4f 93       	tst.b	r15		
    2e00:	06 24       	jz	$+14     	;abs 0x2e0e
        *err = OS_ERR_PEND_ISR;                  /* ... can't PEND from an ISR                         */
    2e02:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2e06:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((void *)0);
    2e0a:	0f 43       	clr	r15		
    2e0c:	8f 3c       	jmp	$+288    	;abs 0x2f2c
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
        *err = OS_ERR_EVENT_TYPE;
        return ((void *)0);
    }
#endif
    OS_ENTER_CRITICAL();
    2e0e:	b0 12 16 14 	call	#0x1416	
    2e12:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    2e16:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2e1a:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2e1e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
    2e22:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e26:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2e2a:	0f 93       	tst	r15		
    2e2c:	32 24       	jz	$+102    	;abs 0x2e92
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
    2e2e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e32:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2e36:	a4 4f 04 00 	mov	@r15,	4(r4)	;0x0004(r4)
    2e3a:	0e 4f       	mov	r15,	r14	
    2e3c:	2e 53       	incd	r14		
    2e3e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e42:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
    2e46:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e4a:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2e4e:	0e 4f       	mov	r15,	r14	
    2e50:	3e 53       	add	#-1,	r14	;r3 As==11
    2e52:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e56:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
    2e5a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e5e:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    2e62:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e66:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2e6a:	0e 9f       	cmp	r15,	r14	
    2e6c:	08 20       	jnz	$+18     	;abs 0x2e7e
            pq->OSQOut = pq->OSQStart;
    2e6e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e72:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2e76:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e7a:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        OS_EXIT_CRITICAL();
    2e7e:	2f 44       	mov	@r4,	r15	
    2e80:	b0 12 1c 14 	call	#0x141c	
        *err = OS_NO_ERR;
    2e84:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2e88:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        return (msg);                            /* Return message received                            */
    2e8c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2e90:	4d 3c       	jmp	$+156    	;abs 0x2f2c
    }
    OSTCBCur->OSTCBStat   |= OS_STAT_Q;          /* Task will have to pend for a message to be posted  */
    2e92:	1f 42 88 03 	mov	&0x0388,r15	
    2e96:	1e 42 88 03 	mov	&0x0388,r14	
    2e9a:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    2e9e:	6e d2       	bis.b	#4,	r14	;r2 As==10
    2ea0:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO  = FALSE;
    2ea4:	1f 42 88 03 	mov	&0x0388,r15	
    2ea8:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly     = timeout;            /* Load timeout into TCB                              */
    2eac:	1f 42 88 03 	mov	&0x0388,r15	
    2eb0:	9f 44 08 00 	mov	8(r4),	24(r15)	;0x0008(r4), 0x0018(r15)
    2eb4:	18 00 
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
    2eb6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2eba:	b0 12 5e 1a 	call	#0x1a5e	
    OS_EXIT_CRITICAL();
    2ebe:	2f 44       	mov	@r4,	r15	
    2ec0:	b0 12 1c 14 	call	#0x141c	
    OS_Sched();                                  /* Find next highest priority task ready to run       */
    2ec4:	b0 12 bc 1d 	call	#0x1dbc	
    OS_ENTER_CRITICAL();
    2ec8:	b0 12 16 14 	call	#0x1416	
    2ecc:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {         /* Was task readied because of a timeout?             */
    2ed0:	1f 42 88 03 	mov	&0x0388,r15	
    2ed4:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    2ed8:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2eda:	0e 20       	jnz	$+30     	;abs 0x2ef8
        OS_EventTO(pevent);                      /* Yes                                                */
    2edc:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2ee0:	b0 12 0e 1b 	call	#0x1b0e	
        OS_EXIT_CRITICAL();
    2ee4:	2f 44       	mov	@r4,	r15	
    2ee6:	b0 12 1c 14 	call	#0x141c	
        *err = OS_TIMEOUT;                       /*     Indicate a timeout occured                     */
    2eea:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2eee:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    2ef2:	00 00 
        return ((void *)0);                      /*     No message received                            */
    2ef4:	0f 43       	clr	r15		
    2ef6:	1a 3c       	jmp	$+54     	;abs 0x2f2c
    }
    msg                     = OSTCBCur->OSTCBMsg;/* No, Extract message from TCB (Put there by QPost)  */
    2ef8:	1f 42 88 03 	mov	&0x0388,r15	
    2efc:	94 4f 14 00 	mov	20(r15),4(r4)	;0x0014(r15), 0x0004(r4)
    2f00:	04 00 
    OSTCBCur->OSTCBMsg      = (void *)0;
    2f02:	1f 42 88 03 	mov	&0x0388,r15	
    2f06:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    2f0a:	1f 42 88 03 	mov	&0x0388,r15	
    2f0e:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;     /*     No longer waiting for event                    */
    2f12:	1f 42 88 03 	mov	&0x0388,r15	
    2f16:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    2f1a:	2f 44       	mov	@r4,	r15	
    2f1c:	b0 12 1c 14 	call	#0x141c	
    *err                    = OS_NO_ERR;
    2f20:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2f24:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (msg);                                /*     Return message received                        */
    2f28:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2f2c:	31 50 0c 00 	add	#12,	r1	;#0x000c
    2f30:	34 41       	pop	r4		
    2f32:	30 41       	ret			

00002f34 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *msg)
{
    2f34:	04 12       	push	r4		
    2f36:	31 82       	sub	#8,	r1	;r2 As==11
    2f38:	04 41       	mov	r1,	r4	
    2f3a:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2f3e:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    2f42:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
    2f46:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f4a:	6f 4f       	mov.b	@r15,	r15	
    2f4c:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    2f4e:	02 24       	jz	$+6      	;abs 0x2f54
        return (OS_ERR_EVENT_TYPE);
    2f50:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2f52:	5b 3c       	jmp	$+184    	;abs 0x300a
    }
    OS_ENTER_CRITICAL();
    2f54:	b0 12 16 14 	call	#0x1416	
    2f58:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                  /* See if any task pending on queue             */
    2f5c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f60:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2f64:	4f 93       	tst.b	r15		
    2f66:	0e 24       	jz	$+30     	;abs 0x2f84
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q); /* Ready highest priority task waiting on event */
    2f68:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    2f6c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f70:	6d 42       	mov.b	#4,	r13	;r2 As==10
    2f72:	b0 12 1c 19 	call	#0x191c	
        OS_EXIT_CRITICAL();
    2f76:	2f 44       	mov	@r4,	r15	
    2f78:	b0 12 1c 14 	call	#0x141c	
        OS_Sched();                                    /* Find highest priority task ready to run      */
    2f7c:	b0 12 bc 1d 	call	#0x1dbc	
        return (OS_NO_ERR);
    2f80:	4f 43       	clr.b	r15		
    2f82:	43 3c       	jmp	$+136    	;abs 0x300a
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
    2f84:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f88:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2f8c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
    2f90:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f94:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    2f98:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f9c:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    2fa0:	0e 9f       	cmp	r15,	r14	
    2fa2:	06 28       	jnc	$+14     	;abs 0x2fb0
        OS_EXIT_CRITICAL();
    2fa4:	2f 44       	mov	@r4,	r15	
    2fa6:	b0 12 1c 14 	call	#0x141c	
        return (OS_Q_FULL);
    2faa:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    2fae:	2d 3c       	jmp	$+92     	;abs 0x300a
    }
    *pq->OSQIn++ = msg;                                /* Insert message into queue                    */
    2fb0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fb4:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    2fb8:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    2fbc:	00 00 
    2fbe:	0e 4f       	mov	r15,	r14	
    2fc0:	2e 53       	incd	r14		
    2fc2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fc6:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
    2fca:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fce:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2fd2:	0e 4f       	mov	r15,	r14	
    2fd4:	1e 53       	inc	r14		
    2fd6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fda:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
    2fde:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fe2:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    2fe6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fea:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2fee:	0e 9f       	cmp	r15,	r14	
    2ff0:	08 20       	jnz	$+18     	;abs 0x3002
        pq->OSQIn = pq->OSQStart;
    2ff2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ff6:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2ffa:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ffe:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    }
    OS_EXIT_CRITICAL();
    3002:	2f 44       	mov	@r4,	r15	
    3004:	b0 12 1c 14 	call	#0x141c	
    return (OS_NO_ERR);
    3008:	4f 43       	clr.b	r15		
}
    300a:	31 52       	add	#8,	r1	;r2 As==11
    300c:	34 41       	pop	r4		
    300e:	30 41       	ret			

00003010 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *msg)
{
    3010:	04 12       	push	r4		
    3012:	31 82       	sub	#8,	r1	;r2 As==11
    3014:	04 41       	mov	r1,	r4	
    3016:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    301a:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    301e:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
    3022:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3026:	6f 4f       	mov.b	@r15,	r15	
    3028:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    302a:	02 24       	jz	$+6      	;abs 0x3030
        return (OS_ERR_EVENT_TYPE);
    302c:	5f 43       	mov.b	#1,	r15	;r3 As==01
    302e:	5f 3c       	jmp	$+192    	;abs 0x30ee
    }
    OS_ENTER_CRITICAL();
    3030:	b0 12 16 14 	call	#0x1416	
    3034:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
    3038:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    303c:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3040:	4f 93       	tst.b	r15		
    3042:	0e 24       	jz	$+30     	;abs 0x3060
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);/* Ready highest priority task waiting on event  */
    3044:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    3048:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    304c:	6d 42       	mov.b	#4,	r13	;r2 As==10
    304e:	b0 12 1c 19 	call	#0x191c	
        OS_EXIT_CRITICAL();
    3052:	2f 44       	mov	@r4,	r15	
    3054:	b0 12 1c 14 	call	#0x141c	
        OS_Sched();                                   /* Find highest priority task ready to run       */
    3058:	b0 12 bc 1d 	call	#0x1dbc	
        return (OS_NO_ERR);
    305c:	4f 43       	clr.b	r15		
    305e:	47 3c       	jmp	$+144    	;abs 0x30ee
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    3060:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3064:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    3068:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
    306c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3070:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    3074:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3078:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    307c:	0e 9f       	cmp	r15,	r14	
    307e:	06 28       	jnc	$+14     	;abs 0x308c
        OS_EXIT_CRITICAL();
    3080:	2f 44       	mov	@r4,	r15	
    3082:	b0 12 1c 14 	call	#0x141c	
        return (OS_Q_FULL);
    3086:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    308a:	31 3c       	jmp	$+100    	;abs 0x30ee
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
    308c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3090:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    3094:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3098:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    309c:	0e 9f       	cmp	r15,	r14	
    309e:	08 20       	jnz	$+18     	;abs 0x30b0
        pq->OSQOut = pq->OSQEnd;
    30a0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30a4:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    30a8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30ac:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    }
    pq->OSQOut--;
    30b0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30b4:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    30b8:	0e 4f       	mov	r15,	r14	
    30ba:	2e 83       	decd	r14		
    30bc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30c0:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    *pq->OSQOut = msg;                                /* Insert message into queue                     */
    30c4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30c8:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    30cc:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    30d0:	00 00 
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    30d2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30d6:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    30da:	0e 4f       	mov	r15,	r14	
    30dc:	1e 53       	inc	r14		
    30de:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30e2:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    OS_EXIT_CRITICAL();
    30e6:	2f 44       	mov	@r4,	r15	
    30e8:	b0 12 1c 14 	call	#0x141c	
    return (OS_NO_ERR);
    30ec:	4f 43       	clr.b	r15		
}
    30ee:	31 52       	add	#8,	r1	;r2 As==11
    30f0:	34 41       	pop	r4		
    30f2:	30 41       	ret			

000030f4 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
    30f4:	04 12       	push	r4		
    30f6:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    30fa:	04 41       	mov	r1,	r4	
    30fc:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    3100:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    3104:	c4 4d 08 00 	mov.b	r13,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
                     


    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    3108:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
    310c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3110:	6f 4f       	mov.b	@r15,	r15	
    3112:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    3114:	02 24       	jz	$+6      	;abs 0x311a
        return (OS_ERR_EVENT_TYPE);
    3116:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3118:	97 3c       	jmp	$+304    	;abs 0x3248
    }
    OS_ENTER_CRITICAL();
    311a:	b0 12 16 14 	call	#0x1416	
    311e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
    3122:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3126:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    312a:	4f 93       	tst.b	r15		
    312c:	22 24       	jz	$+70     	;abs 0x3172
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
    312e:	5f 44 08 00 	mov.b	8(r4),	r15	;0x0008(r4)
    3132:	1f f3       	and	#1,	r15	;r3 As==01
    3134:	4f 93       	tst.b	r15		
    3136:	0f 24       	jz	$+32     	;abs 0x3156
    3138:	07 3c       	jmp	$+16     	;abs 0x3148
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
    313a:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    313e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3142:	6d 42       	mov.b	#4,	r13	;r2 As==10
    3144:	b0 12 1c 19 	call	#0x191c	
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
    3148:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    314c:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3150:	4f 93       	tst.b	r15		
    3152:	f3 23       	jnz	$-24     	;abs 0x313a
    3154:	07 3c       	jmp	$+16     	;abs 0x3164
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);  /* No,  Post to HPT waiting on queue       */
    3156:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    315a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    315e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    3160:	b0 12 1c 19 	call	#0x191c	
        }
        OS_EXIT_CRITICAL();
    3164:	2f 44       	mov	@r4,	r15	
    3166:	b0 12 1c 14 	call	#0x141c	
        OS_Sched();                                         /* Find highest priority task ready to run */
    316a:	b0 12 bc 1d 	call	#0x1dbc	
        return (OS_NO_ERR);
    316e:	4f 43       	clr.b	r15		
    3170:	6b 3c       	jmp	$+216    	;abs 0x3248
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    3172:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3176:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    317a:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
    317e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3182:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    3186:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    318a:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    318e:	0e 9f       	cmp	r15,	r14	
    3190:	06 28       	jnc	$+14     	;abs 0x319e
        OS_EXIT_CRITICAL();
    3192:	2f 44       	mov	@r4,	r15	
    3194:	b0 12 1c 14 	call	#0x141c	
        return (OS_Q_FULL);
    3198:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    319c:	55 3c       	jmp	$+172    	;abs 0x3248
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
    319e:	5f 44 08 00 	mov.b	8(r4),	r15	;0x0008(r4)
    31a2:	2f f3       	and	#2,	r15	;r3 As==10
    31a4:	24 24       	jz	$+74     	;abs 0x31ee
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
    31a6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31aa:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    31ae:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31b2:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    31b6:	0e 9f       	cmp	r15,	r14	
    31b8:	08 20       	jnz	$+18     	;abs 0x31ca
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
    31ba:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31be:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    31c2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31c6:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        pq->OSQOut--;
    31ca:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31ce:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    31d2:	0e 4f       	mov	r15,	r14	
    31d4:	2e 83       	decd	r14		
    31d6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31da:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        *pq->OSQOut = msg;                            /*      Insert message into queue                */
    31de:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31e2:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    31e6:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    31ea:	00 00 
    31ec:	1f 3c       	jmp	$+64     	;abs 0x322c
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = msg;                           /*      Insert message into queue                */
    31ee:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31f2:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    31f6:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    31fa:	00 00 
    31fc:	0e 4f       	mov	r15,	r14	
    31fe:	2e 53       	incd	r14		
    3200:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3204:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
    3208:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    320c:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    3210:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3214:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    3218:	0e 9f       	cmp	r15,	r14	
    321a:	08 20       	jnz	$+18     	;abs 0x322c
            pq->OSQIn = pq->OSQStart;
    321c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3220:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    3224:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3228:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    322c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3230:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    3234:	0e 4f       	mov	r15,	r14	
    3236:	1e 53       	inc	r14		
    3238:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    323c:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    OS_EXIT_CRITICAL();
    3240:	2f 44       	mov	@r4,	r15	
    3242:	b0 12 1c 14 	call	#0x141c	
    return (OS_NO_ERR);
    3246:	4f 43       	clr.b	r15		
}
    3248:	31 50 0a 00 	add	#10,	r1	;#0x000a
    324c:	34 41       	pop	r4		
    324e:	30 41       	ret			

00003250 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
    3250:	04 12       	push	r4		
    3252:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3256:	04 41       	mov	r1,	r4	
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    3258:	3f 40 34 03 	mov	#820,	r15	;#0x0334
    325c:	3e 40 46 00 	mov	#70,	r14	;#0x0046
    3260:	b0 12 56 1d 	call	#0x1d56	
    pq1 = &OSQTbl[0];
    3264:	b4 40 34 03 	mov	#820,	2(r4)	;#0x0334, 0x0002(r4)
    3268:	02 00 
    pq2 = &OSQTbl[1];
    326a:	b4 40 42 03 	mov	#834,	0(r4)	;#0x0342, 0x0000(r4)
    326e:	00 00 
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
    3270:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    3274:	0c 3c       	jmp	$+26     	;abs 0x328e
        pq1->OSQPtr = pq2;
    3276:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    327a:	af 44 00 00 	mov	@r4,	0(r15)	;0x0000(r15)
        pq1++;
    327e:	b4 50 0e 00 	add	#14,	2(r4)	;#0x000e, 0x0002(r4)
    3282:	02 00 
        pq2++;
    3284:	b4 50 0e 00 	add	#14,	0(r4)	;#0x000e, 0x0000(r4)
    3288:	00 00 


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
    328a:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    328e:	a4 92 04 00 	cmp	#4,	4(r4)	;r2 As==10, 0x0004(r4)
    3292:	f1 2b       	jnc	$-28     	;abs 0x3276
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
    3294:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3298:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OSQFreeList = &OSQTbl[0];
    329c:	b2 40 34 03 	mov	#820,	&0x037c	;#0x0334
    32a0:	7c 03 
#endif
}
    32a2:	31 50 06 00 	add	#6,	r1	;#0x0006
    32a6:	34 41       	pop	r4		
    32a8:	30 41       	ret			

000032aa <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
    32aa:	04 12       	push	r4		
    32ac:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    32b0:	04 41       	mov	r1,	r4	
    32b2:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    32b6:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
    32ba:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    32be:	6f 4f       	mov.b	@r15,	r15	
    32c0:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    32c4:	02 24       	jz	$+6      	;abs 0x32ca
        return (0);
    32c6:	0f 43       	clr	r15		
    32c8:	1b 3c       	jmp	$+56     	;abs 0x3300
    }
    OS_ENTER_CRITICAL();
    32ca:	b0 12 16 14 	call	#0x1416	
    32ce:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    cnt = pevent->OSEventCnt;
    32d2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    32d6:	94 4f 02 00 	mov	2(r15),	2(r4)	;0x0002(r15), 0x0002(r4)
    32da:	02 00 
    if (cnt > 0) {                                    /* See if resource is available                  */
    32dc:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    32e0:	0a 24       	jz	$+22     	;abs 0x32f6
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
    32e2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    32e6:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    32ea:	0e 4f       	mov	r15,	r14	
    32ec:	3e 53       	add	#-1,	r14	;r3 As==11
    32ee:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    32f2:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
    }
    OS_EXIT_CRITICAL();
    32f6:	2f 44       	mov	@r4,	r15	
    32f8:	b0 12 1c 14 	call	#0x141c	
    return (cnt);                                     /* Return semaphore count                        */
    32fc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    3300:	31 50 06 00 	add	#6,	r1	;#0x0006
    3304:	34 41       	pop	r4		
    3306:	30 41       	ret			

00003308 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
    3308:	04 12       	push	r4		
    330a:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    330e:	04 41       	mov	r1,	r4	
    3310:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    3314:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
    3318:	5f 42 86 03 	mov.b	&0x0386,r15	
    331c:	4f 93       	tst.b	r15		
    331e:	02 24       	jz	$+6      	;abs 0x3324
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
    3320:	0f 43       	clr	r15		
    3322:	2b 3c       	jmp	$+88     	;abs 0x337a
    }
    OS_ENTER_CRITICAL();
    3324:	b0 12 16 14 	call	#0x1416	
    3328:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
    332c:	94 42 84 03 	mov	&0x0384,2(r4)	;0x0002(r4)
    3330:	02 00 
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
    3332:	1f 42 84 03 	mov	&0x0384,r15	
    3336:	0f 93       	tst	r15		
    3338:	06 24       	jz	$+14     	;abs 0x3346
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    333a:	1f 42 84 03 	mov	&0x0384,r15	
    333e:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    3342:	82 4f 84 03 	mov	r15,	&0x0384	
    }
    OS_EXIT_CRITICAL();
    3346:	2f 44       	mov	@r4,	r15	
    3348:	b0 12 1c 14 	call	#0x141c	
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
    334c:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3350:	12 24       	jz	$+38     	;abs 0x3376
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
    3352:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3356:	ff 40 03 00 	mov.b	#3,	0(r15)	;#0x0003, 0x0000(r15)
    335a:	00 00 
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
    335c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3360:	9f 44 04 00 	mov	4(r4),	2(r15)	;0x0004(r4), 0x0002(r15)
    3364:	02 00 
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
    3366:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    336a:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
    336e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3372:	b0 12 a0 1b 	call	#0x1ba0	
    }
    return (pevent);
    3376:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    337a:	31 50 06 00 	add	#6,	r1	;#0x0006
    337e:	34 41       	pop	r4		
    3380:	30 41       	ret			

00003382 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/

void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    3382:	04 12       	push	r4		
    3384:	31 82       	sub	#8,	r1	;r2 As==11
    3386:	04 41       	mov	r1,	r4	
    3388:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    338c:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    3390:	84 4d 06 00 	mov	r13,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    3394:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
    3398:	5f 42 86 03 	mov.b	&0x0386,r15	
    339c:	4f 93       	tst.b	r15		
    339e:	05 24       	jz	$+12     	;abs 0x33aa
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
    33a0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    33a4:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
    33a8:	64 3c       	jmp	$+202    	;abs 0x3472
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
    33aa:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33ae:	6f 4f       	mov.b	@r15,	r15	
    33b0:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    33b4:	05 24       	jz	$+12     	;abs 0x33c0
        *err = OS_ERR_EVENT_TYPE;
    33b6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    33ba:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
    33be:	59 3c       	jmp	$+180    	;abs 0x3472
        return;
    }
    OS_ENTER_CRITICAL();
    33c0:	b0 12 16 14 	call	#0x1416	
    33c4:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
    33c8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33cc:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    33d0:	0f 93       	tst	r15		
    33d2:	12 24       	jz	$+38     	;abs 0x33f8
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
    33d4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33d8:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    33dc:	0e 4f       	mov	r15,	r14	
    33de:	3e 53       	add	#-1,	r14	;r3 As==11
    33e0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33e4:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
        OS_EXIT_CRITICAL();
    33e8:	2f 44       	mov	@r4,	r15	
    33ea:	b0 12 1c 14 	call	#0x141c	
        *err = OS_NO_ERR;
    33ee:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    33f2:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    33f6:	3d 3c       	jmp	$+124    	;abs 0x3472
        return;
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat   |= OS_STAT_SEM;             /* Resource not available, pend on semaphore     */
    33f8:	1f 42 88 03 	mov	&0x0388,r15	
    33fc:	1e 42 88 03 	mov	&0x0388,r14	
    3400:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    3404:	5e d3       	bis.b	#1,	r14	;r3 As==01
    3406:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO  = FALSE;
    340a:	1f 42 88 03 	mov	&0x0388,r15	
    340e:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly     = timeout;                 /* Store pend timeout in TCB                     */
    3412:	1f 42 88 03 	mov	&0x0388,r15	
    3416:	9f 44 04 00 	mov	4(r4),	24(r15)	;0x0004(r4), 0x0018(r15)
    341a:	18 00 
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    341c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3420:	b0 12 5e 1a 	call	#0x1a5e	
    OS_EXIT_CRITICAL();
    3424:	2f 44       	mov	@r4,	r15	
    3426:	b0 12 1c 14 	call	#0x141c	
    OS_Sched();                                       /* Find next highest priority task ready         */
    342a:	b0 12 bc 1d 	call	#0x1dbc	
    OS_ENTER_CRITICAL();
    342e:	b0 12 16 14 	call	#0x1416	
    3432:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we timedout                            */
    3436:	1f 42 88 03 	mov	&0x0388,r15	
    343a:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    343e:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    3440:	0d 20       	jnz	$+28     	;abs 0x345c
        OS_EventTO(pevent);
    3442:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3446:	b0 12 0e 1b 	call	#0x1b0e	
        OS_EXIT_CRITICAL();
    344a:	2f 44       	mov	@r4,	r15	
    344c:	b0 12 1c 14 	call	#0x141c	
        *err = OS_TIMEOUT;                            /* Indicate that didn't get event within TO      */
    3450:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3454:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    3458:	00 00 
    345a:	0b 3c       	jmp	$+24     	;abs 0x3472
        return;
    }
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
    345c:	1f 42 88 03 	mov	&0x0388,r15	
    3460:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    3464:	2f 44       	mov	@r4,	r15	
    3466:	b0 12 1c 14 	call	#0x141c	
    *err = OS_NO_ERR;
    346a:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    346e:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
}
    3472:	31 52       	add	#8,	r1	;r2 As==11
    3474:	34 41       	pop	r4		
    3476:	30 41       	ret			

00003478 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
    3478:	04 12       	push	r4		
    347a:	21 82       	sub	#4,	r1	;r2 As==10
    347c:	04 41       	mov	r1,	r4	
    347e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;                               



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    3482:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
    3486:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    348a:	6f 4f       	mov.b	@r15,	r15	
    348c:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    3490:	02 24       	jz	$+6      	;abs 0x3496
        return (OS_ERR_EVENT_TYPE);
    3492:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3494:	32 3c       	jmp	$+102    	;abs 0x34fa
    }
    OS_ENTER_CRITICAL();
    3496:	b0 12 16 14 	call	#0x1416	
    349a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                          /* See if any task waiting for semaphore*/
    349e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34a2:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    34a6:	4f 93       	tst.b	r15		
    34a8:	0e 24       	jz	$+30     	;abs 0x34c6
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM); /* Ready HPT waiting on event           */
    34aa:	5e 43       	mov.b	#1,	r14	;r3 As==01
    34ac:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34b0:	4d 4e       	mov.b	r14,	r13	
    34b2:	0e 43       	clr	r14		
    34b4:	b0 12 1c 19 	call	#0x191c	
        OS_EXIT_CRITICAL();
    34b8:	2f 44       	mov	@r4,	r15	
    34ba:	b0 12 1c 14 	call	#0x141c	
        OS_Sched();                                            /* Find HPT ready to run                */
    34be:	b0 12 bc 1d 	call	#0x1dbc	
        return (OS_NO_ERR);
    34c2:	4f 43       	clr.b	r15		
    34c4:	1a 3c       	jmp	$+54     	;abs 0x34fa
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
    34c6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34ca:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    34ce:	3f 93       	cmp	#-1,	r15	;r3 As==11
    34d0:	0f 24       	jz	$+32     	;abs 0x34f0
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
    34d2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34d6:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    34da:	0e 4f       	mov	r15,	r14	
    34dc:	1e 53       	inc	r14		
    34de:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34e2:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
        OS_EXIT_CRITICAL();
    34e6:	2f 44       	mov	@r4,	r15	
    34e8:	b0 12 1c 14 	call	#0x141c	
        return (OS_NO_ERR);
    34ec:	4f 43       	clr.b	r15		
    34ee:	05 3c       	jmp	$+12     	;abs 0x34fa
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    34f0:	2f 44       	mov	@r4,	r15	
    34f2:	b0 12 1c 14 	call	#0x141c	
    return (OS_SEM_OVF);
    34f6:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
}
    34fa:	21 52       	add	#4,	r1	;r2 As==10
    34fc:	34 41       	pop	r4		
    34fe:	30 41       	ret			

00003500 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
    3500:	04 12       	push	r4		
    3502:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3506:	04 41       	mov	r1,	r4	
    3508:	c4 4f 0c 00 	mov.b	r15,	12(r4)	;0x000c(r4)
    350c:	c4 4e 0d 00 	mov.b	r14,	13(r4)	;0x000d(r4)
#if OS_CRITICAL_METHOD == 3                                     
    OS_CPU_SR    cpu_sr;                                        /* Storage for CPU status register     */



    cpu_sr = 0;                                                 /* Prevent compiler warning            */
    3510:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
	}
    if (newprio >= OS_LOWEST_PRIO) {
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    3514:	b0 12 16 14 	call	#0x1416	
    3518:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already exist */
    351c:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    3520:	0f 5f       	rla	r15		
    3522:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3526:	2f 4f       	mov	@r15,	r15	
    3528:	0f 93       	tst	r15		
    352a:	06 24       	jz	$+14     	;abs 0x3538
        OS_EXIT_CRITICAL();
    352c:	2f 44       	mov	@r4,	r15	
    352e:	b0 12 1c 14 	call	#0x141c	
        return (OS_PRIO_EXIST);
    3532:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
    3536:	01 3d       	jmp	$+516    	;abs 0x373a
    } 
    if (oldprio == OS_PRIO_SELF) {                              /* See if changing self                */
    3538:	f4 93 0c 00 	cmp.b	#-1,	12(r4)	;r3 As==11, 0x000c(r4)
    353c:	05 20       	jnz	$+12     	;abs 0x3548
        oldprio = OSTCBCur->OSTCBPrio;                          /* Yes, get priority                   */
    353e:	1f 42 88 03 	mov	&0x0388,r15	
    3542:	d4 4f 1c 00 	mov.b	28(r15),12(r4)	;0x001c(r15), 0x000c(r4)
    3546:	0c 00 
    }
    ptcb = OSTCBPrioTbl[oldprio];
    3548:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    354c:	0f 5f       	rla	r15		
    354e:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3552:	a4 4f 08 00 	mov	@r15,	8(r4)	;0x0008(r4)
    if (ptcb == (OS_TCB *)0) {                                  /* Does task to change exist?          */
    3556:	84 93 08 00 	tst	8(r4)		;0x0008(r4)
    355a:	06 20       	jnz	$+14     	;abs 0x3568
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
    355c:	2f 44       	mov	@r4,	r15	
    355e:	b0 12 1c 14 	call	#0x141c	
        return (OS_PRIO_ERR);
    3562:	7f 40 29 00 	mov.b	#41,	r15	;#0x0029
    3566:	e9 3c       	jmp	$+468    	;abs 0x373a
    }                                       
    if (ptcb == (OS_TCB *)1) {                                  /* Is task assigned to Mutex           */
    3568:	94 93 08 00 	cmp	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    356c:	06 20       	jnz	$+14     	;abs 0x357a
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
    356e:	2f 44       	mov	@r4,	r15	
    3570:	b0 12 1c 14 	call	#0x141c	
        return (OS_TASK_NOT_EXIST);
    3574:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    3578:	e0 3c       	jmp	$+450    	;abs 0x373a
    }                                       
    y                     = newprio >> 3;                       /* Yes, compute new TCB fields         */
    357a:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    357e:	12 c3       	clrc			
    3580:	4f 10       	rrc.b	r15		
    3582:	4f 11       	rra.b	r15		
    3584:	4f 11       	rra.b	r15		
    3586:	c4 4f 05 00 	mov.b	r15,	5(r4)	;0x0005(r4)
    bity                  = OSMapTbl[y];
    358a:	5f 44 05 00 	mov.b	5(r4),	r15	;0x0005(r4)
    358e:	d4 4f 60 15 	mov.b	5472(r15),3(r4)	;0x1560(r15), 0x0003(r4)
    3592:	03 00 
    x                     = newprio & 0x07;
    3594:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    3598:	7f f0 07 00 	and.b	#7,	r15	;#0x0007
    359c:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
    bitx                  = OSMapTbl[x];
    35a0:	5f 44 06 00 	mov.b	6(r4),	r15	;0x0006(r4)
    35a4:	d4 4f 60 15 	mov.b	5472(r15),4(r4)	;0x1560(r15), 0x0004(r4)
    35a8:	04 00 
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
    35aa:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    35ae:	0f 5f       	rla	r15		
    35b0:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    35b4:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
    35b8:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    35bc:	0f 5f       	rla	r15		
    35be:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    35c2:	9f 44 08 00 	mov	8(r4),	0(r15)	;0x0008(r4), 0x0000(r15)
    35c6:	00 00 
    y_old                 = ptcb->OSTCBY;
    35c8:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    35cc:	d4 4f 1e 00 	mov.b	30(r15),2(r4)	;0x001e(r15), 0x0002(r4)
    35d0:	02 00 
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0x00) {          /* If task is ready make it not        */
    35d2:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    35d6:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    35da:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    35de:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    35e2:	4f fe       	and.b	r14,	r15	
    35e4:	31 24       	jz	$+100    	;abs 0x3648
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
    35e6:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    35ea:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    35ee:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    35f2:	4e 4f       	mov.b	r15,	r14	
    35f4:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    35f8:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    35fc:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    35fe:	4f fe       	and.b	r14,	r15	
    3600:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        if (OSRdyTbl[y_old] == 0x00) {
    3604:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3608:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    360c:	4f 93       	tst.b	r15		
    360e:	0b 20       	jnz	$+24     	;abs 0x3626
            OSRdyGrp &= ~ptcb->OSTCBBitY;
    3610:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3614:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    3618:	4e 4f       	mov.b	r15,	r14	
    361a:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    361c:	5f 42 7e 03 	mov.b	&0x037e,r15	
    3620:	4f fe       	and.b	r14,	r15	
    3622:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        }
        OSRdyGrp    |= bity;                                    /* Make new priority ready to run      */
    3626:	5f 42 7e 03 	mov.b	&0x037e,r15	
    362a:	5f d4 03 00 	bis.b	3(r4),	r15	;0x0003(r4)
    362e:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[y] |= bitx;
    3632:	5e 44 05 00 	mov.b	5(r4),	r14	;0x0005(r4)
    3636:	5f 44 05 00 	mov.b	5(r4),	r15	;0x0005(r4)
    363a:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    363e:	5f d4 04 00 	bis.b	4(r4),	r15	;0x0004(r4)
    3642:	ce 4f 80 03 	mov.b	r15,	896(r14);0x0380(r14)
    3646:	5a 3c       	jmp	$+182    	;abs 0x36fc
#if OS_EVENT_EN
    } else {                                                    /* Task was not ready ...              */
        pevent = ptcb->OSTCBEventPtr;
    3648:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    364c:	94 4f 12 00 	mov	18(r15),10(r4)	;0x0012(r15), 0x000a(r4)
    3650:	0a 00 
        if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list     */
    3652:	84 93 0a 00 	tst	10(r4)		;0x000a(r4)
    3656:	52 24       	jz	$+166    	;abs 0x36fc
            pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
    3658:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    365c:	5e 44 02 00 	mov.b	2(r4),	r14	;0x0002(r4)
    3660:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3664:	0f 5e       	add	r14,	r15	
    3666:	3f 50 06 00 	add	#6,	r15	;#0x0006
    366a:	6f 4f       	mov.b	@r15,	r15	
    366c:	4e 4f       	mov.b	r15,	r14	
    366e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3672:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    3676:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    3678:	4f fe       	and.b	r14,	r15	
    367a:	4e 4f       	mov.b	r15,	r14	
    367c:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3680:	0f 5d       	add	r13,	r15	
    3682:	3f 50 06 00 	add	#6,	r15	;#0x0006
    3686:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
            if (pevent->OSEventTbl[y_old] == 0) {
    368a:	5e 44 02 00 	mov.b	2(r4),	r14	;0x0002(r4)
    368e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3692:	0f 5e       	add	r14,	r15	
    3694:	3f 50 06 00 	add	#6,	r15	;#0x0006
    3698:	6f 4f       	mov.b	@r15,	r15	
    369a:	4f 93       	tst.b	r15		
    369c:	10 20       	jnz	$+34     	;abs 0x36be
                pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
    369e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36a2:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    36a6:	4e 4f       	mov.b	r15,	r14	
    36a8:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36ac:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    36b0:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    36b2:	4f fe       	and.b	r14,	r15	
    36b4:	4e 4f       	mov.b	r15,	r14	
    36b6:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36ba:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
            }
            pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list       */
    36be:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36c2:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    36c6:	4e 4f       	mov.b	r15,	r14	
    36c8:	5e d4 03 00 	bis.b	3(r4),	r14	;0x0003(r4)
    36cc:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36d0:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
            pevent->OSEventTbl[y] |= bitx;
    36d4:	5d 44 05 00 	mov.b	5(r4),	r13	;0x0005(r4)
    36d8:	5e 44 05 00 	mov.b	5(r4),	r14	;0x0005(r4)
    36dc:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36e0:	0f 5e       	add	r14,	r15	
    36e2:	3f 50 06 00 	add	#6,	r15	;#0x0006
    36e6:	6f 4f       	mov.b	@r15,	r15	
    36e8:	4e 4f       	mov.b	r15,	r14	
    36ea:	5e d4 04 00 	bis.b	4(r4),	r14	;0x0004(r4)
    36ee:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36f2:	0f 5d       	add	r13,	r15	
    36f4:	3f 50 06 00 	add	#6,	r15	;#0x0006
    36f8:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
        }
#endif
    }
    ptcb->OSTCBPrio = newprio;                                  /* Set new task priority               */
    36fc:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3700:	df 44 0d 00 	mov.b	13(r4),	28(r15)	;0x000d(r4), 0x001c(r15)
    3704:	1c 00 
    ptcb->OSTCBY    = y;
    3706:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    370a:	df 44 05 00 	mov.b	5(r4),	30(r15)	;0x0005(r4), 0x001e(r15)
    370e:	1e 00 
    ptcb->OSTCBX    = x;
    3710:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3714:	df 44 06 00 	mov.b	6(r4),	29(r15)	;0x0006(r4), 0x001d(r15)
    3718:	1d 00 
    ptcb->OSTCBBitY = bity;
    371a:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    371e:	df 44 03 00 	mov.b	3(r4),	32(r15)	;0x0003(r4), 0x0020(r15)
    3722:	20 00 
    ptcb->OSTCBBitX = bitx;
    3724:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3728:	df 44 04 00 	mov.b	4(r4),	31(r15)	;0x0004(r4), 0x001f(r15)
    372c:	1f 00 
    OS_EXIT_CRITICAL();
    372e:	2f 44       	mov	@r4,	r15	
    3730:	b0 12 1c 14 	call	#0x141c	
    OS_Sched();                                                 /* Run highest priority task ready     */
    3734:	b0 12 bc 1d 	call	#0x1dbc	
    return (OS_NO_ERR);
    3738:	4f 43       	clr.b	r15		
}
    373a:	31 50 0e 00 	add	#14,	r1	;#0x000e
    373e:	34 41       	pop	r4		
    3740:	30 41       	ret			

00003742 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT8U prio)
{
    3742:	04 12       	push	r4		
    3744:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3748:	04 41       	mov	r1,	r4	
    374a:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    374e:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    3752:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
    3756:	c4 4c 0c 00 	mov.b	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                              /* Prevent compiler warning                               */
    375a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    375e:	b0 12 16 14 	call	#0x1416	
    3762:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
    3766:	5f 42 86 03 	mov.b	&0x0386,r15	
    376a:	4f 93       	tst.b	r15		
    376c:	06 24       	jz	$+14     	;abs 0x377a
        OS_EXIT_CRITICAL();
    376e:	2f 44       	mov	@r4,	r15	
    3770:	b0 12 1c 14 	call	#0x141c	
        return (OS_ERR_TASK_CREATE_ISR);
    3774:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    3778:	4e 3c       	jmp	$+158    	;abs 0x3816
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
    377a:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    377e:	0f 5f       	rla	r15		
    3780:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3784:	2f 4f       	mov	@r15,	r15	
    3786:	0f 93       	tst	r15		
    3788:	41 20       	jnz	$+132    	;abs 0x380c
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
    378a:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    378e:	0f 5f       	rla	r15		
    3790:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3794:	9f 43 00 00 	mov	#1,	0(r15)	;r3 As==01, 0x0000(r15)
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
    3798:	2f 44       	mov	@r4,	r15	
    379a:	b0 12 1c 14 	call	#0x141c	
        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, 0);    /* Initialize the task's stack         */
    379e:	1d 44 0a 00 	mov	10(r4),	r13	;0x000a(r4)
    37a2:	1e 44 08 00 	mov	8(r4),	r14	;0x0008(r4)
    37a6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    37aa:	0c 43       	clr	r12		
    37ac:	b0 12 60 14 	call	#0x1460	
    37b0:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
    37b4:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    37b8:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    37bc:	03 12       	push	#0		;r3 As==00
    37be:	03 12       	push	#0		;r3 As==00
    37c0:	03 12       	push	#0		;r3 As==00
    37c2:	03 12       	push	#0		;r3 As==00
    37c4:	0c 43       	clr	r12		
    37c6:	0d 43       	clr	r13		
    37c8:	b0 12 9a 1e 	call	#0x1e9a	
    37cc:	31 52       	add	#8,	r1	;r2 As==11
    37ce:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
        if (err == OS_NO_ERR) {
    37d2:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    37d6:	07 20       	jnz	$+16     	;abs 0x37e6
            if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has started */
    37d8:	5f 42 0d 03 	mov.b	&0x030d,r15	
    37dc:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    37de:	12 20       	jnz	$+38     	;abs 0x3804
                OS_Sched();
    37e0:	b0 12 bc 1d 	call	#0x1dbc	
    37e4:	10 3c       	jmp	$+34     	;abs 0x3806
            }
        } else {
            OS_ENTER_CRITICAL();
    37e6:	b0 12 16 14 	call	#0x1416	
    37ea:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
    37ee:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    37f2:	0f 5f       	rla	r15		
    37f4:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    37f8:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
            OS_EXIT_CRITICAL();
    37fc:	2f 44       	mov	@r4,	r15	
    37fe:	b0 12 1c 14 	call	#0x141c	
    3802:	01 3c       	jmp	$+4      	;abs 0x3806
        OS_EXIT_CRITICAL();
        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, 0);    /* Initialize the task's stack         */
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
        if (err == OS_NO_ERR) {
            if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has started */
                OS_Sched();
    3804:	03 43       	nop			
        } else {
            OS_ENTER_CRITICAL();
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
            OS_EXIT_CRITICAL();
        }
        return (err);
    3806:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    380a:	05 3c       	jmp	$+12     	;abs 0x3816
    }
    OS_EXIT_CRITICAL();
    380c:	2f 44       	mov	@r4,	r15	
    380e:	b0 12 1c 14 	call	#0x141c	
    return (OS_PRIO_EXIST);
    3812:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
}
    3816:	31 50 0e 00 	add	#14,	r1	;#0x000e
    381a:	34 41       	pop	r4		
    381c:	30 41       	ret			

0000381e <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
    381e:	0b 12       	push	r11		
    3820:	04 12       	push	r4		
    3822:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3826:	04 41       	mov	r1,	r4	
    3828:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    382c:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    3830:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
    3834:	c4 4c 0c 00 	mov.b	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                              /* Prevent compiler warning                               */
    3838:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    383c:	b0 12 16 14 	call	#0x1416	
    3840:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
    3844:	5f 42 86 03 	mov.b	&0x0386,r15	
    3848:	4f 93       	tst.b	r15		
    384a:	06 24       	jz	$+14     	;abs 0x3858
        OS_EXIT_CRITICAL();
    384c:	2f 44       	mov	@r4,	r15	
    384e:	b0 12 1c 14 	call	#0x141c	
        return (OS_ERR_TASK_CREATE_ISR);
    3852:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    3856:	63 3c       	jmp	$+200    	;abs 0x391e
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
    3858:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    385c:	0f 5f       	rla	r15		
    385e:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3862:	2f 4f       	mov	@r15,	r15	
    3864:	0f 93       	tst	r15		
    3866:	56 20       	jnz	$+174    	;abs 0x3914
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
    3868:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    386c:	0f 5f       	rla	r15		
    386e:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3872:	9f 43 00 00 	mov	#1,	0(r15)	;r3 As==01, 0x0000(r15)
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
    3876:	2f 44       	mov	@r4,	r15	
    3878:	b0 12 1c 14 	call	#0x141c	

        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
    387c:	1d 44 1e 00 	mov	30(r4),	r13	;0x001e(r4)
    3880:	1e 44 18 00 	mov	24(r4),	r14	;0x0018(r4)
    3884:	1f 44 1a 00 	mov	26(r4),	r15	;0x001a(r4)
    3888:	1b 44 16 00 	mov	22(r4),	r11	;0x0016(r4)
    388c:	0c 4d       	mov	r13,	r12	
    388e:	0d 4e       	mov	r14,	r13	
    3890:	0e 4f       	mov	r15,	r14	
    3892:	0f 4b       	mov	r11,	r15	
    3894:	b0 12 40 3a 	call	#0x3a40	

        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, opt); /* Initialize the task's stack          */
    3898:	1c 44 1e 00 	mov	30(r4),	r12	;0x001e(r4)
    389c:	1d 44 0a 00 	mov	10(r4),	r13	;0x000a(r4)
    38a0:	1e 44 08 00 	mov	8(r4),	r14	;0x0008(r4)
    38a4:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    38a8:	b0 12 60 14 	call	#0x1460	
    38ac:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
    38b0:	1d 44 16 00 	mov	22(r4),	r13	;0x0016(r4)
    38b4:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    38b8:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    38bc:	14 12 1e 00 	push	30(r4)		;0x001e(r4)
    38c0:	14 12 1c 00 	push	28(r4)		;0x001c(r4)
    38c4:	14 12 1a 00 	push	26(r4)		;0x001a(r4)
    38c8:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    38cc:	1c 44 14 00 	mov	20(r4),	r12	;0x0014(r4)
    38d0:	b0 12 9a 1e 	call	#0x1e9a	
    38d4:	31 52       	add	#8,	r1	;r2 As==11
    38d6:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
        if (err == OS_NO_ERR) {
    38da:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    38de:	07 20       	jnz	$+16     	;abs 0x38ee
            if (OSRunning == TRUE) {                           /* Find HPT if multitasking has started */
    38e0:	5f 42 0d 03 	mov.b	&0x030d,r15	
    38e4:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    38e6:	12 20       	jnz	$+38     	;abs 0x390c
                OS_Sched();
    38e8:	b0 12 bc 1d 	call	#0x1dbc	
    38ec:	10 3c       	jmp	$+34     	;abs 0x390e
            }
        } else {
            OS_ENTER_CRITICAL();
    38ee:	b0 12 16 14 	call	#0x1416	
    38f2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
    38f6:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    38fa:	0f 5f       	rla	r15		
    38fc:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3900:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
            OS_EXIT_CRITICAL();
    3904:	2f 44       	mov	@r4,	r15	
    3906:	b0 12 1c 14 	call	#0x141c	
    390a:	01 3c       	jmp	$+4      	;abs 0x390e

        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, opt); /* Initialize the task's stack          */
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
        if (err == OS_NO_ERR) {
            if (OSRunning == TRUE) {                           /* Find HPT if multitasking has started */
                OS_Sched();
    390c:	03 43       	nop			
        } else {
            OS_ENTER_CRITICAL();
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
            OS_EXIT_CRITICAL();
        }
        return (err);
    390e:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3912:	05 3c       	jmp	$+12     	;abs 0x391e
    }
    OS_EXIT_CRITICAL();
    3914:	2f 44       	mov	@r4,	r15	
    3916:	b0 12 1c 14 	call	#0x141c	
    return (OS_PRIO_EXIST);
    391a:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
}
    391e:	31 50 0e 00 	add	#14,	r1	;#0x000e
    3922:	34 41       	pop	r4		
    3924:	3b 41       	pop	r11		
    3926:	30 41       	ret			

00003928 <OSTaskStkChk>:
*              OS_TASK_OPT_ERR     if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
    3928:	04 12       	push	r4		
    392a:	31 50 ee ff 	add	#-18,	r1	;#0xffee
    392e:	04 41       	mov	r1,	r4	
    3930:	c4 4f 0e 00 	mov.b	r15,	14(r4)	;0x000e(r4)
    3934:	84 4e 10 00 	mov	r14,	16(r4)	;0x0010(r4)
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    3938:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
        if (prio != OS_PRIO_SELF) {        
            return (OS_PRIO_INVALID);
        }
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
    393c:	1f 44 10 00 	mov	16(r4),	r15	;0x0010(r4)
    3940:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    3944:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    p_stk_data->OSUsed = 0;
    3948:	1f 44 10 00 	mov	16(r4),	r15	;0x0010(r4)
    394c:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
    3950:	8f 43 06 00 	mov	#0,	6(r15)	;r3 As==00, 0x0006(r15)
    OS_ENTER_CRITICAL();
    3954:	b0 12 16 14 	call	#0x1416	
    3958:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
    395c:	f4 93 0e 00 	cmp.b	#-1,	14(r4)	;r3 As==11, 0x000e(r4)
    3960:	05 20       	jnz	$+12     	;abs 0x396c
        prio = OSTCBCur->OSTCBPrio;
    3962:	1f 42 88 03 	mov	&0x0388,r15	
    3966:	d4 4f 1c 00 	mov.b	28(r15),14(r4)	;0x001c(r15), 0x000e(r4)
    396a:	0e 00 
    }
    ptcb = OSTCBPrioTbl[prio];
    396c:	5f 44 0e 00 	mov.b	14(r4),	r15	;0x000e(r4)
    3970:	0f 5f       	rla	r15		
    3972:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3976:	a4 4f 0c 00 	mov	@r15,	12(r4)	;0x000c(r4)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
    397a:	84 93 0c 00 	tst	12(r4)		;0x000c(r4)
    397e:	06 20       	jnz	$+14     	;abs 0x398c
        OS_EXIT_CRITICAL();
    3980:	2f 44       	mov	@r4,	r15	
    3982:	b0 12 1c 14 	call	#0x141c	
        return (OS_TASK_NOT_EXIST);
    3986:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    398a:	56 3c       	jmp	$+174    	;abs 0x3a38
    }
    if (ptcb == (OS_TCB *)1) {
    398c:	94 93 0c 00 	cmp	#1,	12(r4)	;r3 As==01, 0x000c(r4)
    3990:	06 20       	jnz	$+14     	;abs 0x399e
        OS_EXIT_CRITICAL();
    3992:	2f 44       	mov	@r4,	r15	
    3994:	b0 12 1c 14 	call	#0x141c	
        return (OS_TASK_NOT_EXIST);
    3998:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    399c:	4d 3c       	jmp	$+156    	;abs 0x3a38
    }  
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
    399e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    39a2:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    39a6:	1f f3       	and	#1,	r15	;r3 As==01
    39a8:	06 20       	jnz	$+14     	;abs 0x39b6
        OS_EXIT_CRITICAL();
    39aa:	2f 44       	mov	@r4,	r15	
    39ac:	b0 12 1c 14 	call	#0x141c	
        return (OS_TASK_OPT_ERR);
    39b0:	7f 40 82 ff 	mov.b	#-126,	r15	;#0xff82
    39b4:	41 3c       	jmp	$+132    	;abs 0x3a38
    }
    free = 0;
    39b6:	84 43 06 00 	mov	#0,	6(r4)	;r3 As==00, 0x0006(r4)
    39ba:	84 43 08 00 	mov	#0,	8(r4)	;r3 As==00, 0x0008(r4)
    size = ptcb->OSTCBStkSize;
    39be:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    39c2:	94 4f 06 00 	mov	6(r15),	2(r4)	;0x0006(r15), 0x0002(r4)
    39c6:	02 00 
    39c8:	94 4f 08 00 	mov	8(r15),	4(r4)	;0x0008(r15), 0x0004(r4)
    39cc:	04 00 
    pchk = ptcb->OSTCBStkBottom;
    39ce:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    39d2:	94 4f 04 00 	mov	4(r15),	10(r4)	;0x0004(r15), 0x000a(r4)
    39d6:	0a 00 
    OS_EXIT_CRITICAL();
    39d8:	2f 44       	mov	@r4,	r15	
    39da:	b0 12 1c 14 	call	#0x141c	
    39de:	04 3c       	jmp	$+10     	;abs 0x39e8
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
        free++;
    39e0:	94 53 06 00 	inc	6(r4)		;0x0006(r4)
    39e4:	84 63 08 00 	adc	8(r4)		;0x0008(r4)
    free = 0;
    size = ptcb->OSTCBStkSize;
    pchk = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
    39e8:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    39ec:	2e 4f       	mov	@r15,	r14	
    39ee:	4f 43       	clr.b	r15		
    39f0:	0e 93       	tst	r14		
    39f2:	01 20       	jnz	$+4      	;abs 0x39f6
    39f4:	5f 43       	mov.b	#1,	r15	;r3 As==01
    39f6:	a4 53 0a 00 	incd	10(r4)		;0x000a(r4)
    39fa:	4f 93       	tst.b	r15		
    39fc:	f1 23       	jnz	$-28     	;abs 0x39e0
#else
    while (*pchk-- == (OS_STK)0) {
        free++;
    }
#endif
    p_stk_data->OSFree = free * sizeof(OS_STK);           /* Compute number of free bytes on the stack */
    39fe:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    3a02:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3a06:	0e 5e       	rla	r14		
    3a08:	0f 6f       	rlc	r15		
    3a0a:	1d 44 10 00 	mov	16(r4),	r13	;0x0010(r4)
    3a0e:	8d 4e 00 00 	mov	r14,	0(r13)	;0x0000(r13)
    3a12:	8d 4f 02 00 	mov	r15,	2(r13)	;0x0002(r13)
    p_stk_data->OSUsed = (size - free) * sizeof(OS_STK);  /* Compute number of bytes used on the stack */
    3a16:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    3a1a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3a1e:	1e 84 06 00 	sub	6(r4),	r14	;0x0006(r4)
    3a22:	1f 74 08 00 	subc	8(r4),	r15	;0x0008(r4)
    3a26:	0e 5e       	rla	r14		
    3a28:	0f 6f       	rlc	r15		
    3a2a:	1d 44 10 00 	mov	16(r4),	r13	;0x0010(r4)
    3a2e:	8d 4e 04 00 	mov	r14,	4(r13)	;0x0004(r13)
    3a32:	8d 4f 06 00 	mov	r15,	6(r13)	;0x0006(r13)
    return (OS_NO_ERR);
    3a36:	4f 43       	clr.b	r15		
}
    3a38:	31 50 12 00 	add	#18,	r1	;#0x0012
    3a3c:	34 41       	pop	r4		
    3a3e:	30 41       	ret			

00003a40 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    3a40:	04 12       	push	r4		
    3a42:	31 82       	sub	#8,	r1	;r2 As==11
    3a44:	04 41       	mov	r1,	r4	
    3a46:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    3a4a:	84 4d 02 00 	mov	r13,	2(r4)	;0x0002(r4)
    3a4e:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    3a52:	84 4c 06 00 	mov	r12,	6(r4)	;0x0006(r4)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
    3a56:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3a5a:	1f f3       	and	#1,	r15	;r3 As==01
    3a5c:	4f 93       	tst.b	r15		
    3a5e:	14 24       	jz	$+42     	;abs 0x3a88
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
    3a60:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3a64:	2f f3       	and	#2,	r15	;r3 As==10
    3a66:	10 24       	jz	$+34     	;abs 0x3a88
    3a68:	09 3c       	jmp	$+20     	;abs 0x3a7c
#if OS_STK_GROWTH == 1                     
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
                size--;
    3a6a:	b4 53 02 00 	add	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
    3a6e:	b4 63 04 00 	addc	#-1,	4(r4)	;r3 As==11, 0x0004(r4)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
    3a72:	2f 44       	mov	@r4,	r15	
    3a74:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    3a78:	a4 53 00 00 	incd	0(r4)		;0x0000(r4)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1                     
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
    3a7c:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3a80:	f4 23       	jnz	$-22     	;abs 0x3a6a
    3a82:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    3a86:	f1 23       	jnz	$-28     	;abs 0x3a6a
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
    3a88:	31 52       	add	#8,	r1	;r2 As==11
    3a8a:	34 41       	pop	r4		
    3a8c:	30 41       	ret			

00003a8e <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
    3a8e:	04 12       	push	r4		
    3a90:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3a94:	04 41       	mov	r1,	r4	
    3a96:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    3a9a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (ticks > 0) {                             /* 0 means no delay!                                  */
    3a9e:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    3aa2:	33 24       	jz	$+104    	;abs 0x3b0a
        OS_ENTER_CRITICAL();
    3aa4:	b0 12 16 14 	call	#0x1416	
    3aa8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
    3aac:	1f 42 88 03 	mov	&0x0388,r15	
    3ab0:	d4 4f 1e 00 	mov.b	30(r15),2(r4)	;0x001e(r15), 0x0002(r4)
    3ab4:	02 00 
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
    3ab6:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    3aba:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3abe:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    3ac2:	4e 4f       	mov.b	r15,	r14	
    3ac4:	1f 42 88 03 	mov	&0x0388,r15	
    3ac8:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    3acc:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    3ace:	4f fe       	and.b	r14,	r15	
    3ad0:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        if (OSRdyTbl[y] == 0) {  
    3ad4:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3ad8:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    3adc:	4f 93       	tst.b	r15		
    3ade:	0b 20       	jnz	$+24     	;abs 0x3af6
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
    3ae0:	1f 42 88 03 	mov	&0x0388,r15	
    3ae4:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    3ae8:	4e 4f       	mov.b	r15,	r14	
    3aea:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    3aec:	5f 42 7e 03 	mov.b	&0x037e,r15	
    3af0:	4f fe       	and.b	r14,	r15	
    3af2:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
    3af6:	1f 42 88 03 	mov	&0x0388,r15	
    3afa:	9f 44 04 00 	mov	4(r4),	24(r15)	;0x0004(r4), 0x0018(r15)
    3afe:	18 00 
        OS_EXIT_CRITICAL();
    3b00:	2f 44       	mov	@r4,	r15	
    3b02:	b0 12 1c 14 	call	#0x141c	
        OS_Sched();                              /* Find next task to run!                             */
    3b06:	b0 12 bc 1d 	call	#0x1dbc	
    }
}
    3b0a:	31 50 06 00 	add	#6,	r1	;#0x0006
    3b0e:	34 41       	pop	r4		
    3b10:	30 41       	ret			

00003b12 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U milli)
{
    3b12:	0b 12       	push	r11		
    3b14:	0a 12       	push	r10		
    3b16:	09 12       	push	r9		
    3b18:	08 12       	push	r8		
    3b1a:	07 12       	push	r7		
    3b1c:	06 12       	push	r6		
    3b1e:	04 12       	push	r4		
    3b20:	31 50 f0 ff 	add	#-16,	r1	;#0xfff0
    3b24:	04 41       	mov	r1,	r4	
    3b26:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
    3b2a:	c4 4e 07 00 	mov.b	r14,	7(r4)	;0x0007(r4)
    3b2e:	c4 4d 08 00 	mov.b	r13,	8(r4)	;0x0008(r4)
    3b32:	84 4c 0a 00 	mov	r12,	10(r4)	;0x000a(r4)
        return (OS_TIME_INVALID_MILLI);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
    3b36:	5c 44 06 00 	mov.b	6(r4),	r12	;0x0006(r4)
    3b3a:	0d 43       	clr	r13		
    3b3c:	0e 4c       	mov	r12,	r14	
    3b3e:	0f 4d       	mov	r13,	r15	
    3b40:	0e 5e       	rla	r14		
    3b42:	0f 6f       	rlc	r15		
    3b44:	0e 5e       	rla	r14		
    3b46:	0f 6f       	rlc	r15		
    3b48:	0e 5e       	rla	r14		
    3b4a:	0f 6f       	rlc	r15		
    3b4c:	0e 8c       	sub	r12,	r14	
    3b4e:	0f 7d       	subc	r13,	r15	
    3b50:	0a 4e       	mov	r14,	r10	
    3b52:	0b 4f       	mov	r15,	r11	
    3b54:	4b ea       	xor.b	r10,	r11	
    3b56:	0b ea       	xor	r10,	r11	
    3b58:	8b 10       	swpb	r11		
    3b5a:	7a f3       	and.b	#-1,	r10	;r3 As==11
    3b5c:	8a 10       	swpb	r10		
    3b5e:	0e 5a       	add	r10,	r14	
    3b60:	0f 6b       	addc	r11,	r15	
    3b62:	0e 5e       	rla	r14		
    3b64:	0f 6f       	rlc	r15		
    3b66:	0e 5c       	add	r12,	r14	
    3b68:	0f 6d       	addc	r13,	r15	
    3b6a:	0a 4e       	mov	r14,	r10	
    3b6c:	0b 4f       	mov	r15,	r11	
    3b6e:	0a 5c       	add	r12,	r10	
    3b70:	0b 6d       	addc	r13,	r11	
    3b72:	5c 44 07 00 	mov.b	7(r4),	r12	;0x0007(r4)
    3b76:	0d 43       	clr	r13		
    3b78:	0e 4c       	mov	r12,	r14	
    3b7a:	0f 4d       	mov	r13,	r15	
    3b7c:	0e 5e       	rla	r14		
    3b7e:	0f 6f       	rlc	r15		
    3b80:	0e 5e       	rla	r14		
    3b82:	0f 6f       	rlc	r15		
    3b84:	0e 5e       	rla	r14		
    3b86:	0f 6f       	rlc	r15		
    3b88:	0e 5e       	rla	r14		
    3b8a:	0f 6f       	rlc	r15		
    3b8c:	0e 8c       	sub	r12,	r14	
    3b8e:	0f 7d       	subc	r13,	r15	
    3b90:	0e 5e       	rla	r14		
    3b92:	0f 6f       	rlc	r15		
    3b94:	0e 5e       	rla	r14		
    3b96:	0f 6f       	rlc	r15		
    3b98:	0c 4a       	mov	r10,	r12	
    3b9a:	0d 4b       	mov	r11,	r13	
    3b9c:	0c 5e       	add	r14,	r12	
    3b9e:	0d 6f       	addc	r15,	r13	
    3ba0:	5e 44 08 00 	mov.b	8(r4),	r14	;0x0008(r4)
    3ba4:	0f 43       	clr	r15		
    3ba6:	0a 4c       	mov	r12,	r10	
    3ba8:	0b 4d       	mov	r13,	r11	
    3baa:	0a 5e       	add	r14,	r10	
    3bac:	0b 6f       	addc	r15,	r11	
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    3bae:	0c 4a       	mov	r10,	r12	
    3bb0:	0d 4b       	mov	r11,	r13	
    3bb2:	0e 4c       	mov	r12,	r14	
    3bb4:	0f 4d       	mov	r13,	r15	
    3bb6:	0e 5e       	rla	r14		
    3bb8:	0f 6f       	rlc	r15		
    3bba:	0c 4e       	mov	r14,	r12	
    3bbc:	0d 4f       	mov	r15,	r13	
    3bbe:	0c 5a       	add	r10,	r12	
    3bc0:	0d 6b       	addc	r11,	r13	
    3bc2:	0e 4c       	mov	r12,	r14	
    3bc4:	0f 4d       	mov	r13,	r15	
    3bc6:	0e 5e       	rla	r14		
    3bc8:	0f 6f       	rlc	r15		
    3bca:	0e 5e       	rla	r14		
    3bcc:	0f 6f       	rlc	r15		
    3bce:	0e 5e       	rla	r14		
    3bd0:	0f 6f       	rlc	r15		
    3bd2:	0e 5e       	rla	r14		
    3bd4:	0f 6f       	rlc	r15		
    3bd6:	0e 5e       	rla	r14		
    3bd8:	0f 6f       	rlc	r15		
    3bda:	0c 5e       	add	r14,	r12	
    3bdc:	0d 6f       	addc	r15,	r13	
    3bde:	0e 4c       	mov	r12,	r14	
    3be0:	0f 4d       	mov	r13,	r15	
    3be2:	0e 5a       	add	r10,	r14	
    3be4:	0f 6b       	addc	r11,	r15	
    3be6:	84 4e 0c 00 	mov	r14,	12(r4)	;0x000c(r4)
    3bea:	84 4f 0e 00 	mov	r15,	14(r4)	;0x000e(r4)
    3bee:	1a 44 0a 00 	mov	10(r4),	r10	;0x000a(r4)
    3bf2:	0b 43       	clr	r11		
    3bf4:	0c 4a       	mov	r10,	r12	
    3bf6:	0d 4b       	mov	r11,	r13	
    3bf8:	0e 4c       	mov	r12,	r14	
    3bfa:	0f 4d       	mov	r13,	r15	
    3bfc:	0e 5e       	rla	r14		
    3bfe:	0f 6f       	rlc	r15		
    3c00:	0c 4e       	mov	r14,	r12	
    3c02:	0d 4f       	mov	r15,	r13	
    3c04:	0c 5a       	add	r10,	r12	
    3c06:	0d 6b       	addc	r11,	r13	
    3c08:	0e 4c       	mov	r12,	r14	
    3c0a:	0f 4d       	mov	r13,	r15	
    3c0c:	0e 5e       	rla	r14		
    3c0e:	0f 6f       	rlc	r15		
    3c10:	0e 5e       	rla	r14		
    3c12:	0f 6f       	rlc	r15		
    3c14:	0e 5e       	rla	r14		
    3c16:	0f 6f       	rlc	r15		
    3c18:	0e 5e       	rla	r14		
    3c1a:	0f 6f       	rlc	r15		
    3c1c:	0e 5e       	rla	r14		
    3c1e:	0f 6f       	rlc	r15		
    3c20:	0c 5e       	add	r14,	r12	
    3c22:	0d 6f       	addc	r15,	r13	
    3c24:	0e 4c       	mov	r12,	r14	
    3c26:	0f 4d       	mov	r13,	r15	
    3c28:	0e 5a       	add	r10,	r14	
    3c2a:	0f 6b       	addc	r11,	r15	
    3c2c:	0c 4e       	mov	r14,	r12	
    3c2e:	0d 4f       	mov	r15,	r13	
    3c30:	3c 50 f4 01 	add	#500,	r12	;#0x01f4
    3c34:	0d 63       	adc	r13		
    3c36:	3e 40 e8 03 	mov	#1000,	r14	;#0x03e8
    3c3a:	0f 43       	clr	r15		
    3c3c:	0a 4e       	mov	r14,	r10	
    3c3e:	0b 4f       	mov	r15,	r11	
    3c40:	b0 12 f8 45 	call	#0x45f8	
    3c44:	0e 4c       	mov	r12,	r14	
    3c46:	0f 4d       	mov	r13,	r15	
        return (OS_TIME_INVALID_MILLI);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
    3c48:	1c 44 0c 00 	mov	12(r4),	r12	;0x000c(r4)
    3c4c:	1d 44 0e 00 	mov	14(r4),	r13	;0x000e(r4)
    3c50:	0c 5e       	add	r14,	r12	
    3c52:	0d 6f       	addc	r15,	r13	
    3c54:	84 4c 02 00 	mov	r12,	2(r4)	;0x0002(r4)
    3c58:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    3c5c:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    3c60:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3c64:	07 43       	clr	r7		
    3c66:	06 4f       	mov	r15,	r6	
    3c68:	07 43       	clr	r7		
    3c6a:	84 46 00 00 	mov	r6,	0(r4)	;0x0000(r4)
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    3c6e:	84 f3 04 00 	and	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    OSTimeDly((INT16U)ticks);
    3c72:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3c76:	b0 12 8e 3a 	call	#0x3a8e	
    3c7a:	0a 3c       	jmp	$+22     	;abs 0x3c90
    while (loops > 0) {
        OSTimeDly((INT16U)32768u);
    3c7c:	3f 40 00 80 	mov	#-32768,r15	;#0x8000
    3c80:	b0 12 8e 3a 	call	#0x3a8e	
        OSTimeDly((INT16U)32768u);
    3c84:	3f 40 00 80 	mov	#-32768,r15	;#0x8000
    3c88:	b0 12 8e 3a 	call	#0x3a8e	
        loops--;
    3c8c:	b4 53 00 00 	add	#-1,	0(r4)	;r3 As==11, 0x0000(r4)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
    3c90:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    3c94:	f3 23       	jnz	$-24     	;abs 0x3c7c
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_NO_ERR);
    3c96:	4f 43       	clr.b	r15		
}
    3c98:	31 50 10 00 	add	#16,	r1	;#0x0010
    3c9c:	34 41       	pop	r4		
    3c9e:	36 41       	pop	r6		
    3ca0:	37 41       	pop	r7		
    3ca2:	38 41       	pop	r8		
    3ca4:	39 41       	pop	r9		
    3ca6:	3a 41       	pop	r10		
    3ca8:	3b 41       	pop	r11		
    3caa:	30 41       	ret			

00003cac <initDisplay>:



#include "Display.h"

void initDisplay() {
    3cac:	04 12       	push	r4		
    3cae:	04 41       	mov	r1,	r4	
	InitOsc();
    3cb0:	b0 12 b8 3f 	call	#0x3fb8	
	InitPortsDisplay();
    3cb4:	b0 12 3c 40 	call	#0x403c	
	InitLCD();
    3cb8:	b0 12 62 42 	call	#0x4262	
	clearDisplay();
    3cbc:	b0 12 da 3c 	call	#0x3cda	
}
    3cc0:	34 41       	pop	r4		
    3cc2:	30 41       	ret			

00003cc4 <putch>:
void putch(char c) {
    3cc4:	04 12       	push	r4		
    3cc6:	21 83       	decd	r1		
    3cc8:	04 41       	mov	r1,	r4	
    3cca:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
	SEND_CHAR(c);
    3cce:	6f 44       	mov.b	@r4,	r15	
    3cd0:	b0 12 3a 41 	call	#0x413a	
}
    3cd4:	21 53       	incd	r1		
    3cd6:	34 41       	pop	r4		
    3cd8:	30 41       	ret			

00003cda <clearDisplay>:
void clearDisplay() {
    3cda:	04 12       	push	r4		
    3cdc:	04 41       	mov	r1,	r4	
	SEND_CMD(CLR_DISP);
    3cde:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3ce0:	b0 12 ce 41 	call	#0x41ce	
	Delayx100us(10);
    3ce4:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3ce8:	0f 43       	clr	r15		
    3cea:	b0 12 d2 40 	call	#0x40d2	
}
    3cee:	34 41       	pop	r4		
    3cf0:	30 41       	ret			

00003cf2 <gotoSecondLine>:
void gotoSecondLine() {
    3cf2:	04 12       	push	r4		
    3cf4:	04 41       	mov	r1,	r4	
//    SEND_CMD(CLR_DISP);
	SEND_CMD(DD_RAM_ADDR2);
    3cf6:	7f 40 c0 ff 	mov.b	#-64,	r15	;#0xffc0
    3cfa:	b0 12 ce 41 	call	#0x41ce	
}
    3cfe:	34 41       	pop	r4		
    3d00:	30 41       	ret			

00003d02 <printString>:
void printString(char *String) {
    3d02:	04 12       	push	r4		
    3d04:	21 83       	decd	r1		
    3d06:	04 41       	mov	r1,	r4	
    3d08:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    3d0c:	06 3c       	jmp	$+14     	;abs 0x3d1a
	while (*String)
		putch(*String++);
    3d0e:	2f 44       	mov	@r4,	r15	
    3d10:	6f 4f       	mov.b	@r15,	r15	
    3d12:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    3d16:	b0 12 c4 3c 	call	#0x3cc4	
void gotoSecondLine() {
//    SEND_CMD(CLR_DISP);
	SEND_CMD(DD_RAM_ADDR2);
}
void printString(char *String) {
	while (*String)
    3d1a:	2f 44       	mov	@r4,	r15	
    3d1c:	6f 4f       	mov.b	@r15,	r15	
    3d1e:	4f 93       	tst.b	r15		
    3d20:	f6 23       	jnz	$-18     	;abs 0x3d0e
		putch(*String++);
}
    3d22:	21 53       	incd	r1		
    3d24:	34 41       	pop	r4		
    3d26:	30 41       	ret			

00003d28 <HexDigit>:
char HexDigit(int digitvalue) {
    3d28:	04 12       	push	r4		
    3d2a:	21 83       	decd	r1		
    3d2c:	04 41       	mov	r1,	r4	
    3d2e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	if (digitvalue < 10)
    3d32:	b4 90 0a 00 	cmp	#10,	0(r4)	;#0x000a, 0x0000(r4)
    3d36:	00 00 
    3d38:	04 34       	jge	$+10     	;abs 0x3d42
		return (digitvalue + '0');
    3d3a:	2f 44       	mov	@r4,	r15	
    3d3c:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3d40:	03 3c       	jmp	$+8      	;abs 0x3d48
	else
		return (digitvalue + 'A' - 10);
    3d42:	2f 44       	mov	@r4,	r15	
    3d44:	7f 50 37 00 	add.b	#55,	r15	;#0x0037
}
    3d48:	21 53       	incd	r1		
    3d4a:	34 41       	pop	r4		
    3d4c:	30 41       	ret			

00003d4e <printByte>:
void printByte(INT8U theByte) {
    3d4e:	04 12       	push	r4		
    3d50:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3d54:	04 41       	mov	r1,	r4	
    3d56:	c4 4f 04 00 	mov.b	r15,	4(r4)	;0x0004(r4)
	char HexBuffer[3];
	HexBuffer[2] = '\0';
    3d5a:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
	HexBuffer[1] = HexDigit(theByte & 0x000f);
    3d5e:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    3d62:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d66:	b0 12 28 3d 	call	#0x3d28	
    3d6a:	c4 4f 01 00 	mov.b	r15,	1(r4)	;0x0001(r4)
	theByte = theByte >> 4;
    3d6e:	12 c3       	clrc			
    3d70:	54 10 04 00 	rrc.b	4(r4)		;0x0004(r4)
    3d74:	54 11 04 00 	rra.b	4(r4)		;0x0004(r4)
    3d78:	54 11 04 00 	rra.b	4(r4)		;0x0004(r4)
    3d7c:	54 11 04 00 	rra.b	4(r4)		;0x0004(r4)
	HexBuffer[0] = HexDigit(theByte & 0x000f);
    3d80:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    3d84:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d88:	b0 12 28 3d 	call	#0x3d28	
    3d8c:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
	printString(HexBuffer);
    3d90:	0f 44       	mov	r4,	r15	
    3d92:	b0 12 02 3d 	call	#0x3d02	
}
    3d96:	31 50 06 00 	add	#6,	r1	;#0x0006
    3d9a:	34 41       	pop	r4		
    3d9c:	30 41       	ret			

00003d9e <printHex>:
void printHex(unsigned int Number) {
    3d9e:	04 12       	push	r4		
    3da0:	31 82       	sub	#8,	r1	;r2 As==11
    3da2:	04 41       	mov	r1,	r4	
    3da4:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	char HexBuffer[5];
	HexBuffer[4] = 0;
    3da8:	c4 43 04 00 	mov.b	#0,	4(r4)	;r3 As==00, 0x0004(r4)
	HexBuffer[3] = HexDigit(Number & 0x000f);
    3dac:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3db0:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3db4:	b0 12 28 3d 	call	#0x3d28	
    3db8:	c4 4f 03 00 	mov.b	r15,	3(r4)	;0x0003(r4)
	Number = Number >> 4;
    3dbc:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3dc0:	12 c3       	clrc			
    3dc2:	0f 10       	rrc	r15		
    3dc4:	0f 11       	rra	r15		
    3dc6:	0f 11       	rra	r15		
    3dc8:	0f 11       	rra	r15		
    3dca:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	HexBuffer[2] = HexDigit(Number & 0x000f);
    3dce:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3dd2:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3dd6:	b0 12 28 3d 	call	#0x3d28	
    3dda:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
	Number = Number >> 4;
    3dde:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3de2:	12 c3       	clrc			
    3de4:	0f 10       	rrc	r15		
    3de6:	0f 11       	rra	r15		
    3de8:	0f 11       	rra	r15		
    3dea:	0f 11       	rra	r15		
    3dec:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	HexBuffer[1] = HexDigit(Number & 0x000f);
    3df0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3df4:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3df8:	b0 12 28 3d 	call	#0x3d28	
    3dfc:	c4 4f 01 00 	mov.b	r15,	1(r4)	;0x0001(r4)
	Number = Number >> 4;
    3e00:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3e04:	12 c3       	clrc			
    3e06:	0f 10       	rrc	r15		
    3e08:	0f 11       	rra	r15		
    3e0a:	0f 11       	rra	r15		
    3e0c:	0f 11       	rra	r15		
    3e0e:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	HexBuffer[0] = HexDigit(Number & 0x000f);
    3e12:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3e16:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3e1a:	b0 12 28 3d 	call	#0x3d28	
    3e1e:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
	printString(HexBuffer);
    3e22:	0f 44       	mov	r4,	r15	
    3e24:	b0 12 02 3d 	call	#0x3d02	
}
    3e28:	31 52       	add	#8,	r1	;r2 As==11
    3e2a:	34 41       	pop	r4		
    3e2c:	30 41       	ret			

00003e2e <printDecimal>:
void printDecimal(int Number) {
    3e2e:	0b 12       	push	r11		
    3e30:	0a 12       	push	r10		
    3e32:	09 12       	push	r9		
    3e34:	08 12       	push	r8		
    3e36:	04 12       	push	r4		
    3e38:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3e3c:	04 41       	mov	r1,	r4	
    3e3e:	84 4f 0c 00 	mov	r15,	12(r4)	;0x000c(r4)
	// need to move to long int to account for
	// negative 32768
	char DecimalBuffer[7];
	long lNumber = Number;
    3e42:	94 44 0c 00 	mov	12(r4),	0(r4)	;0x000c(r4), 0x0000(r4)
    3e46:	00 00 
    3e48:	a4 44 02 00 	mov	@r4,	2(r4)	;0x0002(r4)
    3e4c:	94 54 02 00 	rla	2(r4)		;0x0002(r4)
    3e50:	02 00 
    3e52:	94 74 02 00 	subc	2(r4),	2(r4)	;0x0002(r4), 0x0002(r4)
    3e56:	02 00 
    3e58:	b4 e3 02 00 	xor	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
	DecimalBuffer[6] = 0;
    3e5c:	c4 43 0a 00 	mov.b	#0,	10(r4)	;r3 As==00, 0x000a(r4)
	if (lNumber < 0) {
    3e60:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3e64:	0f 34       	jge	$+32     	;abs 0x3e84
		DecimalBuffer[0] = '-';
    3e66:	f4 40 2d 00 	mov.b	#45,	4(r4)	;#0x002d, 0x0004(r4)
    3e6a:	04 00 
		lNumber = -lNumber;
    3e6c:	2e 44       	mov	@r4,	r14	
    3e6e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3e72:	3e e3       	inv	r14		
    3e74:	3f e3       	inv	r15		
    3e76:	1e 53       	inc	r14		
    3e78:	0f 63       	adc	r15		
    3e7a:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3e7e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    3e82:	03 3c       	jmp	$+8      	;abs 0x3e8a
	} else
		DecimalBuffer[0] = '+';
    3e84:	f4 40 2b 00 	mov.b	#43,	4(r4)	;#0x002b, 0x0004(r4)
    3e88:	04 00 
	DecimalBuffer[5] = (lNumber % 10) + '0';
    3e8a:	2c 44       	mov	@r4,	r12	
    3e8c:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3e90:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3e94:	0f 43       	clr	r15		
    3e96:	0a 4e       	mov	r14,	r10	
    3e98:	0b 4f       	mov	r15,	r11	
    3e9a:	b0 12 22 46 	call	#0x4622	
    3e9e:	4f 4e       	mov.b	r14,	r15	
    3ea0:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3ea4:	c4 4f 09 00 	mov.b	r15,	9(r4)	;0x0009(r4)
	lNumber = lNumber / 10;
    3ea8:	2c 44       	mov	@r4,	r12	
    3eaa:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3eae:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3eb2:	0f 43       	clr	r15		
    3eb4:	0a 4e       	mov	r14,	r10	
    3eb6:	0b 4f       	mov	r15,	r11	
    3eb8:	b0 12 22 46 	call	#0x4622	
    3ebc:	0e 4c       	mov	r12,	r14	
    3ebe:	0f 4d       	mov	r13,	r15	
    3ec0:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3ec4:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[4] = (lNumber % 10) + '0';
    3ec8:	2c 44       	mov	@r4,	r12	
    3eca:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3ece:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3ed2:	0f 43       	clr	r15		
    3ed4:	0a 4e       	mov	r14,	r10	
    3ed6:	0b 4f       	mov	r15,	r11	
    3ed8:	b0 12 22 46 	call	#0x4622	
    3edc:	4f 4e       	mov.b	r14,	r15	
    3ede:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3ee2:	c4 4f 08 00 	mov.b	r15,	8(r4)	;0x0008(r4)
	lNumber = lNumber / 10;
    3ee6:	2c 44       	mov	@r4,	r12	
    3ee8:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3eec:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3ef0:	0f 43       	clr	r15		
    3ef2:	0a 4e       	mov	r14,	r10	
    3ef4:	0b 4f       	mov	r15,	r11	
    3ef6:	b0 12 22 46 	call	#0x4622	
    3efa:	0e 4c       	mov	r12,	r14	
    3efc:	0f 4d       	mov	r13,	r15	
    3efe:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3f02:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[3] = (lNumber % 10) + '0';
    3f06:	2c 44       	mov	@r4,	r12	
    3f08:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f0c:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f10:	0f 43       	clr	r15		
    3f12:	0a 4e       	mov	r14,	r10	
    3f14:	0b 4f       	mov	r15,	r11	
    3f16:	b0 12 22 46 	call	#0x4622	
    3f1a:	4f 4e       	mov.b	r14,	r15	
    3f1c:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3f20:	c4 4f 07 00 	mov.b	r15,	7(r4)	;0x0007(r4)
	lNumber = lNumber / 10;
    3f24:	2c 44       	mov	@r4,	r12	
    3f26:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f2a:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f2e:	0f 43       	clr	r15		
    3f30:	0a 4e       	mov	r14,	r10	
    3f32:	0b 4f       	mov	r15,	r11	
    3f34:	b0 12 22 46 	call	#0x4622	
    3f38:	0e 4c       	mov	r12,	r14	
    3f3a:	0f 4d       	mov	r13,	r15	
    3f3c:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3f40:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[2] = (lNumber % 10) + '0';
    3f44:	2c 44       	mov	@r4,	r12	
    3f46:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f4a:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f4e:	0f 43       	clr	r15		
    3f50:	0a 4e       	mov	r14,	r10	
    3f52:	0b 4f       	mov	r15,	r11	
    3f54:	b0 12 22 46 	call	#0x4622	
    3f58:	4f 4e       	mov.b	r14,	r15	
    3f5a:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3f5e:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
	lNumber = lNumber / 10;
    3f62:	2c 44       	mov	@r4,	r12	
    3f64:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f68:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f6c:	0f 43       	clr	r15		
    3f6e:	0a 4e       	mov	r14,	r10	
    3f70:	0b 4f       	mov	r15,	r11	
    3f72:	b0 12 22 46 	call	#0x4622	
    3f76:	0e 4c       	mov	r12,	r14	
    3f78:	0f 4d       	mov	r13,	r15	
    3f7a:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3f7e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[1] = (lNumber % 10) + '0';
    3f82:	2c 44       	mov	@r4,	r12	
    3f84:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f88:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f8c:	0f 43       	clr	r15		
    3f8e:	0a 4e       	mov	r14,	r10	
    3f90:	0b 4f       	mov	r15,	r11	
    3f92:	b0 12 22 46 	call	#0x4622	
    3f96:	4f 4e       	mov.b	r14,	r15	
    3f98:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3f9c:	c4 4f 05 00 	mov.b	r15,	5(r4)	;0x0005(r4)
	printString(DecimalBuffer);
    3fa0:	0f 44       	mov	r4,	r15	
    3fa2:	2f 52       	add	#4,	r15	;r2 As==10
    3fa4:	b0 12 02 3d 	call	#0x3d02	
}
    3fa8:	31 50 0e 00 	add	#14,	r1	;#0x000e
    3fac:	34 41       	pop	r4		
    3fae:	38 41       	pop	r8		
    3fb0:	39 41       	pop	r9		
    3fb2:	3a 41       	pop	r10		
    3fb4:	3b 41       	pop	r11		
    3fb6:	30 41       	ret			

00003fb8 <InitOsc>:

void InitOsc(void) {
    3fb8:	04 12       	push	r4		
    3fba:	04 41       	mov	r1,	r4	
	WDTCTL = WDTPW | WDTHOLD; // stop watchdog timer
    3fbc:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    3fc0:	20 01 

	BCSCTL1 |= XTS; // XT1 as high-frequency
    3fc2:	5f 42 57 00 	mov.b	&0x0057,r15	
    3fc6:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    3fca:	c2 4f 57 00 	mov.b	r15,	&0x0057	
	_BIC_SR(OSCOFF);
    3fce:	32 c0 20 00 	bic	#32,	r2	;#0x0020
	// turn on XT1 oscillator

	do // wait in loop until crystal is stable
		IFG1 &= ~OFIFG;
    3fd2:	5f 42 02 00 	mov.b	&0x0002,r15	
    3fd6:	6f c3       	bic.b	#2,	r15	;r3 As==10
    3fd8:	c2 4f 02 00 	mov.b	r15,	&0x0002	
	while (IFG1 & OFIFG);
    3fdc:	5f 42 02 00 	mov.b	&0x0002,r15	
    3fe0:	7f f3       	and.b	#-1,	r15	;r3 As==11
    3fe2:	2f f3       	and	#2,	r15	;r3 As==10
    3fe4:	f6 23       	jnz	$-18     	;abs 0x3fd2

	BCSCTL1 |= DIVA0; // ACLK = XT1 / 2
    3fe6:	5f 42 57 00 	mov.b	&0x0057,r15	
    3fea:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    3fee:	c2 4f 57 00 	mov.b	r15,	&0x0057	
	BCSCTL1 &= ~DIVA1;
    3ff2:	5f 42 57 00 	mov.b	&0x0057,r15	
    3ff6:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    3ffa:	c2 4f 57 00 	mov.b	r15,	&0x0057	

	IE1 &= ~WDTIE; // disable WDT int.
    3ffe:	5f 42 00 00 	mov.b	&0x0000,r15	
    4002:	5f c3       	bic.b	#1,	r15	;r3 As==01
    4004:	c2 4f 00 00 	mov.b	r15,	&0x0000	
	IFG1 &= ~WDTIFG; // clear WDT int. flag
    4008:	5f 42 02 00 	mov.b	&0x0002,r15	
    400c:	5f c3       	bic.b	#1,	r15	;r3 As==01
    400e:	c2 4f 02 00 	mov.b	r15,	&0x0002	

	WDTCTL = WDTPW | WDTTMSEL | WDTCNTCL | WDTSSEL | WDTIS1; // use WDT as timer, flag each
    4012:	b2 40 1e 5a 	mov	#23070,	&0x0120	;#0x5a1e
    4016:	20 01 
															 // 512 pulses from ACLK

	while (!(IFG1 & WDTIFG))
    4018:	5f 42 02 00 	mov.b	&0x0002,r15	
    401c:	7f f3       	and.b	#-1,	r15	;r3 As==11
    401e:	1f f3       	and	#1,	r15	;r3 As==01
    4020:	fb 27       	jz	$-8      	;abs 0x4018
		; // count 1024 pulses from XT1 (until XT1's
		  // amplitude is OK)

	IFG1 &= ~OFIFG; // clear osc. fault int. flag
    4022:	5f 42 02 00 	mov.b	&0x0002,r15	
    4026:	6f c3       	bic.b	#2,	r15	;r3 As==10
    4028:	c2 4f 02 00 	mov.b	r15,	&0x0002	
	BCSCTL2 |= SELM0 | SELM1; // set XT1 as MCLK
    402c:	5f 42 58 00 	mov.b	&0x0058,r15	
    4030:	7f d0 c0 ff 	bis.b	#-64,	r15	;#0xffc0
    4034:	c2 4f 58 00 	mov.b	r15,	&0x0058	
}
    4038:	34 41       	pop	r4		
    403a:	30 41       	ret			

0000403c <InitPortsDisplay>:

void InitPortsDisplay(void) {
    403c:	04 12       	push	r4		
    403e:	04 41       	mov	r1,	r4	
	P1SEL = 0; //
    4040:	c2 43 26 00 	mov.b	#0,	&0x0026	;r3 As==00
	P1OUT = 0; //
    4044:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00
	P1DIR = BIT5 | BIT6; //enable only Relay outputs
    4048:	f2 40 60 00 	mov.b	#96,	&0x0022	;#0x0060
    404c:	22 00 

	P2SEL = 0;
    404e:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00
	P2OUT = 0;
    4052:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00
	P2DIR = ~BIT0; //only P2.0 is input
    4056:	f2 40 fe ff 	mov.b	#-2,	&0x002a	;#0xfffe
    405a:	2a 00 

	P3SEL |= BIT4 | BIT5; //enable UART0
    405c:	5f 42 1b 00 	mov.b	&0x001b,r15	
    4060:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    4064:	c2 4f 1b 00 	mov.b	r15,	&0x001b	
	P3DIR |= BIT4; //enable TXD0 as output
    4068:	5f 42 1a 00 	mov.b	&0x001a,r15	
    406c:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    4070:	c2 4f 1a 00 	mov.b	r15,	&0x001a	
	P3DIR &= ~BIT5; //enable RXD0 as input
    4074:	5f 42 1a 00 	mov.b	&0x001a,r15	
    4078:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    407c:	c2 4f 1a 00 	mov.b	r15,	&0x001a	

	P4SEL = 0;
    4080:	c2 43 1f 00 	mov.b	#0,	&0x001f	;r3 As==00
	P4OUT = 0;
    4084:	c2 43 1d 00 	mov.b	#0,	&0x001d	;r3 As==00
	P4DIR = BIT2 | BIT3; //only buzzer pins are outputs
    4088:	f2 40 0c 00 	mov.b	#12,	&0x001e	;#0x000c
    408c:	1e 00 

	//P6SEL = 0x80;
	//P6OUT = 0;
	//P6DIR = 0x00;
	//all output
}
    408e:	34 41       	pop	r4		
    4090:	30 41       	ret			

00004092 <Delay>:

void Delay(unsigned long int a)

{
    4092:	04 12       	push	r4		
    4094:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    4098:	04 41       	mov	r1,	r4	
    409a:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    409e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
	int k;
	for (k = 0; k != a; ++k) {
    40a2:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    40a6:	06 3c       	jmp	$+14     	;abs 0x40b4
		_NOP();
    40a8:	03 43       	nop			
		_NOP();
    40aa:	03 43       	nop			
		_NOP();
    40ac:	03 43       	nop			
		_NOP();
    40ae:	03 43       	nop			

void Delay(unsigned long int a)

{
	int k;
	for (k = 0; k != a; ++k) {
    40b0:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    40b4:	2e 44       	mov	@r4,	r14	
    40b6:	0f 4e       	mov	r14,	r15	
    40b8:	0f 5f       	rla	r15		
    40ba:	0f 7f       	subc	r15,	r15	
    40bc:	3f e3       	inv	r15		
    40be:	1e 94 02 00 	cmp	2(r4),	r14	;0x0002(r4)
    40c2:	f2 23       	jnz	$-26     	;abs 0x40a8
    40c4:	1f 94 04 00 	cmp	4(r4),	r15	;0x0004(r4)
    40c8:	ef 23       	jnz	$-32     	;abs 0x40a8
		_NOP();
		_NOP();
		_NOP();
		_NOP();
	}
}
    40ca:	31 50 06 00 	add	#6,	r1	;#0x0006
    40ce:	34 41       	pop	r4		
    40d0:	30 41       	ret			

000040d2 <Delayx100us>:

void Delayx100us(unsigned long int b) {
    40d2:	04 12       	push	r4		
    40d4:	31 82       	sub	#8,	r1	;r2 As==11
    40d6:	04 41       	mov	r1,	r4	
    40d8:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    40dc:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	long int j;

	for (j = 0; j != b; ++j)
    40e0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    40e4:	84 43 02 00 	mov	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    40e8:	09 3c       	jmp	$+20     	;abs 0x40fc
		Delay(_100us);
    40ea:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    40ee:	0f 43       	clr	r15		
    40f0:	b0 12 92 40 	call	#0x4092	
}

void Delayx100us(unsigned long int b) {
	long int j;

	for (j = 0; j != b; ++j)
    40f4:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    40f8:	84 63 02 00 	adc	2(r4)		;0x0002(r4)
    40fc:	2e 44       	mov	@r4,	r14	
    40fe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    4102:	1e 94 04 00 	cmp	4(r4),	r14	;0x0004(r4)
    4106:	f1 23       	jnz	$-28     	;abs 0x40ea
    4108:	1f 94 06 00 	cmp	6(r4),	r15	;0x0006(r4)
    410c:	ee 23       	jnz	$-34     	;abs 0x40ea
		Delay(_100us);
}
    410e:	31 52       	add	#8,	r1	;r2 As==11
    4110:	34 41       	pop	r4		
    4112:	30 41       	ret			

00004114 <_E>:

void _E(void) {
    4114:	04 12       	push	r4		
    4116:	04 41       	mov	r1,	r4	
	bitset(P2OUT, E);
    4118:	5f 42 29 00 	mov.b	&0x0029,r15	
    411c:	7f d2       	bis.b	#8,	r15	;r2 As==11
    411e:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//toggle E for LCD
	Delay(_10us);
    4122:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    4126:	0f 43       	clr	r15		
    4128:	b0 12 92 40 	call	#0x4092	
	bitclr(P2OUT, E);
    412c:	5f 42 29 00 	mov.b	&0x0029,r15	
    4130:	7f c2       	bic.b	#8,	r15	;r2 As==11
    4132:	c2 4f 29 00 	mov.b	r15,	&0x0029	
}
    4136:	34 41       	pop	r4		
    4138:	30 41       	ret			

0000413a <SEND_CHAR>:

void SEND_CHAR(unsigned char d) {
    413a:	04 12       	push	r4		
    413c:	21 82       	sub	#4,	r1	;r2 As==10
    413e:	04 41       	mov	r1,	r4	
    4140:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
	int temp;
	Delayx100us(5); //.5ms
    4144:	3e 40 05 00 	mov	#5,	r14	;#0x0005
    4148:	0f 43       	clr	r15		
    414a:	b0 12 d2 40 	call	#0x40d2	
	temp = d & 0xf0; //get upper nibble
    414e:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    4152:	0e 4f       	mov	r15,	r14	
    4154:	3e f0 f0 00 	and	#240,	r14	;#0x00f0
    4158:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    415c:	5f 42 29 00 	mov.b	&0x0029,r15	
    4160:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    4164:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    4168:	2f 44       	mov	@r4,	r15	
    416a:	4e 4f       	mov.b	r15,	r14	
    416c:	5f 42 29 00 	mov.b	&0x0029,r15	
    4170:	4f de       	bis.b	r14,	r15	
    4172:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitset(P2OUT, RS);
    4176:	5f 42 29 00 	mov.b	&0x0029,r15	
    417a:	6f d2       	bis.b	#4,	r15	;r2 As==10
    417c:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to data mode
	_E(); //toggle E for LCD
    4180:	b0 12 14 41 	call	#0x4114	
	temp = d & 0x0f;
    4184:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    4188:	0e 4f       	mov	r15,	r14	
    418a:	3e f0 0f 00 	and	#15,	r14	;#0x000f
    418e:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	temp = temp << 4; //get down nibble
    4192:	2f 44       	mov	@r4,	r15	
    4194:	0f 5f       	rla	r15		
    4196:	0f 5f       	rla	r15		
    4198:	0f 5f       	rla	r15		
    419a:	0f 5f       	rla	r15		
    419c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    41a0:	5f 42 29 00 	mov.b	&0x0029,r15	
    41a4:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    41a8:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    41ac:	2f 44       	mov	@r4,	r15	
    41ae:	4e 4f       	mov.b	r15,	r14	
    41b0:	5f 42 29 00 	mov.b	&0x0029,r15	
    41b4:	4f de       	bis.b	r14,	r15	
    41b6:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitset(P2OUT, RS);
    41ba:	5f 42 29 00 	mov.b	&0x0029,r15	
    41be:	6f d2       	bis.b	#4,	r15	;r2 As==10
    41c0:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to data mode
	_E(); //toggle E for LCD
    41c4:	b0 12 14 41 	call	#0x4114	
}
    41c8:	21 52       	add	#4,	r1	;r2 As==10
    41ca:	34 41       	pop	r4		
    41cc:	30 41       	ret			

000041ce <SEND_CMD>:

void SEND_CMD(unsigned char e) {
    41ce:	04 12       	push	r4		
    41d0:	21 82       	sub	#4,	r1	;r2 As==10
    41d2:	04 41       	mov	r1,	r4	
    41d4:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
	int temp;
	Delayx100us(10); //10ms
    41d8:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    41dc:	0f 43       	clr	r15		
    41de:	b0 12 d2 40 	call	#0x40d2	
	temp = e & 0xf0; //get upper nibble
    41e2:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    41e6:	0e 4f       	mov	r15,	r14	
    41e8:	3e f0 f0 00 	and	#240,	r14	;#0x00f0
    41ec:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    41f0:	5f 42 29 00 	mov.b	&0x0029,r15	
    41f4:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    41f8:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp; //send CMD to LCD
    41fc:	2f 44       	mov	@r4,	r15	
    41fe:	4e 4f       	mov.b	r15,	r14	
    4200:	5f 42 29 00 	mov.b	&0x0029,r15	
    4204:	4f de       	bis.b	r14,	r15	
    4206:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitclr(P2OUT, RS);
    420a:	5f 42 29 00 	mov.b	&0x0029,r15	
    420e:	6f c2       	bic.b	#4,	r15	;r2 As==10
    4210:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to CMD mode
	_E(); //toggle E for LCD
    4214:	b0 12 14 41 	call	#0x4114	
	temp = e & 0x0f;
    4218:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    421c:	0e 4f       	mov	r15,	r14	
    421e:	3e f0 0f 00 	and	#15,	r14	;#0x000f
    4222:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	temp = temp << 4; //get down nibble
    4226:	2f 44       	mov	@r4,	r15	
    4228:	0f 5f       	rla	r15		
    422a:	0f 5f       	rla	r15		
    422c:	0f 5f       	rla	r15		
    422e:	0f 5f       	rla	r15		
    4230:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    4234:	5f 42 29 00 	mov.b	&0x0029,r15	
    4238:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    423c:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    4240:	2f 44       	mov	@r4,	r15	
    4242:	4e 4f       	mov.b	r15,	r14	
    4244:	5f 42 29 00 	mov.b	&0x0029,r15	
    4248:	4f de       	bis.b	r14,	r15	
    424a:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitclr(P2OUT, RS);
    424e:	5f 42 29 00 	mov.b	&0x0029,r15	
    4252:	6f c2       	bic.b	#4,	r15	;r2 As==10
    4254:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to CMD mode
	_E(); //toggle E for LCD
    4258:	b0 12 14 41 	call	#0x4114	
}
    425c:	21 52       	add	#4,	r1	;r2 As==10
    425e:	34 41       	pop	r4		
    4260:	30 41       	ret			

00004262 <InitLCD>:

void InitLCD(void) {
    4262:	04 12       	push	r4		
    4264:	04 41       	mov	r1,	r4	
	bitclr(P2OUT, RS);
    4266:	5f 42 29 00 	mov.b	&0x0029,r15	
    426a:	6f c2       	bic.b	#4,	r15	;r2 As==10
    426c:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	Delayx100us(250); //Delay 100ms
    4270:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4274:	0f 43       	clr	r15		
    4276:	b0 12 d2 40 	call	#0x40d2	
	Delayx100us(250);
    427a:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    427e:	0f 43       	clr	r15		
    4280:	b0 12 d2 40 	call	#0x40d2	
	Delayx100us(250);
    4284:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4288:	0f 43       	clr	r15		
    428a:	b0 12 d2 40 	call	#0x40d2	
	Delayx100us(250);
    428e:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4292:	0f 43       	clr	r15		
    4294:	b0 12 d2 40 	call	#0x40d2	
	LCD_Data |= BIT4 | BIT5; //D7-D4 = 0011
    4298:	5f 42 29 00 	mov.b	&0x0029,r15	
    429c:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    42a0:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data &= ~BIT6 & ~BIT7;
    42a4:	5f 42 29 00 	mov.b	&0x0029,r15	
    42a8:	7f f0 3f 00 	and.b	#63,	r15	;#0x003f
    42ac:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	_E(); //toggle E for LCD
    42b0:	b0 12 14 41 	call	#0x4114	
	Delayx100us(100); //10ms
    42b4:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    42b8:	0f 43       	clr	r15		
    42ba:	b0 12 d2 40 	call	#0x40d2	
	_E(); //toggle E for LCD
    42be:	b0 12 14 41 	call	#0x4114	
	Delayx100us(100); //10ms
    42c2:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    42c6:	0f 43       	clr	r15		
    42c8:	b0 12 d2 40 	call	#0x40d2	
	_E(); //toggle E for LCD
    42cc:	b0 12 14 41 	call	#0x4114	
	Delayx100us(100); //10ms
    42d0:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    42d4:	0f 43       	clr	r15		
    42d6:	b0 12 d2 40 	call	#0x40d2	
	LCD_Data &= ~BIT4;
    42da:	5f 42 29 00 	mov.b	&0x0029,r15	
    42de:	7f f0 ef ff 	and.b	#-17,	r15	;#0xffef
    42e2:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	_E(); //toggle E for LCD
    42e6:	b0 12 14 41 	call	#0x4114	

	SEND_CMD(DISP_ON);
    42ea:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    42ee:	b0 12 ce 41 	call	#0x41ce	
	SEND_CMD(CLR_DISP);
    42f2:	5f 43       	mov.b	#1,	r15	;r3 As==01
    42f4:	b0 12 ce 41 	call	#0x41ce	
	Delayx100us(250);
    42f8:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    42fc:	0f 43       	clr	r15		
    42fe:	b0 12 d2 40 	call	#0x40d2	
	Delayx100us(250);
    4302:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4306:	0f 43       	clr	r15		
    4308:	b0 12 d2 40 	call	#0x40d2	
	Delayx100us(250);
    430c:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4310:	0f 43       	clr	r15		
    4312:	b0 12 d2 40 	call	#0x40d2	
	Delayx100us(250);
    4316:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    431a:	0f 43       	clr	r15		
    431c:	b0 12 d2 40 	call	#0x40d2	
}
    4320:	34 41       	pop	r4		
    4322:	30 41       	ret			

00004324 <ServiceOutput>:
INT8S setVolume(INT8U cmd, INT8U nb);

// Helpers
INT8S sendOverSPI(INT8U target, INT16U data, INT8U nbits);

void ServiceOutput(void *parg) {
    4324:	04 12       	push	r4		
    4326:	31 82       	sub	#8,	r1	;r2 As==11
    4328:	04 41       	mov	r1,	r4	
    432a:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)

		OS_EVENT *msgQServiceOutput = (OS_EVENT*) parg;
    432e:	94 44 06 00 	mov	6(r4),	2(r4)	;0x0006(r4), 0x0002(r4)
    4332:	02 00 
		INT8U err;
		ServiceMsg* data;

		for (;;) {

			data = (ServiceMsg*) OSQPend (msgQServiceOutput, 0, &err);
    4334:	0e 44       	mov	r4,	r14	
    4336:	2e 52       	add	#4,	r14	;r2 As==10
    4338:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    433c:	0d 4e       	mov	r14,	r13	
    433e:	0e 43       	clr	r14		
    4340:	b0 12 e2 2d 	call	#0x2de2	
    4344:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)

			switch(data->serviceType) {
    4348:	2f 44       	mov	@r4,	r15	
    434a:	2f 4f       	mov	@r15,	r15	
    434c:	2f 93       	cmp	#2,	r15	;r3 As==10
    434e:	10 24       	jz	$+34     	;abs 0x4370
    4350:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4354:	05 2c       	jc	$+12     	;abs 0x4360
    4356:	0f 93       	tst	r15		
    4358:	09 24       	jz	$+20     	;abs 0x436c
    435a:	1f 93       	cmp	#1,	r15	;r3 As==01
    435c:	08 24       	jz	$+18     	;abs 0x436e
    435e:	ea 3f       	jmp	$-42     	;abs 0x4334
    4360:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4364:	0b 24       	jz	$+24     	;abs 0x437c
    4366:	2f 92       	cmp	#4,	r15	;r2 As==10
    4368:	11 24       	jz	$+36     	;abs 0x438c
    436a:	e4 3f       	jmp	$-54     	;abs 0x4334
				break;
			default:
				// Error
				break;
			}
		}
    436c:	18 3c       	jmp	$+50     	;abs 0x439e

			data = (ServiceMsg*) OSQPend (msgQServiceOutput, 0, &err);

			switch(data->serviceType) {
			case SERV_BARGRAPH:
				break;
    436e:	17 3c       	jmp	$+48     	;abs 0x439e
			case SERV_EEPROM:
				break;
			case SERV_FREQ:
				setFrequency(data->val);
    4370:	2f 44       	mov	@r4,	r15	
    4372:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    4376:	b0 12 a0 43 	call	#0x43a0	
    437a:	11 3c       	jmp	$+36     	;abs 0x439e
				break;
			case SERV_LCD:
				clearDisplay();
    437c:	b0 12 da 3c 	call	#0x3cda	
				// Parse string '\n' gotoSecondLine() TODO
				printDecimal(data->val);
    4380:	2f 44       	mov	@r4,	r15	
    4382:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    4386:	b0 12 2e 3e 	call	#0x3e2e	
    438a:	09 3c       	jmp	$+20     	;abs 0x439e
				//printString(data->msg.pBuffer);
				break;
			case SERV_VOLUME:
				setVolume(VOLUME_CMD, data->val);
    438c:	2f 44       	mov	@r4,	r15	
    438e:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    4392:	4e 4f       	mov.b	r15,	r14	
    4394:	7f 40 1f 00 	mov.b	#31,	r15	;#0x001f
    4398:	b0 12 f4 43 	call	#0x43f4	
    439c:	cb 3f       	jmp	$-104    	;abs 0x4334
				break;
			default:
				// Error
				break;
			}
		}
    439e:	ca 3f       	jmp	$-106    	;abs 0x4334

000043a0 <setFrequency>:

}

INT8S setFrequency(INT16U nb) {
    43a0:	04 12       	push	r4		
    43a2:	21 82       	sub	#4,	r1	;r2 As==10
    43a4:	04 41       	mov	r1,	r4	
    43a6:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)

	if(nb>1023) {
    43aa:	b4 90 00 04 	cmp	#1024,	2(r4)	;#0x0400, 0x0002(r4)
    43ae:	02 00 
    43b0:	02 28       	jnc	$+6      	;abs 0x43b6
		return -1;
    43b2:	7f 43       	mov.b	#-1,	r15	;r3 As==11
    43b4:	1c 3c       	jmp	$+58     	;abs 0x43ee
	}

	INT16U data = (nb << 2) & 0x0fff; // "create" dummy bits and select lowest 12 bits
    43b6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    43ba:	0f 5f       	rla	r15		
    43bc:	0f 5f       	rla	r15		
    43be:	0e 4f       	mov	r15,	r14	
    43c0:	3e f0 ff 0f 	and	#4095,	r14	;#0x0fff
    43c4:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)

	clearDisplay();
    43c8:	b0 12 da 3c 	call	#0x3cda	
	printDecimal(nb);
    43cc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    43d0:	b0 12 2e 3e 	call	#0x3e2e	
	gotoSecondLine();
    43d4:	b0 12 f2 3c 	call	#0x3cf2	
	printHex(data);
    43d8:	2f 44       	mov	@r4,	r15	
    43da:	b0 12 9e 3d 	call	#0x3d9e	
	sendOverSPI(SPI_FREQ, data, 12);
    43de:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    43e2:	4d 4f       	mov.b	r15,	r13	
    43e4:	2e 44       	mov	@r4,	r14	
    43e6:	4f 43       	clr.b	r15		
    43e8:	b0 12 2a 44 	call	#0x442a	

	return 0;
    43ec:	4f 43       	clr.b	r15		
}
    43ee:	21 52       	add	#4,	r1	;r2 As==10
    43f0:	34 41       	pop	r4		
    43f2:	30 41       	ret			

000043f4 <setVolume>:

INT8S setVolume(INT8U cmd, INT8U nb) {
    43f4:	04 12       	push	r4		
    43f6:	21 82       	sub	#4,	r1	;r2 As==10
    43f8:	04 41       	mov	r1,	r4	
    43fa:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
    43fe:	c4 4e 03 00 	mov.b	r14,	3(r4)	;0x0003(r4)

	INT16U data = (cmd << 8) | nb;
    4402:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    4406:	7f f3       	and.b	#-1,	r15	;r3 As==11
    4408:	8f 10       	swpb	r15		
    440a:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    440e:	0f de       	bis	r14,	r15	
    4410:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	// Send command & data
	sendOverSPI(SPI_VOL, data, 16);
    4414:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    4418:	5f 43       	mov.b	#1,	r15	;r3 As==01
    441a:	4d 4e       	mov.b	r14,	r13	
    441c:	2e 44       	mov	@r4,	r14	
    441e:	b0 12 2a 44 	call	#0x442a	

	return 0;
    4422:	4f 43       	clr.b	r15		
}
    4424:	21 52       	add	#4,	r1	;r2 As==10
    4426:	34 41       	pop	r4		
    4428:	30 41       	ret			

0000442a <sendOverSPI>:
/////////////////////////////////////////////////////////////////
// HELPERS /////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

// nbits=[1,15], nbits de poids faible
INT8S sendOverSPI(INT8U target, INT16U data, INT8U nbits) {
    442a:	04 12       	push	r4		
    442c:	31 82       	sub	#8,	r1	;r2 As==11
    442e:	04 41       	mov	r1,	r4	
    4430:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
    4434:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    4438:	c4 4d 06 00 	mov.b	r13,	6(r4)	;0x0006(r4)
	// Select SPI path
	if (target == SPI_FREQ) {
    443c:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    4440:	07 20       	jnz	$+16     	;abs 0x4450
		SEL_OFF;
    4442:	5f 42 35 00 	mov.b	&0x0035,r15	
    4446:	7f f0 7f 00 	and.b	#127,	r15	;#0x007f
    444a:	c2 4f 35 00 	mov.b	r15,	&0x0035	
    444e:	0c 3c       	jmp	$+26     	;abs 0x4468
	} else if(target == SPI_VOL) {
    4450:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    4454:	07 20       	jnz	$+16     	;abs 0x4464
		SEL_ON;
    4456:	5f 42 35 00 	mov.b	&0x0035,r15	
    445a:	7f d0 80 ff 	bis.b	#-128,	r15	;#0xff80
    445e:	c2 4f 35 00 	mov.b	r15,	&0x0035	
    4462:	02 3c       	jmp	$+6      	;abs 0x4468
	} else {
		return -1;
    4464:	7f 43       	mov.b	#-1,	r15	;r3 As==11
    4466:	57 3c       	jmp	$+176    	;abs 0x4516
	}

	// Three state gate : disable and re-enable output
	CS_ON;
    4468:	5f 42 35 00 	mov.b	&0x0035,r15	
    446c:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    4470:	c2 4f 35 00 	mov.b	r15,	&0x0035	
	Delayx100us(1);
    4474:	1e 43       	mov	#1,	r14	;r3 As==01
    4476:	0f 43       	clr	r15		
    4478:	b0 12 d2 40 	call	#0x40d2	
	CS_OFF;
    447c:	5f 42 35 00 	mov.b	&0x0035,r15	
    4480:	7f f0 bf ff 	and.b	#-65,	r15	;#0xffbf
    4484:	c2 4f 35 00 	mov.b	r15,	&0x0035	

	INT8U currentBit;
	INT8U k = nbits;
    4488:	d4 44 06 00 	mov.b	6(r4),	0(r4)	;0x0006(r4), 0x0000(r4)
    448c:	00 00 
    448e:	39 3c       	jmp	$+116    	;abs 0x4502
	while (k > 0)
	{
		currentBit = (data >> (k-1)) & 0x1;
    4490:	6f 44       	mov.b	@r4,	r15	
    4492:	0e 4f       	mov	r15,	r14	
    4494:	3e 53       	add	#-1,	r14	;r3 As==11
    4496:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    449a:	0e 93       	tst	r14		
    449c:	04 24       	jz	$+10     	;abs 0x44a6
    449e:	12 c3       	clrc			
    44a0:	0f 10       	rrc	r15		
    44a2:	1e 83       	dec	r14		
    44a4:	fc 23       	jnz	$-6      	;abs 0x449e
    44a6:	4e 4f       	mov.b	r15,	r14	
    44a8:	5e f3       	and.b	#1,	r14	;r3 As==01
    44aa:	c4 4e 01 00 	mov.b	r14,	1(r4)	;0x0001(r4)
		if (currentBit)
    44ae:	c4 93 01 00 	tst.b	1(r4)		;0x0001(r4)
    44b2:	13 24       	jz	$+40     	;abs 0x44da
		{
			// currentBit = 1
			P6OUT |=0x10;	// DIN=1 	SCLK=0	 CS=0
    44b4:	5f 42 35 00 	mov.b	&0x0035,r15	
    44b8:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    44bc:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT |=0x20;	// SCLK=1
    44c0:	5f 42 35 00 	mov.b	&0x0035,r15	
    44c4:	7f d0 20 00 	bis.b	#32,	r15	;#0x0020
    44c8:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT &=~0x20;	// SCLK=0
    44cc:	5f 42 35 00 	mov.b	&0x0035,r15	
    44d0:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    44d4:	c2 4f 35 00 	mov.b	r15,	&0x0035	
    44d8:	12 3c       	jmp	$+38     	;abs 0x44fe
		}
		else
		{
			// currentBit = 0
			P6OUT &=~0x70;	// DIN=0 	SCLK=0	 CS=0
    44da:	5f 42 35 00 	mov.b	&0x0035,r15	
    44de:	7f f0 8f ff 	and.b	#-113,	r15	;#0xff8f
    44e2:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT |=0x20;	// SCLK=1
    44e6:	5f 42 35 00 	mov.b	&0x0035,r15	
    44ea:	7f d0 20 00 	bis.b	#32,	r15	;#0x0020
    44ee:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT &=~0x20;	// SCLK=0
    44f2:	5f 42 35 00 	mov.b	&0x0035,r15	
    44f6:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    44fa:	c2 4f 35 00 	mov.b	r15,	&0x0035	
		}
		--k;
    44fe:	f4 53 00 00 	add.b	#-1,	0(r4)	;r3 As==11, 0x0000(r4)
	Delayx100us(1);
	CS_OFF;

	INT8U currentBit;
	INT8U k = nbits;
	while (k > 0)
    4502:	c4 93 00 00 	tst.b	0(r4)		;0x0000(r4)
    4506:	c4 23       	jnz	$-118    	;abs 0x4490
		}
		--k;
	}

	// Three state gate : disable output
	CS_ON;
    4508:	5f 42 35 00 	mov.b	&0x0035,r15	
    450c:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    4510:	c2 4f 35 00 	mov.b	r15,	&0x0035	
		SEL_ON;
	} else if(target == SPI_VOL) {
		SEL_OFF;
	}*/

	return 0;
    4514:	4f 43       	clr.b	r15		
}
    4516:	31 52       	add	#8,	r1	;r2 As==11
    4518:	34 41       	pop	r4		
    451a:	30 41       	ret			

0000451c <ModeStep>:
//} //----- fin de nom

//////////////////////////////////////////////////////////////////  PUBLIC
//---------------------------------------------------- Fonctions publiques

void ModeStep(INT16U event) {
    451c:	04 12       	push	r4		
    451e:	21 83       	decd	r1		
    4520:	04 41       	mov	r1,	r4	
    4522:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	switch (mode) {
    4526:	1f 42 02 02 	mov	&0x0202,r15	
    452a:	2f 93       	cmp	#2,	r15	;r3 As==10
    452c:	20 24       	jz	$+66     	;abs 0x456e
    452e:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4532:	05 2c       	jc	$+12     	;abs 0x453e
    4534:	0f 93       	tst	r15		
    4536:	09 24       	jz	$+20     	;abs 0x454a
    4538:	1f 93       	cmp	#1,	r15	;r3 As==01
    453a:	13 24       	jz	$+40     	;abs 0x4562
    453c:	33 3c       	jmp	$+104    	;abs 0x45a4
    453e:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4542:	1c 24       	jz	$+58     	;abs 0x457c
    4544:	2f 92       	cmp	#4,	r15	;r2 As==10
    4546:	21 24       	jz	$+68     	;abs 0x458a
    4548:	2d 3c       	jmp	$+92     	;abs 0x45a4
	case VEILLE:
		if(event == CMD0) {
    454a:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    454e:	03 20       	jnz	$+8      	;abs 0x4556
			mode = MR_INIT;
    4550:	92 43 02 02 	mov	#1,	&0x0202	;r3 As==01
    4554:	27 3c       	jmp	$+80     	;abs 0x45a4
		} else if (event == CMD1) {
    4556:	94 93 00 00 	cmp	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    455a:	1d 20       	jnz	$+60     	;abs 0x4596
			mode = MS;
    455c:	a2 42 02 02 	mov	#4,	&0x0202	;r2 As==10
    4560:	21 3c       	jmp	$+68     	;abs 0x45a4
		}
		break;
	case MR_INIT:
		if(event == MR_INIT_ACK) {
    4562:	a4 92 00 00 	cmp	#4,	0(r4)	;r2 As==10, 0x0000(r4)
    4566:	19 20       	jnz	$+52     	;abs 0x459a
			mode = MR;
    4568:	a2 43 02 02 	mov	#2,	&0x0202	;r3 As==10
    456c:	1b 3c       	jmp	$+56     	;abs 0x45a4
		}
		break;
	case MR:
		if(event == CMD0) {
    456e:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    4572:	15 20       	jnz	$+44     	;abs 0x459e
			mode = MR_FIN;
    4574:	b2 40 03 00 	mov	#3,	&0x0202	;#0x0003
    4578:	02 02 
    457a:	14 3c       	jmp	$+42     	;abs 0x45a4
		}
		break;
	case MR_FIN:
		if(event == MR_FIN_ACK) {
    457c:	b4 90 05 00 	cmp	#5,	0(r4)	;#0x0005, 0x0000(r4)
    4580:	00 00 
    4582:	0f 20       	jnz	$+32     	;abs 0x45a2
			mode = VEILLE;
    4584:	82 43 02 02 	mov	#0,	&0x0202	;r3 As==00
    4588:	0d 3c       	jmp	$+28     	;abs 0x45a4
		}
		break;
	case MS:
		if(event == CMD1) {
    458a:	94 93 00 00 	cmp	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    458e:	0a 20       	jnz	$+22     	;abs 0x45a4
			mode = VEILLE;
    4590:	82 43 02 02 	mov	#0,	&0x0202	;r3 As==00
    4594:	07 3c       	jmp	$+16     	;abs 0x45a4
		if(event == CMD0) {
			mode = MR_INIT;
		} else if (event == CMD1) {
			mode = MS;
		}
		break;
    4596:	03 43       	nop			
    4598:	05 3c       	jmp	$+12     	;abs 0x45a4
	case MR_INIT:
		if(event == MR_INIT_ACK) {
			mode = MR;
		}
		break;
    459a:	03 43       	nop			
    459c:	03 3c       	jmp	$+8      	;abs 0x45a4
	case MR:
		if(event == CMD0) {
			mode = MR_FIN;
		}
		break;
    459e:	03 43       	nop			
    45a0:	01 3c       	jmp	$+4      	;abs 0x45a4
	case MR_FIN:
		if(event == MR_FIN_ACK) {
			mode = VEILLE;
		}
		break;
    45a2:	03 43       	nop			
		}
		break;
	default:
		break;
	}
}
    45a4:	21 53       	incd	r1		
    45a6:	34 41       	pop	r4		
    45a8:	30 41       	ret			

000045aa <GestionMode>:


void GestionMode(void *parg) {
    45aa:	04 12       	push	r4		
    45ac:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    45b0:	04 41       	mov	r1,	r4	
    45b2:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)

		OS_EVENT *msgQServiceOutput = (OS_EVENT*) parg;
    45b6:	94 44 0a 00 	mov	10(r4),	2(r4)	;0x000a(r4), 0x0002(r4)
    45ba:	02 00 
		INT8U err;
		ServiceMsg data;

		for(;;) {

			data.serviceType = SERV_LCD;
    45bc:	b4 40 03 00 	mov	#3,	4(r4)	;#0x0003, 0x0004(r4)
    45c0:	04 00 
			data.val = 33;
    45c2:	b4 40 21 00 	mov	#33,	6(r4)	;#0x0021, 0x0006(r4)
    45c6:	06 00 

			err = OSQPost (msgQServiceOutput, (void *)&data);
    45c8:	0e 44       	mov	r4,	r14	
    45ca:	2e 52       	add	#4,	r14	;r2 As==10
    45cc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    45d0:	b0 12 34 2f 	call	#0x2f34	
    45d4:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
			STATUS_LED_ON;
    45d8:	5f 42 29 00 	mov.b	&0x0029,r15	
    45dc:	6f c3       	bic.b	#2,	r15	;r3 As==10
    45de:	c2 4f 29 00 	mov.b	r15,	&0x0029	
			OSTimeDly(2*OS_TICKS_PER_SEC);
    45e2:	3f 40 c8 00 	mov	#200,	r15	;#0x00c8
    45e6:	b0 12 8e 3a 	call	#0x3a8e	
			STATUS_LED_OFF;
    45ea:	5f 42 29 00 	mov.b	&0x0029,r15	
    45ee:	6f d3       	bis.b	#2,	r15	;r3 As==10
    45f0:	c2 4f 29 00 	mov.b	r15,	&0x0029	
    45f4:	e3 3f       	jmp	$-56     	;abs 0x45bc

000045f6 <_unexpected_>:
    45f6:	00 13       	reti			

000045f8 <__udivmodsi4>:
    45f8:	0f ef       	xor	r15,	r15	
    45fa:	0e ee       	xor	r14,	r14	
    45fc:	39 40 21 00 	mov	#33,	r9	;#0x0021
    4600:	0a 3c       	jmp	$+22     	;abs 0x4616
    4602:	08 10       	rrc	r8		
    4604:	0e 6e       	rlc	r14		
    4606:	0f 6f       	rlc	r15		
    4608:	0f 9b       	cmp	r11,	r15	
    460a:	05 28       	jnc	$+12     	;abs 0x4616
    460c:	02 20       	jnz	$+6      	;abs 0x4612
    460e:	0e 9a       	cmp	r10,	r14	
    4610:	02 28       	jnc	$+6      	;abs 0x4616
    4612:	0e 8a       	sub	r10,	r14	
    4614:	0f 7b       	subc	r11,	r15	
    4616:	0c 6c       	rlc	r12		
    4618:	0d 6d       	rlc	r13		
    461a:	08 68       	rlc	r8		
    461c:	19 83       	dec	r9		
    461e:	f1 23       	jnz	$-28     	;abs 0x4602
    4620:	30 41       	ret			

00004622 <__divmodsi4>:
    4622:	08 43       	clr	r8		
    4624:	3d b0 00 80 	bit	#-32768,r13	;#0x8000
    4628:	05 24       	jz	$+12     	;abs 0x4634
    462a:	3d e3       	inv	r13		
    462c:	3c e3       	inv	r12		
    462e:	1c 53       	inc	r12		
    4630:	0d 63       	adc	r13		
    4632:	28 d2       	bis	#4,	r8	;r2 As==10
    4634:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    4638:	05 24       	jz	$+12     	;abs 0x4644
    463a:	3b e3       	inv	r11		
    463c:	3a e3       	inv	r10		
    463e:	1a 53       	inc	r10		
    4640:	0b 63       	adc	r11		
    4642:	38 d2       	bis	#8,	r8	;r2 As==11
    4644:	b0 12 f8 45 	call	#0x45f8	
    4648:	08 10       	rrc	r8		
    464a:	28 b2       	bit	#4,	r8	;r2 As==10
    464c:	08 24       	jz	$+18     	;abs 0x465e
    464e:	3e e3       	inv	r14		
    4650:	3f e3       	inv	r15		
    4652:	1e 53       	inc	r14		
    4654:	0f 63       	adc	r15		
    4656:	3c e3       	inv	r12		
    4658:	3d e3       	inv	r13		
    465a:	1c 53       	inc	r12		
    465c:	0d 63       	adc	r13		
    465e:	38 b2       	bit	#8,	r8	;r2 As==11
    4660:	04 24       	jz	$+10     	;abs 0x466a
    4662:	3c e3       	inv	r12		
    4664:	3d e3       	inv	r13		
    4666:	1c 53       	inc	r12		
    4668:	0d 63       	adc	r13		
    466a:	30 41       	ret			

0000466c <__stop_progExec__>:
    466c:	ff 3f       	jmp	$+0      	;abs 0x466c

Disassembly of section .vectors:

0000ffe0 <InterruptVectors>:
    ffe0:	30 11 ee 12 30 11 30 11 4c 12 30 11 b0 13 30 11     0...0.0.L.0...0.
    fff0:	30 11 30 11 30 11 30 11 30 11 30 11 30 11 00 11     0.0.0.0.0.0.0...
