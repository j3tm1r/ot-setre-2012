
exe/main.elf:     file format elf32-msp430

SYMBOL TABLE:
00001100 l    d  .text	00000000 .text
00000200 l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
0000012e l       *ABS*	00000000 TA0IV
00000160 l       *ABS*	00000000 TA0CTL
00000170 l       *ABS*	00000000 TA0R
00000162 l       *ABS*	00000000 TA0CCTL0
00000164 l       *ABS*	00000000 TA0CCTL1
00000172 l       *ABS*	00000000 TA0CCR0
00000174 l       *ABS*	00000000 TA0CCR1
00000166 l       *ABS*	00000000 TA0CCTL2
00000176 l       *ABS*	00000000 TA0CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000190 l       *ABS*	00000000 TBR
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000004 l       *ABS*	00000000 ME1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000005 l       *ABS*	00000000 ME2
00000002 l       *ABS*	00000000 PUSH_BYTES
00001130 l       .text	00000000 _branch_to_unexpected_
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 main.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
0000012e l       *ABS*	00000000 TA0IV
00000160 l       *ABS*	00000000 TA0CTL
00000170 l       *ABS*	00000000 TA0R
00000162 l       *ABS*	00000000 TA0CCTL0
00000164 l       *ABS*	00000000 TA0CCTL1
00000172 l       *ABS*	00000000 TA0CCR0
00000174 l       *ABS*	00000000 TA0CCR1
00000166 l       *ABS*	00000000 TA0CCTL2
00000176 l       *ABS*	00000000 TA0CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000190 l       *ABS*	00000000 TBR
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000004 l       *ABS*	00000000 ME1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000005 l       *ABS*	00000000 ME2
00001364 l       .text	00000000 TA0_ISR
00001394 l       .text	00000000 L1
000013b0 l       .text	00000000 L2
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_core.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001bf2 l     F .text	00000028 OS_InitMisc
00001c1a l     F .text	00000040 OS_InitRdyList
00001c8e l     F .text	0000006a OS_InitTCBList
00001b8c l     F .text	00000066 OS_InitEventList
00001c5a l     F .text	00000034 OS_InitTaskIdle
00000000 l    df *ABS*	00000000 os_flag.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
000025e4 l     F .text	000000fa OS_FlagBlock
00002748 l     F .text	000000a8 OS_FlagTaskRdy
00000000 l    df *ABS*	00000000 os_mbox.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_mem.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_mutex.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_q.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_sem.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_task.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_time.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Display.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 g       *ABS*	00000000 __data_size
000013e4 g     F .text	00000010 OSTaskCreateHook
00003f5a g     F .text	00000084 InitOsc
00001648 g     F .text	00000022 OSIntEnter
0000140c g     F .text	00000008 OSTaskStatHook
00000304 g     O .bss	00000001 OSLockNesting
00000305 g     O .bss	00000001 OSRunning
000040dc g     F .text	00000094 SEND_CHAR
00003ca4 g     F .text	00000026 printString
000013d4 g     F .text	00000008 OSInitHookBegin
00000306 g     O .bss	00000004 OSIdleCtr
00001e3c g     F .text	000001f0 OS_TCBInit
0000030a g     O .bss	00000001 OSPrioHighRdy
000013f4 g     F .text	00000010 OSTaskDelHook
0000433e g       .text	00000000 _etext
00003c7c g     F .text	00000018 clearDisplay
000012b6 g     F .text	00000000 OSStartHighRdy
000037c0 g     F .text	0000010a OSTaskCreateExt
00002416 g     F .text	0000002c OSFlagPendGetFlagsRdy
0000202c g     F .text	0000012a OSFlagAccept
00002d28 g     F .text	0000005c OSQFlush
00002b62 g     F .text	000000c4 OSQAccept
000036e4 g     F .text	000000dc OSTaskCreate
000034a2 g     F .text	00000242 OSTaskChangePrio
000003ea g       *ABS*	00000000 __bss_size
0000030c g     O .bss	00000012 OSFlagTbl
0000433c  w      .text	00000000 __stop_progExec__
00001130  w      .text	00000000 vector_ffe0
000040b6 g     F .text	00000026 _E
0000166a g     F .text	000000c2 OSIntExit
0000031e g     O .bss	00000001 OSPrioCur
00003dd0 g     F .text	0000018a printDecimal
000012e2 g       .text	00000000 OSCtxSw
00003cf0 g     F .text	00000050 printByte
00000320 g     O .bss	00000002 OSTCBList
00000322 g     O .bss	00000001 OSTickStepState
00002ed6 g     F .text	000000dc OSQPost
000027f0 g     F .text	00000068 OS_FlagUnlink
00001d22 g     F .text	0000003c OS_MemCopy
00001d5e g     F .text	000000a8 OS_Sched
00000324 g     O .bss	00000004 OSCtxSwCtr
00001364 g       .text	00000000 vector_ffec
0000150c g     F .text	00000008 OSTimeTickHook
00001130  w      .text	00000000 vector_fff0
0000433e g       *ABS*	00000000 __data_load_start
00003324 g     F .text	000000f6 OSSemPend
00001514 g     O .text	00000008 OSMapTbl
00001130 g       .text	00000000 __dtors_end
00001130  w      .text	00000000 vector_fffc
000014fc g     F .text	00000010 OSTCBInitHook
00002a32 g     F .text	00000084 OSMboxPost
000026de g     F .text	0000006a OS_FlagInit
00001130  w      .text	00000000 vector_ffe4
0000324c g     F .text	0000005e OSSemAccept
00001334 g       .text	00000000 OSIntCtxSw
00003cca g     F .text	00000026 HexDigit
00000328 g     O .bss	00000002 OSTCBFreeList
0000ffe0 g     O .vectors	00000020 InterruptVectors
00004074 g     F .text	00000042 Delayx100us
0000111c  w      .text	00000000 __do_clear_bss
00001cf8 g     F .text	0000002a OS_MemClr
00001414 g     F .text	000000e0 OSTaskStkInit
000018d0 g     F .text	00000142 OS_EventTaskRdy
00002d84 g     F .text	00000152 OSQPend
00004170 g     F .text	00000094 SEND_CMD
00003a30 g     F .text	00000084 OSTimeDly
0000032a g     O .bss	00000001 OSTaskCtr
00003ab4 g     F .text	0000019a OSTimeDlyHMSM
00001130  w      .text	00000000 vector_ffe2
0000341a g     F .text	00000088 OSSemPost
00001130  w      .text	00000000 vector_ffe8
000042c6  w      .text	00000000 _unexpected_
00001130  w      .text	00000000 vector_fffa
00004204 g     F .text	000000c2 InitLCD
0000032c g     O .bss	0000001c OSQTbl
00001100  w      .text	00000000 _reset_vector__
00001130 g       .text	00000000 __ctors_start
00000348 g     O .bss	00000002 OSTCBHighRdy
0000034a g     O .bss	00000002 OSQFreeList
0000110a  w      .text	00000000 __do_copy_data
0000034c g     O .bss	00000001 OSRdyGrp
00000200 g       .bss	00000000 __bss_start
00001130  w      .text	00000000 vector_ffee
00001130  w      .text	00000000 vector_fff4
00001138 g     F .text	000000da main
00001130  w      .text	00000000 vector_fff8
0000151c g     O .text	00000100 OSUnMapTbl
00000200 g     O .bss	00000002 global_pb_gd
00001130  w      .text	00000000 vector_fff2
00002442 g     F .text	000001a2 OSFlagPost
00003c4e g     F .text	00000018 initDisplay
00001a12 g     F .text	000000b0 OS_EventTaskWait
0000172c g     F .text	00000066 OSStart
00002fb2 g     F .text	000000e4 OSQPostFront
00003c66 g     F .text	00000016 putc
0000034e g     O .bss	00000002 OSRdyTbl
00010000 g       .vectors	00000000 _vectors_end
00002c26 g     F .text	00000102 OSQCreate
00003096 g     F .text	0000015c OSQPostOpt
00001792 g     F .text	00000132 OSTimeTick
00001130  w      .text	00000000 vector_ffe6
000032aa g     F .text	0000007a OSSemCreate
00003fde g     F .text	00000056 InitPorts
00002156 g     F .text	0000008e OSFlagCreate
00000350 g     O .bss	00000002 OSEventFreeList
00003d40 g     F .text	00000090 printHex
00001100  w      .text	00000000 __init_stack
000021e4 g     F .text	00000232 OSFlagPend
00004034 g     F .text	00000040 Delay
00000202 g     O .bss	00000080 TaskStartStk2
000013dc g     F .text	00000008 OSInitHookEnd
00001130 g       .text	00000000 __dtors_start
00001130 g       .text	00000000 __ctors_end
000042f2 g       .text	00000000 __divmodsi4
00000a00 g       *ABS*	00000000 __stack
000028a2 g     F .text	00000078 OSMboxCreate
000013d0 g     F .text	00000000 OSCPURestoreSR
00000200 g       .text	00000000 _edata
000005ea g       .bss	00000000 _end
00000352 g     O .bss	00000001 OSIntNesting
00000282 g     O .bss	00000080 TaskStartStk
000013ca g     F .text	00000000 OSCPUSaveSR
0000291a g     F .text	00000118 OSMboxPend
000038ca g     F .text	00000118 OSTaskStkChk
00000354 g     O .bss	00000002 OSTCBCur
000042c8 g       .text	00000000 __udivmodsi4
00002858 g     F .text	0000004a OSMboxAccept
0000161c g     F .text	0000002c OSInit
00001ac2 g     F .text	00000092 OS_EventTO
000031f2 g     F .text	0000005a OS_QInit
00001212 g     F .text	00000062 TaskStart
00001130  w      .text	00000000 vector_fff6
00000356 g     O .bss	00000080 OSTaskIdleStk
00002ab6 g     F .text	000000ac OSMboxPostOpt
000014f4 g     F .text	00000008 OSTaskSwHook
000003d6 g     O .bss	00000028 OSEventTbl
00001104  w      .text	00000000 __low_level_init
000003fe g     O .bss	000001d4 OSTCBTbl
0000112c  w      .text	00000000 __jump_to_main
00003c94 g     F .text	00000010 gotoSecondLine
00000200 g       .text	00000000 __data_start
000005d2 g     O .bss	00000002 OSFlagFreeList
000005d4 g     O .bss	00000016 OSTCBPrioTbl
00000120  w      *ABS*	00000000 __WDTCTL
00000302 g     O .bss	00000002 OSISRStkPtr
00001130  w      .text	00000000 vector_ffea
000018c4 g     F .text	0000000c OSVersion
000039e2 g     F .text	0000004e OS_TaskStkClr
00001b54 g     F .text	00000038 OS_EventWaitListInit
00001404 g     F .text	00000008 OSTaskIdleHook
00001274 g     F .text	00000042 TaskStart2
00001e06 g     F .text	00000036 OS_TaskIdle



Disassembly of section .text:

00001100 <__init_stack>:
    1100:	31 40 00 0a 	mov	#2560,	r1	;#0x0a00

00001104 <__low_level_init>:
    1104:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    1108:	20 01 

0000110a <__do_copy_data>:
    110a:	3f 40 00 00 	mov	#0,	r15	;#0x0000
    110e:	0f 93       	tst	r15		
    1110:	05 24       	jz	$+12     	;abs 0x111c
    1112:	2f 83       	decd	r15		
    1114:	9f 4f 3e 43 	mov	17214(r15),512(r15);0x433e(r15), 0x0200(r15)
    1118:	00 02 
    111a:	fb 23       	jnz	$-8      	;abs 0x1112

0000111c <__do_clear_bss>:
    111c:	3f 40 ea 03 	mov	#1002,	r15	;#0x03ea
    1120:	0f 93       	tst	r15		
    1122:	04 24       	jz	$+10     	;abs 0x112c
    1124:	1f 83       	dec	r15		
    1126:	cf 43 00 02 	mov.b	#0,	512(r15);r3 As==00, 0x0200(r15)
    112a:	fc 23       	jnz	$-6      	;abs 0x1124

0000112c <__jump_to_main>:
    112c:	30 40 38 11 	br	#0x1138	

00001130 <__ctors_end>:
    1130:	30 40 c6 42 	br	#0x42c6	
    1134:	20 4f       	br	@r15		
    1136:	54 00       	.word	0x0054;	????	

00001138 <main>:
*                                                MAIN
*********************************************************************************************************
*/

int  main (void)
{int i,j;
    1138:	31 40 fc 09 	mov	#2556,	r1	;#0x09fc
    113c:	04 41       	mov	r1,	r4	
#define WDTCTL_INIT     WDTPW|WDTHOLD



	
 WDTCTL = WDTCTL_INIT;               //Init watchdog timer
    113e:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    1142:	20 01 

    P6OUT  = P1OUT_INIT;                //Init output data of port1
    1144:	c2 43 35 00 	mov.b	#0,	&0x0035	;r3 As==00
    P6OUT  = P1OUT_INIT;                //Init output data of port2
    1148:	c2 43 35 00 	mov.b	#0,	&0x0035	;r3 As==00

    P6SEL  = P1SEL_INIT;                //Select port or module -function on port1
    114c:	c2 43 37 00 	mov.b	#0,	&0x0037	;r3 As==00
    P6SEL  = P2SEL_INIT;                //Select port or module -function on port2
    1150:	c2 43 37 00 	mov.b	#0,	&0x0037	;r3 As==00

    P6DIR  = P1DIR_INIT;                //Init port direction register of port1
    1154:	f2 43 36 00 	mov.b	#-1,	&0x0036	;r3 As==11
    P6DIR  = P2DIR_INIT;                //Init port direction register of port2
    1158:	f2 43 36 00 	mov.b	#-1,	&0x0036	;r3 As==11

    P1IES  = P1IES_INIT;                //init port interrupts
    115c:	c2 43 24 00 	mov.b	#0,	&0x0024	;r3 As==00
    P2IES  = P2IES_INIT;
    1160:	c2 43 2c 00 	mov.b	#0,	&0x002c	;r3 As==00
    P1IE   = P1IE_INIT;
    1164:	c2 43 25 00 	mov.b	#0,	&0x0025	;r3 As==00
    P2IE   = P2IE_INIT;
    1168:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00
// changement au vue de tournier , 3 lignes
  P2SEL = 0;
    116c:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00
  P2OUT = 0;
    1170:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00
  P2DIR = ~BIT0;                                //only P2.0 is input
    1174:	f2 40 fe ff 	mov.b	#-2,	&0x002a	;#0xfffe
    1178:	2a 00 

  

InitPorts();
    117a:	b0 12 de 3f 	call	#0x3fde	
	initDisplay();
    117e:	b0 12 4e 3c 	call	#0x3c4e	
	clearDisplay();
    1182:	b0 12 7c 3c 	call	#0x3c7c	
	printString(" OT");
    1186:	3f 40 34 11 	mov	#4404,	r15	;#0x1134
    118a:	b0 12 a4 3c 	call	#0x3ca4	


     for(i=0;i<=5;i++){   
    118e:	84 43 02 00 	mov	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    1192:	0b 3c       	jmp	$+24     	;abs 0x11aa
            //P6OUT = 248>>i;
            for(j=1;j<=10000;j++);
    1194:	94 43 00 00 	mov	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    1198:	02 3c       	jmp	$+6      	;abs 0x119e
    119a:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    119e:	b4 90 11 27 	cmp	#10001,	0(r4)	;#0x2711, 0x0000(r4)
    11a2:	00 00 
    11a4:	fa 3b       	jl	$-10     	;abs 0x119a
	initDisplay();
	clearDisplay();
	printString(" OT");


     for(i=0;i<=5;i++){   
    11a6:	94 53 02 00 	inc	2(r4)		;0x0002(r4)
    11aa:	b4 90 06 00 	cmp	#6,	2(r4)	;#0x0006, 0x0002(r4)
    11ae:	02 00 
    11b0:	f1 3b       	jl	$-28     	;abs 0x1194

// fin du test du démmarage


	
    WDTCTL = WDTPW + WDTHOLD;           /* Disable the watchdog timer   */
    11b2:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    11b6:	20 01 
  /*   P6DIR = 0x01;                       /* P1.0 is the only output.     */
  /*  P6OUT = 0x00;                       /* P1.0 initially low.          */
 
    // TIMERA Configuration             /* Configure TIMERA for the system Tick source. */
    //
    TACTL    = TASSEL1 + TACLR;         /* Clear the Timer and set SMCLK as the source. */
    11b8:	b2 40 04 02 	mov	#516,	&0x0160	;#0x0204
    11bc:	60 01 
    TACTL   |= 0x00C0;                  /* Input divider is /8.  */
    11be:	1f 42 60 01 	mov	&0x0160,r15	
    11c2:	3f d0 c0 00 	bis	#192,	r15	;#0x00c0
    11c6:	82 4f 60 01 	mov	r15,	&0x0160	
    TACCTL0  = CCIE;                    /* Enable the TACCR0 interrupt. */
    11ca:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    11ce:	62 01 
    TACCR0   = 2304;                   /* Load the TACCR0 register.    */  
    11d0:	b2 40 00 09 	mov	#2304,	&0x0172	;#0x0900
    11d4:	72 01 

    OSInit();                                              /* Initialize uC/OS-II                      */
    11d6:	b0 12 1c 16 	call	#0x161c	
    OSTaskCreate(TaskStart, (void *)0, &TaskStartStk[TASK_STK_SIZE - 1], 0);
    11da:	3f 40 00 03 	mov	#768,	r15	;#0x0300
    11de:	4c 43       	clr.b	r12		
    11e0:	0d 4f       	mov	r15,	r13	
    11e2:	0e 43       	clr	r14		
    11e4:	3f 40 12 12 	mov	#4626,	r15	;#0x1212
    11e8:	b0 12 e4 36 	call	#0x36e4	
	OSTaskCreate(TaskStart2, (void *)5, &TaskStartStk2[TASK_STK_SIZE - 1], 5);
    11ec:	7d 40 05 00 	mov.b	#5,	r13	;#0x0005
    11f0:	3e 40 80 02 	mov	#640,	r14	;#0x0280
    11f4:	3f 40 05 00 	mov	#5,	r15	;#0x0005
    11f8:	4c 4d       	mov.b	r13,	r12	
    11fa:	0d 4e       	mov	r14,	r13	
    11fc:	0e 4f       	mov	r15,	r14	
    11fe:	3f 40 74 12 	mov	#4724,	r15	;#0x1274
    1202:	b0 12 e4 36 	call	#0x36e4	
  /*  P6OUT = 0;*/
    OSStart();                                             /* Start multitasking                       */
    1206:	b0 12 2c 17 	call	#0x172c	

	return(0);
    120a:	0f 43       	clr	r15		
}
    120c:	21 52       	add	#4,	r1	;r2 As==10
    120e:	30 40 3c 43 	br	#0x433c	

00001212 <TaskStart>:
*                                            STARTUP TASK
*********************************************************************************************************
*/

void  TaskStart (void *pdata)
{ int i,j,k;
    1212:	04 12       	push	r4		
    1214:	31 82       	sub	#8,	r1	;r2 As==11
    1216:	04 41       	mov	r1,	r4	
    1218:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    pdata  = pdata;         /* Prevent compiler warning                 */

    TACTL |= MC1;           /* Start the Timer in Continuous mode. */
    121c:	1f 42 60 01 	mov	&0x0160,r15	
    1220:	3f d0 20 00 	bis	#32,	r15	;#0x0020
    1224:	82 4f 60 01 	mov	r15,	&0x0160	

    while (1) 
    { for(i=0;i<=5;i++){   
    1228:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    122c:	0b 3c       	jmp	$+24     	;abs 0x1244
            //P6OUT = 248>>i;
            for(j=1;j<10000;j++);
    122e:	94 43 02 00 	mov	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    1232:	02 3c       	jmp	$+6      	;abs 0x1238
    1234:	94 53 02 00 	inc	2(r4)		;0x0002(r4)
    1238:	b4 90 10 27 	cmp	#10000,	2(r4)	;#0x2710, 0x0002(r4)
    123c:	02 00 
    123e:	fa 3b       	jl	$-10     	;abs 0x1234
    pdata  = pdata;         /* Prevent compiler warning                 */

    TACTL |= MC1;           /* Start the Timer in Continuous mode. */

    while (1) 
    { for(i=0;i<=5;i++){   
    1240:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    1244:	b4 90 06 00 	cmp	#6,	4(r4)	;#0x0006, 0x0004(r4)
    1248:	04 00 
    124a:	f1 3b       	jl	$-28     	;abs 0x122e
            for(j=1;j<10000;j++);
     }
        /* Task specific code */

      //  P6OUT ^= 0x01;      /* Toggle the port pin to show signs of life.   
    k++;
    124c:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
	STATUS_LED_ON;    
    1250:	5f 42 29 00 	mov.b	&0x0029,r15	
    1254:	6f c3       	bic.b	#2,	r15	;r3 As==10
    1256:	c2 4f 29 00 	mov.b	r15,	&0x0029	
    OSTimeDly(OS_TICKS_PER_SEC); 
    125a:	3f 40 64 00 	mov	#100,	r15	;#0x0064
    125e:	b0 12 30 3a 	call	#0x3a30	
	printDecimal(1); /* Delay for a bit. */    
    1262:	1f 43       	mov	#1,	r15	;r3 As==01
    1264:	b0 12 d0 3d 	call	#0x3dd0	
	STATUS_LED_OFF;
    1268:	5f 42 29 00 	mov.b	&0x0029,r15	
    126c:	6f d3       	bis.b	#2,	r15	;r3 As==10
    126e:	c2 4f 29 00 	mov.b	r15,	&0x0029	
    1272:	da 3f       	jmp	$-74     	;abs 0x1228

00001274 <TaskStart2>:
    }
}


void  TaskStart2 (void *pdata)
{ int i,j,k;
    1274:	04 12       	push	r4		
    1276:	31 82       	sub	#8,	r1	;r2 As==11
    1278:	04 41       	mov	r1,	r4	
    127a:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    pdata  = pdata;         /* Prevent compiler warning                 */

    while (1) 
    { for(i=0;i<=5;i++){   
    127e:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    1282:	0b 3c       	jmp	$+24     	;abs 0x129a
            //P6OUT = 248>>i;
            for(j=1;j<10000;j++);
    1284:	94 43 02 00 	mov	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    1288:	02 3c       	jmp	$+6      	;abs 0x128e
    128a:	94 53 02 00 	inc	2(r4)		;0x0002(r4)
    128e:	b4 90 10 27 	cmp	#10000,	2(r4)	;#0x2710, 0x0002(r4)
    1292:	02 00 
    1294:	fa 3b       	jl	$-10     	;abs 0x128a
void  TaskStart2 (void *pdata)
{ int i,j,k;
    pdata  = pdata;         /* Prevent compiler warning                 */

    while (1) 
    { for(i=0;i<=5;i++){   
    1296:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    129a:	b4 90 06 00 	cmp	#6,	4(r4)	;#0x0006, 0x0004(r4)
    129e:	04 00 
    12a0:	f1 3b       	jl	$-28     	;abs 0x1284
            for(j=1;j<10000;j++);
     }
        /* Task specific code */

      //  P6OUT ^= 0x01;      /* Toggle the port pin to show signs of life.   
    k++;
    12a2:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
 
    OSTimeDly(OS_TICKS_PER_SEC); 
    12a6:	3f 40 64 00 	mov	#100,	r15	;#0x0064
    12aa:	b0 12 30 3a 	call	#0x3a30	
	printDecimal(2); /* Delay for a bit. */    
    12ae:	2f 43       	mov	#2,	r15	;r3 As==10
    12b0:	b0 12 d0 3d 	call	#0x3dd0	
    12b4:	e4 3f       	jmp	$-54     	;abs 0x127e

000012b6 <OSStartHighRdy>:

	.global OSStartHighRdy
	.type OSStartHighRdy, @function

OSStartHighRdy:	
            call     #OSTaskSwHook
    12b6:	b0 12 f4 14 	call	#0x14f4	

            mov.b    #1, &OSRunning         /* kernel running */
    12ba:	d2 43 05 03 	mov.b	#1,	&0x0305	;r3 As==01

            mov.w    r1, &OSISRStkPtr       /* save interrupt stack  */            
    12be:	82 41 02 03 	mov	r1,	&0x0302	

            mov.w    &OSTCBHighRdy, r13     /* load highest ready task stack  */
    12c2:	1d 42 48 03 	mov	&0x0348,r13	
            mov.w    @r13, r1
    12c6:	21 4d       	mov	@r13,	r1	

            POPALL							/* Restore all the registers.  */
    12c8:	3f 41       	pop	r15		
    12ca:	3e 41       	pop	r14		
    12cc:	3d 41       	pop	r13		
    12ce:	3c 41       	pop	r12		
    12d0:	3b 41       	pop	r11		
    12d2:	3a 41       	pop	r10		
    12d4:	39 41       	pop	r9		
    12d6:	38 41       	pop	r8		
    12d8:	37 41       	pop	r7		
    12da:	36 41       	pop	r6		
    12dc:	35 41       	pop	r5		
    12de:	34 41       	pop	r4		
                    
            reti                            /* emulate return from interrupt  */
    12e0:	00 13       	reti			

000012e2 <OSCtxSw>:
;********************************************************************************************************
*/

.global OSCtxSw
OSCtxSw:
            push      r2                    /* emulate interrupt by also saving the SR */
    12e2:	02 12       	push	r2		
            
            PUSHALL							/* Save all the task registers.  */
    12e4:	04 12       	push	r4		
    12e6:	05 12       	push	r5		
    12e8:	06 12       	push	r6		
    12ea:	07 12       	push	r7		
    12ec:	08 12       	push	r8		
    12ee:	09 12       	push	r9		
    12f0:	0a 12       	push	r10		
    12f2:	0b 12       	push	r11		
    12f4:	0c 12       	push	r12		
    12f6:	0d 12       	push	r13		
    12f8:	0e 12       	push	r14		
    12fa:	0f 12       	push	r15		
            
            mov.w     &OSTCBCur, r13        /* OSTCBCur->OSTCBStkPtr = SP  */
    12fc:	1d 42 54 03 	mov	&0x0354,r13	
            mov.w     r1, 0(r13)
    1300:	8d 41 00 00 	mov	r1,	0(r13)	;0x0000(r13)

            call      #OSTaskSwHook
    1304:	b0 12 f4 14 	call	#0x14f4	

            mov.b     &OSPrioHighRdy, r13   /*  OSPrioCur = OSPrioHighRdy  */
    1308:	5d 42 0a 03 	mov.b	&0x030a,r13	
            mov.b     r13, &OSPrioCur       /*                             */
    130c:	c2 4d 1e 03 	mov.b	r13,	&0x031e	
                          
            mov.w     &OSTCBHighRdy, r13    /* OSTCBCur  = OSTCBHighRdy    */
    1310:	1d 42 48 03 	mov	&0x0348,r13	
            mov.w     r13, &OSTCBCur        /*                             */
    1314:	82 4d 54 03 	mov	r13,	&0x0354	
                          
            mov.w     @r13, r1              /*  SP        = OSTCBHighRdy->OSTCBStkPtr  */
    1318:	21 4d       	mov	@r13,	r1	
             
            POPALL							/* Restore the new task registers.  */
    131a:	3f 41       	pop	r15		
    131c:	3e 41       	pop	r14		
    131e:	3d 41       	pop	r13		
    1320:	3c 41       	pop	r12		
    1322:	3b 41       	pop	r11		
    1324:	3a 41       	pop	r10		
    1326:	39 41       	pop	r9		
    1328:	38 41       	pop	r8		
    132a:	37 41       	pop	r7		
    132c:	36 41       	pop	r6		
    132e:	35 41       	pop	r5		
    1330:	34 41       	pop	r4		
            
            reti                            /* return from interrup  */
    1332:	00 13       	reti			

00001334 <OSIntCtxSw>:

.global OSIntCtxSw

OSIntCtxSw:
             
            call      #OSTaskSwHook
    1334:	b0 12 f4 14 	call	#0x14f4	

            mov.b     &OSPrioHighRdy, r13   /* OSPrioCur = OSPrioHighRdy */
    1338:	5d 42 0a 03 	mov.b	&0x030a,r13	
            mov.b     r13, &OSPrioCur       
    133c:	c2 4d 1e 03 	mov.b	r13,	&0x031e	
                          
            mov.w     &OSTCBHighRdy, r13    /* OSTCBCur  = OSTCBHighRdy  */
    1340:	1d 42 48 03 	mov	&0x0348,r13	
            mov.w     r13, &OSTCBCur
    1344:	82 4d 54 03 	mov	r13,	&0x0354	
                          
            mov.w     @r13, r1              /* SP        = OSTCBHighRdy->OSTCBStkPtr */
    1348:	21 4d       	mov	@r13,	r1	
             
            POPALL							/* Restore the registers.  */
    134a:	3f 41       	pop	r15		
    134c:	3e 41       	pop	r14		
    134e:	3d 41       	pop	r13		
    1350:	3c 41       	pop	r12		
    1352:	3b 41       	pop	r11		
    1354:	3a 41       	pop	r10		
    1356:	39 41       	pop	r9		
    1358:	38 41       	pop	r8		
    135a:	37 41       	pop	r7		
    135c:	36 41       	pop	r6		
    135e:	35 41       	pop	r5		
    1360:	34 41       	pop	r4		
             
            reti                            /* return from interrup */
    1362:	00 13       	reti			

00001364 <vector_ffec>:
;********************************************************************************************************
*/

interrupt(TIMERA0_VECTOR)
TA0_ISR:                                    /* TIMERA0 timer ISR */
            PUSHALL
    1364:	04 12       	push	r4		
    1366:	05 12       	push	r5		
    1368:	06 12       	push	r6		
    136a:	07 12       	push	r7		
    136c:	08 12       	push	r8		
    136e:	09 12       	push	r9		
    1370:	0a 12       	push	r10		
    1372:	0b 12       	push	r11		
    1374:	0c 12       	push	r12		
    1376:	0d 12       	push	r13		
    1378:	0e 12       	push	r14		
    137a:	0f 12       	push	r15		
                        
            add.w	 #2304, &TACCR0			/* Reset the Timer Period*/
    137c:	b2 50 00 09 	add	#2304,	&0x0172	;#0x0900
    1380:	72 01 
                         
            cmp.b    #0, &OSIntNesting      /* if (OSIntNesting == 0)  */
    1382:	c2 93 52 03 	tst.b	&0x0352	
            jne      L1
    1386:	06 20       	jnz	$+14     	;abs 0x1394
                               
            mov.w    &OSTCBCur, r13         /* save task stack */
    1388:	1d 42 54 03 	mov	&0x0354,r13	
            mov.w    r1, 0(r13)
    138c:	8d 41 00 00 	mov	r1,	0(r13)	;0x0000(r13)

            mov.w    &OSISRStkPtr, r1       /* load interrupt stack  */
    1390:	11 42 02 03 	mov	&0x0302,r1	

00001394 <L1>:

L1:
            inc.b    &OSIntNesting          /* increase OSIntNesting */
    1394:	d2 53 52 03 	inc.b	&0x0352	
             
            EINT                           /* enable general interrupt to allow for interrupt nesting */
    1398:	32 d2       	eint			

            call     #OSTimeTick            /* call ticks routine       */
    139a:	b0 12 92 17 	call	#0x1792	

            DINT                           /* IMPORTANT: disable general interrupt BEFORE calling OSIntExit() */
    139e:	32 c2       	dint			

            call     #OSIntExit             /* call ticks routine */
    13a0:	b0 12 6a 16 	call	#0x166a	

            cmp.b    #0, &OSIntNesting      /* if (OSIntNesting == 0) */ 
    13a4:	c2 93 52 03 	tst.b	&0x0352	
            jne      L2
    13a8:	03 20       	jnz	$+8      	;abs 0x13b0

            mov.w    &OSTCBHighRdy, r13     /* restore task stack SP */
    13aa:	1d 42 48 03 	mov	&0x0348,r13	
            mov.w    @r13, r1
    13ae:	21 4d       	mov	@r13,	r1	

000013b0 <L2>:
                       
L2:
			POPALL
    13b0:	3f 41       	pop	r15		
    13b2:	3e 41       	pop	r14		
    13b4:	3d 41       	pop	r13		
    13b6:	3c 41       	pop	r12		
    13b8:	3b 41       	pop	r11		
    13ba:	3a 41       	pop	r10		
    13bc:	39 41       	pop	r9		
    13be:	38 41       	pop	r8		
    13c0:	37 41       	pop	r7		
    13c2:	36 41       	pop	r6		
    13c4:	35 41       	pop	r5		
    13c6:	34 41       	pop	r4		

            reti                            ; return from interrupt
    13c8:	00 13       	reti			

000013ca <OSCPUSaveSR>:
*/

.global OSCPUSaveSR
.type OSCPUSaveSR, @function
OSCPUSaveSR:
            MOV.W    r2,r15			/* gcc returns the value of the sr in r15 */
    13ca:	0f 42       	mov	r2,	r15	
            DINT
    13cc:	32 c2       	dint			
            RET
    13ce:	30 41       	ret			

000013d0 <OSCPURestoreSR>:

.global OSCPURestoreSR
.type OSCPURestoreSR, @function
OSCPURestoreSR:
            MOV.W    r15,r2			/* gcc passes the sr in r15 */
    13d0:	02 4f       	mov	r15,	r2	
            RET
    13d2:	30 41       	ret			

000013d4 <OSInitHookBegin>:
* Note(s)    : 1) Interrupts should be disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSInitHookBegin (void)
{
    13d4:	04 12       	push	r4		
    13d6:	04 41       	mov	r1,	r4	
}
    13d8:	34 41       	pop	r4		
    13da:	30 41       	ret			

000013dc <OSInitHookEnd>:
* Note(s)    : 1) Interrupts should be disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSInitHookEnd (void)
{
    13dc:	04 12       	push	r4		
    13de:	04 41       	mov	r1,	r4	
}
    13e0:	34 41       	pop	r4		
    13e2:	30 41       	ret			

000013e4 <OSTaskCreateHook>:
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 
void  OSTaskCreateHook (OS_TCB *ptcb)
{
    13e4:	04 12       	push	r4		
    13e6:	21 83       	decd	r1		
    13e8:	04 41       	mov	r1,	r4	
    13ea:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
    13ee:	21 53       	incd	r1		
    13f0:	34 41       	pop	r4		
    13f2:	30 41       	ret			

000013f4 <OSTaskDelHook>:
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 
void  OSTaskDelHook (OS_TCB *ptcb)
{
    13f4:	04 12       	push	r4		
    13f6:	21 83       	decd	r1		
    13f8:	04 41       	mov	r1,	r4	
    13fa:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
    13fe:	21 53       	incd	r1		
    1400:	34 41       	pop	r4		
    1402:	30 41       	ret			

00001404 <OSTaskIdleHook>:
* Note(s)    : 1) Interrupts are enabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION >= 251
void  OSTaskIdleHook (void)
{
    1404:	04 12       	push	r4		
    1406:	04 41       	mov	r1,	r4	
#if 0
    LPM0;                                         /* Enter low power mode                              */
#endif    
}
    1408:	34 41       	pop	r4		
    140a:	30 41       	ret			

0000140c <OSTaskStatHook>:
*********************************************************************************************************
*/

#if OS_CPU_HOOKS_EN > 0 
void  OSTaskStatHook (void)
{
    140c:	04 12       	push	r4		
    140e:	04 41       	mov	r1,	r4	
}
    1410:	34 41       	pop	r4		
    1412:	30 41       	ret			

00001414 <OSTaskStkInit>:
*                 }
*********************************************************************************************************
*/

OS_STK  *OSTaskStkInit (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT16U opt)
{
    1414:	04 12       	push	r4		
    1416:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    141a:	04 41       	mov	r1,	r4	
    141c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    1420:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    1424:	84 4d 06 00 	mov	r13,	6(r4)	;0x0006(r4)
    1428:	84 4c 08 00 	mov	r12,	8(r4)	;0x0008(r4)
    INT16U  *top;


    opt    = opt;                 
    top    = (INT16U *)ptos;
    142c:	94 44 06 00 	mov	6(r4),	0(r4)	;0x0006(r4), 0x0000(r4)
    1430:	00 00 
    top--;  
    1432:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)task;
    1436:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    143a:	2f 44       	mov	@r4,	r15	
    143c:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    top--;
    1440:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)task;                          /* Interrupt return pointer                          */
    1444:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    1448:	2f 44       	mov	@r4,	r15	
    144a:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    top--;
    144e:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0008;                        /* Status register                                   */
    1452:	2f 44       	mov	@r4,	r15	
    1454:	bf 42 00 00 	mov	#8,	0(r15)	;r2 As==11, 0x0000(r15)
    top--;
    1458:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0404;
    145c:	2f 44       	mov	@r4,	r15	
    145e:	bf 40 04 04 	mov	#1028,	0(r15)	;#0x0404, 0x0000(r15)
    1462:	00 00 
    top--;
    1464:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0505;
    1468:	2f 44       	mov	@r4,	r15	
    146a:	bf 40 05 05 	mov	#1285,	0(r15)	;#0x0505, 0x0000(r15)
    146e:	00 00 
    top--;
    1470:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0606;
    1474:	2f 44       	mov	@r4,	r15	
    1476:	bf 40 06 06 	mov	#1542,	0(r15)	;#0x0606, 0x0000(r15)
    147a:	00 00 
    top--;
    147c:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0707;
    1480:	2f 44       	mov	@r4,	r15	
    1482:	bf 40 07 07 	mov	#1799,	0(r15)	;#0x0707, 0x0000(r15)
    1486:	00 00 
    top--;
    1488:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0808;
    148c:	2f 44       	mov	@r4,	r15	
    148e:	bf 40 08 08 	mov	#2056,	0(r15)	;#0x0808, 0x0000(r15)
    1492:	00 00 
    top--;
    1494:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0909;
    1498:	2f 44       	mov	@r4,	r15	
    149a:	bf 40 09 09 	mov	#2313,	0(r15)	;#0x0909, 0x0000(r15)
    149e:	00 00 
    top--;
    14a0:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1010;
    14a4:	2f 44       	mov	@r4,	r15	
    14a6:	bf 40 10 10 	mov	#4112,	0(r15)	;#0x1010, 0x0000(r15)
    14aa:	00 00 
    top--;
    14ac:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1111;
    14b0:	2f 44       	mov	@r4,	r15	
    14b2:	bf 40 11 11 	mov	#4369,	0(r15)	;#0x1111, 0x0000(r15)
    14b6:	00 00 
    top--;
    14b8:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1212;           /* IAR Only */  /* Pass 'p_arg' through register R12                 */
    14bc:	2f 44       	mov	@r4,	r15	
    14be:	bf 40 12 12 	mov	#4626,	0(r15)	;#0x1212, 0x0000(r15)
    14c2:	00 00 
    top--;
    14c4:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1313;
    14c8:	2f 44       	mov	@r4,	r15	
    14ca:	bf 40 13 13 	mov	#4883,	0(r15)	;#0x1313, 0x0000(r15)
    14ce:	00 00 
    top--;
    14d0:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1414;                         
    14d4:	2f 44       	mov	@r4,	r15	
    14d6:	bf 40 14 14 	mov	#5140,	0(r15)	;#0x1414, 0x0000(r15)
    14da:	00 00 
    top--;
    14dc:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)p_arg;           /* GCC uses r15 */
    14e0:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    14e4:	2f 44       	mov	@r4,	r15	
    14e6:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    return ((OS_STK *)top);    
    14ea:	2f 44       	mov	@r4,	r15	
}
    14ec:	31 50 0a 00 	add	#10,	r1	;#0x000a
    14f0:	34 41       	pop	r4		
    14f2:	30 41       	ret			

000014f4 <OSTaskSwHook>:
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0
void  OSTaskSwHook (void)
{
    14f4:	04 12       	push	r4		
    14f6:	04 41       	mov	r1,	r4	
}
    14f8:	34 41       	pop	r4		
    14fa:	30 41       	ret			

000014fc <OSTCBInitHook>:
* Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSTCBInitHook (OS_TCB *ptcb)
{
    14fc:	04 12       	push	r4		
    14fe:	21 83       	decd	r1		
    1500:	04 41       	mov	r1,	r4	
    1502:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                                           /* Prevent Compiler warning                 */
}
    1506:	21 53       	incd	r1		
    1508:	34 41       	pop	r4		
    150a:	30 41       	ret			

0000150c <OSTimeTickHook>:
* Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0
void  OSTimeTickHook (void)
{
    150c:	04 12       	push	r4		
    150e:	04 41       	mov	r1,	r4	
}
    1510:	34 41       	pop	r4		
    1512:	30 41       	ret			

00001514 <OSMapTbl>:
    1514:	01 02 04 08 10 20 40 80                             ..... @.

0000151c <OSUnMapTbl>:
    151c:	00 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    152c:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    153c:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    154c:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    155c:	06 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    156c:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    157c:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    158c:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    159c:	07 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15ac:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15bc:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15cc:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15dc:	06 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15ec:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15fc:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    160c:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................

0000161c <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
    161c:	04 12       	push	r4		
    161e:	04 41       	mov	r1,	r4	
#if OS_VERSION >= 204
    OSInitHookBegin();                                           /* Call port specific initialization code   */
    1620:	b0 12 d4 13 	call	#0x13d4	
#endif

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
    1624:	b0 12 f2 1b 	call	#0x1bf2	

    OS_InitRdyList();                                            /* Initialize the Ready List                */
    1628:	b0 12 1a 1c 	call	#0x1c1a	

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
    162c:	b0 12 8e 1c 	call	#0x1c8e	

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
    1630:	b0 12 8c 1b 	call	#0x1b8c	

#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
    1634:	b0 12 de 26 	call	#0x26de	
#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
    1638:	b0 12 f2 31 	call	#0x31f2	
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
    163c:	b0 12 5a 1c 	call	#0x1c5a	
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
#endif

#if OS_VERSION >= 204
    OSInitHookEnd();                                             /* Call port specific init. code            */
    1640:	b0 12 dc 13 	call	#0x13dc	
#endif

#if OS_VERSION >= 270 && OS_DEBUG_EN > 0
    OSDebugInit();
#endif
}
    1644:	34 41       	pop	r4		
    1646:	30 41       	ret			

00001648 <OSIntEnter>:
*                 OSIntEnter() is always called with interrupts disabled.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
    1648:	04 12       	push	r4		
    164a:	04 41       	mov	r1,	r4	
    if (OSRunning == TRUE) {
    164c:	5f 42 05 03 	mov.b	&0x0305,r15	
    1650:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    1652:	09 20       	jnz	$+20     	;abs 0x1666
        if (OSIntNesting < 255u) {
    1654:	5f 42 52 03 	mov.b	&0x0352,r15	
    1658:	7f 93       	cmp.b	#-1,	r15	;r3 As==11
    165a:	05 24       	jz	$+12     	;abs 0x1666
            OSIntNesting++;                      /* Increment ISR nesting level                        */
    165c:	5f 42 52 03 	mov.b	&0x0352,r15	
    1660:	5f 53       	inc.b	r15		
    1662:	c2 4f 52 03 	mov.b	r15,	&0x0352	
        }
    }
}
    1666:	34 41       	pop	r4		
    1668:	30 41       	ret			

0000166a <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
    166a:	04 12       	push	r4		
    166c:	21 82       	sub	#4,	r1	;r2 As==10
    166e:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    1670:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSRunning == TRUE) {
    1674:	5f 42 05 03 	mov.b	&0x0305,r15	
    1678:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    167a:	55 20       	jnz	$+172    	;abs 0x1726
        OS_ENTER_CRITICAL();
    167c:	b0 12 ca 13 	call	#0x13ca	
    1680:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
    1684:	5f 42 52 03 	mov.b	&0x0352,r15	
    1688:	4f 93       	tst.b	r15		
    168a:	05 24       	jz	$+12     	;abs 0x1696
            OSIntNesting--;
    168c:	5f 42 52 03 	mov.b	&0x0352,r15	
    1690:	7f 53       	add.b	#-1,	r15	;r3 As==11
    1692:	c2 4f 52 03 	mov.b	r15,	&0x0352	
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
    1696:	5f 42 52 03 	mov.b	&0x0352,r15	
    169a:	4f 93       	tst.b	r15		
    169c:	41 20       	jnz	$+132    	;abs 0x1720
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
    169e:	5f 42 04 03 	mov.b	&0x0304,r15	
    16a2:	4f 93       	tst.b	r15		
    16a4:	3d 20       	jnz	$+124    	;abs 0x1720
                y             = OSUnMapTbl[OSRdyGrp];          
    16a6:	5f 42 4c 03 	mov.b	&0x034c,r15	
    16aa:	7f f3       	and.b	#-1,	r15	;r3 As==11
    16ac:	d4 4f 1c 15 	mov.b	5404(r15),2(r4)	;0x151c(r15), 0x0002(r4)
    16b0:	02 00 
                OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
    16b2:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    16b6:	4f 5f       	rla.b	r15		
    16b8:	4f 5f       	rla.b	r15		
    16ba:	4f 5f       	rla.b	r15		
    16bc:	4e 4f       	mov.b	r15,	r14	
    16be:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    16c2:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    16c6:	7f f3       	and.b	#-1,	r15	;r3 As==11
    16c8:	5f 4f 1c 15 	mov.b	5404(r15),r15	;0x151c(r15)
    16cc:	4f 5e       	add.b	r14,	r15	
    16ce:	c2 4f 0a 03 	mov.b	r15,	&0x030a	
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
    16d2:	5e 42 0a 03 	mov.b	&0x030a,r14	
    16d6:	5f 42 1e 03 	mov.b	&0x031e,r15	
    16da:	4e 9f       	cmp.b	r15,	r14	
    16dc:	21 24       	jz	$+68     	;abs 0x1720
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
    16de:	5f 42 0a 03 	mov.b	&0x030a,r15	
    16e2:	7f f3       	and.b	#-1,	r15	;r3 As==11
    16e4:	0f 5f       	rla	r15		
    16e6:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    16ea:	2f 4f       	mov	@r15,	r15	
    16ec:	82 4f 48 03 	mov	r15,	&0x0348	
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
    16f0:	1d 42 48 03 	mov	&0x0348,r13	
    16f4:	1e 4d 22 00 	mov	34(r13),r14	;0x0022(r13)
    16f8:	1f 4d 24 00 	mov	36(r13),r15	;0x0024(r13)
    16fc:	1e 53       	inc	r14		
    16fe:	0f 63       	adc	r15		
    1700:	8d 4e 22 00 	mov	r14,	34(r13)	;0x0022(r13)
    1704:	8d 4f 24 00 	mov	r15,	36(r13)	;0x0024(r13)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
    1708:	1e 42 24 03 	mov	&0x0324,r14	
    170c:	1f 42 26 03 	mov	&0x0326,r15	
    1710:	1e 53       	inc	r14		
    1712:	0f 63       	adc	r15		
    1714:	82 4e 24 03 	mov	r14,	&0x0324	
    1718:	82 4f 26 03 	mov	r15,	&0x0326	
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
    171c:	b0 12 34 13 	call	#0x1334	
                }
            }
        }
        OS_EXIT_CRITICAL();
    1720:	2f 44       	mov	@r4,	r15	
    1722:	b0 12 d0 13 	call	#0x13d0	
    }
}
    1726:	21 52       	add	#4,	r1	;r2 As==10
    1728:	34 41       	pop	r4		
    172a:	30 41       	ret			

0000172c <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
    172c:	04 12       	push	r4		
    172e:	21 83       	decd	r1		
    1730:	04 41       	mov	r1,	r4	
    INT8U y;
    INT8U x;


    if (OSRunning == FALSE) {
    1732:	5f 42 05 03 	mov.b	&0x0305,r15	
    1736:	4f 93       	tst.b	r15		
    1738:	29 20       	jnz	$+84     	;abs 0x178c
        y             = OSUnMapTbl[OSRdyGrp];        /* Find highest priority's task priority number   */
    173a:	5f 42 4c 03 	mov.b	&0x034c,r15	
    173e:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1740:	d4 4f 1c 15 	mov.b	5404(r15),1(r4)	;0x151c(r15), 0x0001(r4)
    1744:	01 00 
        x             = OSUnMapTbl[OSRdyTbl[y]];
    1746:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    174a:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    174e:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1750:	d4 4f 1c 15 	mov.b	5404(r15),0(r4)	;0x151c(r15), 0x0000(r4)
    1754:	00 00 
        OSPrioHighRdy = (INT8U)((y << 3) + x);
    1756:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    175a:	4f 5f       	rla.b	r15		
    175c:	4f 5f       	rla.b	r15		
    175e:	4f 5f       	rla.b	r15		
    1760:	6f 54       	add.b	@r4,	r15	
    1762:	c2 4f 0a 03 	mov.b	r15,	&0x030a	
        OSPrioCur     = OSPrioHighRdy;
    1766:	5f 42 0a 03 	mov.b	&0x030a,r15	
    176a:	c2 4f 1e 03 	mov.b	r15,	&0x031e	
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
    176e:	5f 42 0a 03 	mov.b	&0x030a,r15	
    1772:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1774:	0f 5f       	rla	r15		
    1776:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    177a:	2f 4f       	mov	@r15,	r15	
    177c:	82 4f 48 03 	mov	r15,	&0x0348	
        OSTCBCur      = OSTCBHighRdy;
    1780:	1f 42 48 03 	mov	&0x0348,r15	
    1784:	82 4f 54 03 	mov	r15,	&0x0354	
        OSStartHighRdy();                            /* Execute target specific code to start task     */
    1788:	b0 12 b6 12 	call	#0x12b6	
    }
}
    178c:	21 53       	incd	r1		
    178e:	34 41       	pop	r4		
    1790:	30 41       	ret			

00001792 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
    1792:	04 12       	push	r4		
    1794:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1798:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                     */
    179a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif
#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
    179e:	b0 12 0c 15 	call	#0x150c	
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
    OSTime++;
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == TRUE) {
    17a2:	5f 42 05 03 	mov.b	&0x0305,r15	
    17a6:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    17a8:	89 20       	jnz	$+276    	;abs 0x18bc
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
    17aa:	5f 42 22 03 	mov.b	&0x0322,r15	
    17ae:	7f f3       	and.b	#-1,	r15	;r3 As==11
    17b0:	1f 93       	cmp	#1,	r15	;r3 As==01
    17b2:	07 24       	jz	$+16     	;abs 0x17c2
    17b4:	2f 93       	cmp	#2,	r15	;r3 As==10
    17b6:	08 24       	jz	$+18     	;abs 0x17c8
    17b8:	0f 93       	tst	r15		
    17ba:	0b 20       	jnz	$+24     	;abs 0x17d2
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = TRUE;
    17bc:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    17c0:	0c 3c       	jmp	$+26     	;abs 0x17da
                 break;

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = FALSE;                             /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
    17c2:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    17c6:	09 3c       	jmp	$+20     	;abs 0x17da
                 break;

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = TRUE;                   /*      ... step command from uC/OS-View        */
    17c8:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
                 OSTickStepState = OS_TICK_STEP_WAIT;
    17cc:	d2 43 22 03 	mov.b	#1,	&0x0322	;r3 As==01
    17d0:	04 3c       	jmp	$+10     	;abs 0x17da
                 break;

            default:                                       /* Invalid case, correct situation              */
                 step            = TRUE;
    17d2:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
                 OSTickStepState = OS_TICK_STEP_DIS;
    17d6:	c2 43 22 03 	mov.b	#0,	&0x0322	;r3 As==00
                 break;
        }
        if (step == FALSE) {                               /* Return if waiting for step command           */
    17da:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    17de:	6d 24       	jz	$+220    	;abs 0x18ba
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
    17e0:	94 42 20 03 	mov	&0x0320,4(r4)	;0x0004(r4)
    17e4:	04 00 
    17e6:	61 3c       	jmp	$+196    	;abs 0x18aa
        while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {          /* Go through all TCBs in TCB list              */
            OS_ENTER_CRITICAL();
    17e8:	b0 12 ca 13 	call	#0x13ca	
    17ec:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
    17f0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    17f4:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    17f8:	0f 93       	tst	r15		
    17fa:	4f 24       	jz	$+160    	;abs 0x189a
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
    17fc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1800:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    1804:	0e 4f       	mov	r15,	r14	
    1806:	3e 53       	add	#-1,	r14	;r3 As==11
    1808:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    180c:	8f 4e 18 00 	mov	r14,	24(r15)	;0x0018(r15)
    1810:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1814:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    1818:	0f 93       	tst	r15		
    181a:	3f 20       	jnz	$+128    	;abs 0x189a
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
    181c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1820:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1824:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1826:	3f f0 37 00 	and	#55,	r15	;#0x0037
    182a:	10 24       	jz	$+34     	;abs 0x184c
                        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag   */
    182c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1830:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1834:	4e 4f       	mov.b	r15,	r14	
    1836:	7e f0 c8 ff 	and.b	#-56,	r14	;#0xffc8
    183a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    183e:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
                        ptcb->OSTCBPendTO  = TRUE;                             /* Indicate PEND timeout    */
    1842:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1846:	df 43 1b 00 	mov.b	#1,	27(r15)	;r3 As==01, 0x001b(r15)
    184a:	04 3c       	jmp	$+10     	;abs 0x1854
                    } else {
                        ptcb->OSTCBPendTO  = FALSE;
    184c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1850:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
    1854:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1858:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    185c:	7f f3       	and.b	#-1,	r15	;r3 As==11
    185e:	3f f2       	and	#8,	r15	;r2 As==11
    1860:	1c 20       	jnz	$+58     	;abs 0x189a
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
    1862:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1866:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    186a:	5f 42 4c 03 	mov.b	&0x034c,r15	
    186e:	4f de       	bis.b	r14,	r15	
    1870:	c2 4f 4c 03 	mov.b	r15,	&0x034c	
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    1874:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1878:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    187c:	4d 4f       	mov.b	r15,	r13	
    187e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1882:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1886:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1888:	5e 4f 4e 03 	mov.b	846(r15),r14	;0x034e(r15)
    188c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1890:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1894:	4f de       	bis.b	r14,	r15	
    1896:	cd 4f 4e 03 	mov.b	r15,	846(r13);0x034e(r13)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
    189a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    189e:	94 4f 0e 00 	mov	14(r15),4(r4)	;0x000e(r15), 0x0004(r4)
    18a2:	04 00 
            OS_EXIT_CRITICAL();
    18a4:	2f 44       	mov	@r4,	r15	
    18a6:	b0 12 d0 13 	call	#0x13d0	
        if (step == FALSE) {                               /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {          /* Go through all TCBs in TCB list              */
    18aa:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18ae:	5f 4f 1c 00 	mov.b	28(r15),r15	;0x001c(r15)
    18b2:	7f 90 0a 00 	cmp.b	#10,	r15	;#0x000a
    18b6:	98 23       	jnz	$-206    	;abs 0x17e8
    18b8:	01 3c       	jmp	$+4      	;abs 0x18bc
                 step            = TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == FALSE) {                               /* Return if waiting for step command           */
            return;
    18ba:	03 43       	nop			
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
    18bc:	31 50 06 00 	add	#6,	r1	;#0x0006
    18c0:	34 41       	pop	r4		
    18c2:	30 41       	ret			

000018c4 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
    18c4:	04 12       	push	r4		
    18c6:	04 41       	mov	r1,	r4	
    return (OS_VERSION);
    18c8:	3f 40 14 01 	mov	#276,	r15	;#0x0114
}
    18cc:	34 41       	pop	r4		
    18ce:	30 41       	ret			

000018d0 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *msg, INT8U msk)
{
    18d0:	04 12       	push	r4		
    18d2:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    18d6:	04 41       	mov	r1,	r4	
    18d8:	84 4f 08 00 	mov	r15,	8(r4)	;0x0008(r4)
    18dc:	84 4e 0a 00 	mov	r14,	10(r4)	;0x000a(r4)
    18e0:	c4 4d 0c 00 	mov.b	r13,	12(r4)	;0x000c(r4)
    INT8U   bitx;
    INT8U   bity;
    INT8U   prio;


    y                      = OSUnMapTbl[pevent->OSEventGrp];   /* Find HPT waiting for message         */
    18e4:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    18e8:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    18ec:	7f f3       	and.b	#-1,	r15	;r3 As==11
    18ee:	d4 4f 1c 15 	mov.b	5404(r15),3(r4)	;0x151c(r15), 0x0003(r4)
    18f2:	03 00 
    bity                   = OSMapTbl[y];
    18f4:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    18f8:	d4 4f 14 15 	mov.b	5396(r15),1(r4)	;0x1514(r15), 0x0001(r4)
    18fc:	01 00 
    x                      = OSUnMapTbl[pevent->OSEventTbl[y]];
    18fe:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    1902:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1906:	0f 5e       	add	r14,	r15	
    1908:	3f 50 06 00 	add	#6,	r15	;#0x0006
    190c:	6f 4f       	mov.b	@r15,	r15	
    190e:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1910:	d4 4f 1c 15 	mov.b	5404(r15),4(r4)	;0x151c(r15), 0x0004(r4)
    1914:	04 00 
    bitx                   = OSMapTbl[x];
    1916:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    191a:	d4 4f 14 15 	mov.b	5396(r15),2(r4)	;0x1514(r15), 0x0002(r4)
    191e:	02 00 
    prio                   = (INT8U)((y << 3) + x);     /* Find priority of task getting the msg       */
    1920:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    1924:	4f 5f       	rla.b	r15		
    1926:	4f 5f       	rla.b	r15		
    1928:	4f 5f       	rla.b	r15		
    192a:	4e 4f       	mov.b	r15,	r14	
    192c:	5e 54 04 00 	add.b	4(r4),	r14	;0x0004(r4)
    1930:	c4 4e 00 00 	mov.b	r14,	0(r4)	;0x0000(r4)
    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
    1934:	5d 44 03 00 	mov.b	3(r4),	r13	;0x0003(r4)
    1938:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    193c:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1940:	0f 5e       	add	r14,	r15	
    1942:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1946:	6f 4f       	mov.b	@r15,	r15	
    1948:	4e 4f       	mov.b	r15,	r14	
    194a:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    194e:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1950:	4f fe       	and.b	r14,	r15	
    1952:	4e 4f       	mov.b	r15,	r14	
    1954:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1958:	0f 5d       	add	r13,	r15	
    195a:	3f 50 06 00 	add	#6,	r15	;#0x0006
    195e:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    if (pevent->OSEventTbl[y] == 0x00) {                
    1962:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    1966:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    196a:	0f 5e       	add	r14,	r15	
    196c:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1970:	6f 4f       	mov.b	@r15,	r15	
    1972:	4f 93       	tst.b	r15		
    1974:	0e 20       	jnz	$+30     	;abs 0x1992
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
    1976:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    197a:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    197e:	4e 4f       	mov.b	r15,	r14	
    1980:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    1984:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1986:	4f fe       	and.b	r14,	r15	
    1988:	4e 4f       	mov.b	r15,	r14	
    198a:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    198e:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
    }
    ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
    1992:	6f 44       	mov.b	@r4,	r15	
    1994:	0f 5f       	rla	r15		
    1996:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    199a:	a4 4f 06 00 	mov	@r15,	6(r4)	;0x0006(r4)
    ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
    199e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19a2:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)
    ptcb->OSTCBEventPtr  = (OS_EVENT *)0;               /* Unlink ECB from this task                   */
    19a6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19aa:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg       = msg;                         /* Send message directly to waiting task       */
    19ae:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19b2:	9f 44 0a 00 	mov	10(r4),	20(r15)	;0x000a(r4), 0x0014(r15)
    19b6:	14 00 
#else
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = FALSE;                       /* Cancel 'any' timeout because of post        */
    19b8:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19bc:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
    19c0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19c4:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    19c8:	4e 4f       	mov.b	r15,	r14	
    19ca:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    19ce:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    19d0:	4f fe       	and.b	r14,	r15	
    19d2:	4e 4f       	mov.b	r15,	r14	
    19d4:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19d8:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {               /* See if task is ready (could be susp'd)      */
    19dc:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19e0:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    19e4:	4f 93       	tst.b	r15		
    19e6:	10 20       	jnz	$+34     	;abs 0x1a08
        OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
    19e8:	5f 42 4c 03 	mov.b	&0x034c,r15	
    19ec:	5f d4 01 00 	bis.b	1(r4),	r15	;0x0001(r4)
    19f0:	c2 4f 4c 03 	mov.b	r15,	&0x034c	
        OSRdyTbl[y]     |=  bitx;
    19f4:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    19f8:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    19fc:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    1a00:	5f d4 02 00 	bis.b	2(r4),	r15	;0x0002(r4)
    1a04:	ce 4f 4e 03 	mov.b	r15,	846(r14);0x034e(r14)
    }
    return (prio);
    1a08:	6f 44       	mov.b	@r4,	r15	
}
    1a0a:	31 50 0e 00 	add	#14,	r1	;#0x000e
    1a0e:	34 41       	pop	r4		
    1a10:	30 41       	ret			

00001a12 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    1a12:	04 12       	push	r4		
    1a14:	21 82       	sub	#4,	r1	;r2 As==10
    1a16:	04 41       	mov	r1,	r4	
    1a18:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    1a1c:	1f 42 54 03 	mov	&0x0354,r15	
    1a20:	9f 44 02 00 	mov	2(r4),	18(r15)	;0x0002(r4), 0x0012(r15)
    1a24:	12 00 
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    1a26:	1f 42 54 03 	mov	&0x0354,r15	
    1a2a:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    1a2e:	00 00 
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
    1a30:	6d 44       	mov.b	@r4,	r13	
    1a32:	6f 44       	mov.b	@r4,	r15	
    1a34:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    1a38:	4e 4f       	mov.b	r15,	r14	
    1a3a:	1f 42 54 03 	mov	&0x0354,r15	
    1a3e:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1a42:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1a44:	4f fe       	and.b	r14,	r15	
    1a46:	cd 4f 4e 03 	mov.b	r15,	846(r13);0x034e(r13)
    if (OSRdyTbl[y] == 0x00) {                   
    1a4a:	6f 44       	mov.b	@r4,	r15	
    1a4c:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    1a50:	4f 93       	tst.b	r15		
    1a52:	0b 20       	jnz	$+24     	;abs 0x1a6a
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
    1a54:	1f 42 54 03 	mov	&0x0354,r15	
    1a58:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1a5c:	4e 4f       	mov.b	r15,	r14	
    1a5e:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    1a60:	5f 42 4c 03 	mov.b	&0x034c,r15	
    1a64:	4f fe       	and.b	r14,	r15	
    1a66:	c2 4f 4c 03 	mov.b	r15,	&0x034c	
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
    1a6a:	1f 42 54 03 	mov	&0x0354,r15	
    1a6e:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1a72:	4d 4f       	mov.b	r15,	r13	
    1a74:	1f 42 54 03 	mov	&0x0354,r15	
    1a78:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1a7c:	4e 4f       	mov.b	r15,	r14	
    1a7e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1a82:	0f 5e       	add	r14,	r15	
    1a84:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1a88:	6e 4f       	mov.b	@r15,	r14	
    1a8a:	1f 42 54 03 	mov	&0x0354,r15	
    1a8e:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1a92:	4e df       	bis.b	r15,	r14	
    1a94:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1a98:	0f 5d       	add	r13,	r15	
    1a9a:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1a9e:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
    1aa2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1aa6:	5e 4f 01 00 	mov.b	1(r15),	r14	;0x0001(r15)
    1aaa:	1f 42 54 03 	mov	&0x0354,r15	
    1aae:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1ab2:	4e df       	bis.b	r15,	r14	
    1ab4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ab8:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
}
    1abc:	21 52       	add	#4,	r1	;r2 As==10
    1abe:	34 41       	pop	r4		
    1ac0:	30 41       	ret			

00001ac2 <OS_EventTO>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTO (OS_EVENT *pevent)
{
    1ac2:	04 12       	push	r4		
    1ac4:	21 82       	sub	#4,	r1	;r2 As==10
    1ac6:	04 41       	mov	r1,	r4	
    1ac8:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  y;


    y                      = OSTCBCur->OSTCBY;
    1acc:	1f 42 54 03 	mov	&0x0354,r15	
    1ad0:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    1ad4:	00 00 
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
    1ad6:	6d 44       	mov.b	@r4,	r13	
    1ad8:	6e 44       	mov.b	@r4,	r14	
    1ada:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ade:	0f 5e       	add	r14,	r15	
    1ae0:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1ae4:	6f 4f       	mov.b	@r15,	r15	
    1ae6:	4e 4f       	mov.b	r15,	r14	
    1ae8:	1f 42 54 03 	mov	&0x0354,r15	
    1aec:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1af0:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1af2:	4f fe       	and.b	r14,	r15	
    1af4:	4e 4f       	mov.b	r15,	r14	
    1af6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1afa:	0f 5d       	add	r13,	r15	
    1afc:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b00:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    if (pevent->OSEventTbl[y] == 0x00) {
    1b04:	6e 44       	mov.b	@r4,	r14	
    1b06:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b0a:	0f 5e       	add	r14,	r15	
    1b0c:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b10:	6f 4f       	mov.b	@r15,	r15	
    1b12:	4f 93       	tst.b	r15		
    1b14:	10 20       	jnz	$+34     	;abs 0x1b36
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
    1b16:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b1a:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    1b1e:	4e 4f       	mov.b	r15,	r14	
    1b20:	1f 42 54 03 	mov	&0x0354,r15	
    1b24:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1b28:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1b2a:	4f fe       	and.b	r14,	r15	
    1b2c:	4e 4f       	mov.b	r15,	r14	
    1b2e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b32:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
    }
    OSTCBCur->OSTCBPendTO   = FALSE;                   /* Clear the Pend Timeout flag                  */
    1b36:	1f 42 54 03 	mov	&0x0354,r15	
    1b3a:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
    1b3e:	1f 42 54 03 	mov	&0x0354,r15	
    1b42:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
    1b46:	1f 42 54 03 	mov	&0x0354,r15	
    1b4a:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
}
    1b4e:	21 52       	add	#4,	r1	;r2 As==10
    1b50:	34 41       	pop	r4		
    1b52:	30 41       	ret			

00001b54 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
    1b54:	04 12       	push	r4		
    1b56:	21 82       	sub	#4,	r1	;r2 As==10
    1b58:	04 41       	mov	r1,	r4	
    1b5a:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  *ptbl;


    pevent->OSEventGrp = 0x00;                   /* No task waiting on event                           */
    1b5e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b62:	cf 43 01 00 	mov.b	#0,	1(r15)	;r3 As==00, 0x0001(r15)
    ptbl               = &pevent->OSEventTbl[0];
    1b66:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b6a:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b6e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)

#if OS_EVENT_TBL_SIZE > 0
    *ptbl++            = 0x00;
    1b72:	2f 44       	mov	@r4,	r15	
    1b74:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1b78:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 1
    *ptbl++            = 0x00;
    1b7c:	2f 44       	mov	@r4,	r15	
    1b7e:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1b82:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 7
    *ptbl              = 0x00;
#endif
}
    1b86:	21 52       	add	#4,	r1	;r2 As==10
    1b88:	34 41       	pop	r4		
    1b8a:	30 41       	ret			

00001b8c <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
    1b8c:	04 12       	push	r4		
    1b8e:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1b92:	04 41       	mov	r1,	r4	
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    1b94:	3f 40 d6 03 	mov	#982,	r15	;#0x03d6
    1b98:	3e 40 28 00 	mov	#40,	r14	;#0x0028
    1b9c:	b0 12 f8 1c 	call	#0x1cf8	
    pevent1 = &OSEventTbl[0];
    1ba0:	b4 40 d6 03 	mov	#982,	2(r4)	;#0x03d6, 0x0002(r4)
    1ba4:	02 00 
    pevent2 = &OSEventTbl[1];
    1ba6:	b4 40 de 03 	mov	#990,	0(r4)	;#0x03de, 0x0000(r4)
    1baa:	00 00 
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
    1bac:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    1bb0:	0e 3c       	jmp	$+30     	;abs 0x1bce
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
    1bb2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bb6:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        pevent1->OSEventPtr     = pevent2;
    1bba:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bbe:	af 44 04 00 	mov	@r4,	4(r15)	;0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
    1bc2:	b4 52 02 00 	add	#8,	2(r4)	;r2 As==11, 0x0002(r4)
        pevent2++;
    1bc6:	b4 52 00 00 	add	#8,	0(r4)	;r2 As==11, 0x0000(r4)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
    1bca:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    1bce:	a4 92 04 00 	cmp	#4,	4(r4)	;r2 As==10, 0x0004(r4)
    1bd2:	ef 2b       	jnc	$-32     	;abs 0x1bb2
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
    1bd4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bd8:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
    1bdc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1be0:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';                  
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
#endif
    OSEventFreeList                 = &OSEventTbl[0];
    1be4:	b2 40 d6 03 	mov	#982,	&0x0350	;#0x03d6
    1be8:	50 03 
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
    1bea:	31 50 06 00 	add	#6,	r1	;#0x0006
    1bee:	34 41       	pop	r4		
    1bf0:	30 41       	ret			

00001bf2 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
    1bf2:	04 12       	push	r4		
    1bf4:	04 41       	mov	r1,	r4	
#if OS_TIME_GET_SET_EN > 0   
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
    1bf6:	c2 43 52 03 	mov.b	#0,	&0x0352	;r3 As==00
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
    1bfa:	c2 43 04 03 	mov.b	#0,	&0x0304	;r3 As==00

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
    1bfe:	c2 43 2a 03 	mov.b	#0,	&0x032a	;r3 As==00

    OSRunning     = FALSE;                                 /* Indicate that multitasking not started   */
    1c02:	c2 43 05 03 	mov.b	#0,	&0x0305	;r3 As==00
    
    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
    1c06:	82 43 24 03 	mov	#0,	&0x0324	;r3 As==00
    1c0a:	82 43 26 03 	mov	#0,	&0x0326	;r3 As==00
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
    1c0e:	82 43 06 03 	mov	#0,	&0x0306	;r3 As==00
    1c12:	82 43 08 03 	mov	#0,	&0x0308	;r3 As==00
#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
    OSIdleCtrMax  = 0L;
    OSStatRdy     = FALSE;                                 /* Statistic task is not ready              */
#endif
}
    1c16:	34 41       	pop	r4		
    1c18:	30 41       	ret			

00001c1a <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
    1c1a:	04 12       	push	r4		
    1c1c:	21 82       	sub	#4,	r1	;r2 As==10
    1c1e:	04 41       	mov	r1,	r4	
    INT8U    i;
    INT8U   *prdytbl;


    OSRdyGrp      = 0x00;                                  /* Clear the ready list                     */
    1c20:	c2 43 4c 03 	mov.b	#0,	&0x034c	;r3 As==00
    prdytbl       = &OSRdyTbl[0];
    1c24:	b4 40 4e 03 	mov	#846,	0(r4)	;#0x034e, 0x0000(r4)
    1c28:	00 00 
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
    1c2a:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    1c2e:	07 3c       	jmp	$+16     	;abs 0x1c3e
        *prdytbl++ = 0x00;
    1c30:	2f 44       	mov	@r4,	r15	
    1c32:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1c36:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    INT8U   *prdytbl;


    OSRdyGrp      = 0x00;                                  /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
    1c3a:	d4 53 02 00 	inc.b	2(r4)		;0x0002(r4)
    1c3e:	e4 93 02 00 	cmp.b	#2,	2(r4)	;r3 As==10, 0x0002(r4)
    1c42:	f6 2b       	jnc	$-18     	;abs 0x1c30
        *prdytbl++ = 0x00;
    }

    OSPrioCur     = 0;
    1c44:	c2 43 1e 03 	mov.b	#0,	&0x031e	;r3 As==00
    OSPrioHighRdy = 0;
    1c48:	c2 43 0a 03 	mov.b	#0,	&0x030a	;r3 As==00

    OSTCBHighRdy  = (OS_TCB *)0;                                 
    1c4c:	82 43 48 03 	mov	#0,	&0x0348	;r3 As==00
    OSTCBCur      = (OS_TCB *)0;
    1c50:	82 43 54 03 	mov	#0,	&0x0354	;r3 As==00
}
    1c54:	21 52       	add	#4,	r1	;r2 As==10
    1c56:	34 41       	pop	r4		
    1c58:	30 41       	ret			

00001c5a <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
    1c5a:	04 12       	push	r4		
    1c5c:	04 41       	mov	r1,	r4	
#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
    1c5e:	7e 40 0a 00 	mov.b	#10,	r14	;#0x000a
    1c62:	3f 40 d4 03 	mov	#980,	r15	;#0x03d4
    1c66:	30 12 03 00 	push	#3		;#0x0003
    1c6a:	03 12       	push	#0		;r3 As==00
    1c6c:	03 12       	push	#0		;r3 As==00
    1c6e:	30 12 40 00 	push	#64		;#0x0040
    1c72:	30 12 56 03 	push	#854		;#0x0356
    1c76:	33 12       	push	#-1		;r3 As==11
    1c78:	4c 4e       	mov.b	r14,	r12	
    1c7a:	0d 4f       	mov	r15,	r13	
    1c7c:	0e 43       	clr	r14		
    1c7e:	3f 40 06 1e 	mov	#7686,	r15	;#0x1e06
    1c82:	b0 12 c0 37 	call	#0x37c0	
    1c86:	31 50 0c 00 	add	#12,	r1	;#0x000c
                       (void *)0,
                       &OSTaskIdleStk[0],
                       OS_IDLE_PRIO);
    #endif
#endif
}
    1c8a:	34 41       	pop	r4		
    1c8c:	30 41       	ret			

00001c8e <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
    1c8e:	04 12       	push	r4		
    1c90:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1c94:	04 41       	mov	r1,	r4	
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    1c96:	3f 40 fe 03 	mov	#1022,	r15	;#0x03fe
    1c9a:	3e 40 d4 01 	mov	#468,	r14	;#0x01d4
    1c9e:	b0 12 f8 1c 	call	#0x1cf8	
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    1ca2:	3f 40 d4 05 	mov	#1492,	r15	;#0x05d4
    1ca6:	3e 40 16 00 	mov	#22,	r14	;#0x0016
    1caa:	b0 12 f8 1c 	call	#0x1cf8	
    ptcb1 = &OSTCBTbl[0];
    1cae:	b4 40 fe 03 	mov	#1022,	2(r4)	;#0x03fe, 0x0002(r4)
    1cb2:	02 00 
    ptcb2 = &OSTCBTbl[1];
    1cb4:	b4 40 32 04 	mov	#1074,	0(r4)	;#0x0432, 0x0000(r4)
    1cb8:	00 00 
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
    1cba:	c4 43 04 00 	mov.b	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    1cbe:	0c 3c       	jmp	$+26     	;abs 0x1cd8
        ptcb1->OSTCBNext = ptcb2;
    1cc0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1cc4:	af 44 0e 00 	mov	@r4,	14(r15)	;0x000e(r15)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
    1cc8:	b4 50 34 00 	add	#52,	2(r4)	;#0x0034, 0x0002(r4)
    1ccc:	02 00 
        ptcb2++;
    1cce:	b4 50 34 00 	add	#52,	0(r4)	;#0x0034, 0x0000(r4)
    1cd2:	00 00 

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
    1cd4:	d4 53 04 00 	inc.b	4(r4)		;0x0004(r4)
    1cd8:	f4 92 04 00 	cmp.b	#8,	4(r4)	;r2 As==11, 0x0004(r4)
    1cdc:	f1 2b       	jnc	$-28     	;abs 0x1cc0
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
    1cde:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ce2:	8f 43 0e 00 	mov	#0,	14(r15)	;r3 As==00, 0x000e(r15)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
    1ce6:	82 43 20 03 	mov	#0,	&0x0320	;r3 As==00
    OSTCBFreeList           = &OSTCBTbl[0];
    1cea:	b2 40 fe 03 	mov	#1022,	&0x0328	;#0x03fe
    1cee:	28 03 
}
    1cf0:	31 50 06 00 	add	#6,	r1	;#0x0006
    1cf4:	34 41       	pop	r4		
    1cf6:	30 41       	ret			

00001cf8 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    1cf8:	04 12       	push	r4		
    1cfa:	21 82       	sub	#4,	r1	;r2 As==10
    1cfc:	04 41       	mov	r1,	r4	
    1cfe:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    1d02:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    1d06:	07 3c       	jmp	$+16     	;abs 0x1d16
    while (size > 0) {
        *pdest++ = (INT8U)0;
    1d08:	2f 44       	mov	@r4,	r15	
    1d0a:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1d0e:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
        size--;
    1d12:	b4 53 02 00 	add	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
    1d16:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    1d1a:	f6 23       	jnz	$-18     	;abs 0x1d08
        *pdest++ = (INT8U)0;
        size--;
    }
}
    1d1c:	21 52       	add	#4,	r1	;r2 As==10
    1d1e:	34 41       	pop	r4		
    1d20:	30 41       	ret			

00001d22 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    1d22:	04 12       	push	r4		
    1d24:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1d28:	04 41       	mov	r1,	r4	
    1d2a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    1d2e:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    1d32:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
    1d36:	0c 3c       	jmp	$+26     	;abs 0x1d50
    while (size > 0) {
        *pdest++ = *psrc++;
    1d38:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1d3c:	6e 4f       	mov.b	@r15,	r14	
    1d3e:	2f 44       	mov	@r4,	r15	
    1d40:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    1d44:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    1d48:	94 53 02 00 	inc	2(r4)		;0x0002(r4)
        size--;
    1d4c:	b4 53 04 00 	add	#-1,	4(r4)	;r3 As==11, 0x0004(r4)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
    1d50:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    1d54:	f1 23       	jnz	$-28     	;abs 0x1d38
        *pdest++ = *psrc++;
        size--;
    }
}
    1d56:	31 50 06 00 	add	#6,	r1	;#0x0006
    1d5a:	34 41       	pop	r4		
    1d5c:	30 41       	ret			

00001d5e <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
    1d5e:	04 12       	push	r4		
    1d60:	21 82       	sub	#4,	r1	;r2 As==10
    1d62:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    1d64:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    1d68:	b0 12 ca 13 	call	#0x13ca	
    1d6c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
    1d70:	5f 42 52 03 	mov.b	&0x0352,r15	
    1d74:	4f 93       	tst.b	r15		
    1d76:	41 20       	jnz	$+132    	;abs 0x1dfa
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
    1d78:	5f 42 04 03 	mov.b	&0x0304,r15	
    1d7c:	4f 93       	tst.b	r15		
    1d7e:	3d 20       	jnz	$+124    	;abs 0x1dfa
            y             = OSUnMapTbl[OSRdyGrp];      /* Get pointer to HPT ready to run              */
    1d80:	5f 42 4c 03 	mov.b	&0x034c,r15	
    1d84:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1d86:	d4 4f 1c 15 	mov.b	5404(r15),2(r4)	;0x151c(r15), 0x0002(r4)
    1d8a:	02 00 
            OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
    1d8c:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1d90:	4f 5f       	rla.b	r15		
    1d92:	4f 5f       	rla.b	r15		
    1d94:	4f 5f       	rla.b	r15		
    1d96:	4e 4f       	mov.b	r15,	r14	
    1d98:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1d9c:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    1da0:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1da2:	5f 4f 1c 15 	mov.b	5404(r15),r15	;0x151c(r15)
    1da6:	4f 5e       	add.b	r14,	r15	
    1da8:	c2 4f 0a 03 	mov.b	r15,	&0x030a	
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
    1dac:	5e 42 0a 03 	mov.b	&0x030a,r14	
    1db0:	5f 42 1e 03 	mov.b	&0x031e,r15	
    1db4:	4e 9f       	cmp.b	r15,	r14	
    1db6:	21 24       	jz	$+68     	;abs 0x1dfa
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
    1db8:	5f 42 0a 03 	mov.b	&0x030a,r15	
    1dbc:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1dbe:	0f 5f       	rla	r15		
    1dc0:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    1dc4:	2f 4f       	mov	@r15,	r15	
    1dc6:	82 4f 48 03 	mov	r15,	&0x0348	
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
    1dca:	1d 42 48 03 	mov	&0x0348,r13	
    1dce:	1e 4d 22 00 	mov	34(r13),r14	;0x0022(r13)
    1dd2:	1f 4d 24 00 	mov	36(r13),r15	;0x0024(r13)
    1dd6:	1e 53       	inc	r14		
    1dd8:	0f 63       	adc	r15		
    1dda:	8d 4e 22 00 	mov	r14,	34(r13)	;0x0022(r13)
    1dde:	8d 4f 24 00 	mov	r15,	36(r13)	;0x0024(r13)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
    1de2:	1e 42 24 03 	mov	&0x0324,r14	
    1de6:	1f 42 26 03 	mov	&0x0326,r15	
    1dea:	1e 53       	inc	r14		
    1dec:	0f 63       	adc	r15		
    1dee:	82 4e 24 03 	mov	r14,	&0x0324	
    1df2:	82 4f 26 03 	mov	r15,	&0x0326	
                OS_TASK_SW();                          /* Perform a context switch                     */
    1df6:	b0 12 e2 12 	call	#0x12e2	
            }
        }
    }
    OS_EXIT_CRITICAL();
    1dfa:	2f 44       	mov	@r4,	r15	
    1dfc:	b0 12 d0 13 	call	#0x13d0	
}
    1e00:	21 52       	add	#4,	r1	;r2 As==10
    1e02:	34 41       	pop	r4		
    1e04:	30 41       	ret			

00001e06 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *parg)
{
    1e06:	04 12       	push	r4		
    1e08:	21 82       	sub	#4,	r1	;r2 As==10
    1e0a:	04 41       	mov	r1,	r4	
    1e0c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    1e10:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    parg   = parg;                               /* Prevent compiler warning for not using 'parg'      */
    for (;;) {
        OS_ENTER_CRITICAL();
    1e14:	b0 12 ca 13 	call	#0x13ca	
    1e18:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        OSIdleCtr++;
    1e1c:	1e 42 06 03 	mov	&0x0306,r14	
    1e20:	1f 42 08 03 	mov	&0x0308,r15	
    1e24:	1e 53       	inc	r14		
    1e26:	0f 63       	adc	r15		
    1e28:	82 4e 06 03 	mov	r14,	&0x0306	
    1e2c:	82 4f 08 03 	mov	r15,	&0x0308	
        OS_EXIT_CRITICAL();
    1e30:	2f 44       	mov	@r4,	r15	
    1e32:	b0 12 d0 13 	call	#0x13d0	
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
    1e36:	b0 12 04 14 	call	#0x1404	
    1e3a:	ec 3f       	jmp	$-38     	;abs 0x1e14

00001e3c <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
    1e3c:	04 12       	push	r4		
    1e3e:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    1e42:	04 41       	mov	r1,	r4	
    1e44:	c4 4f 04 00 	mov.b	r15,	4(r4)	;0x0004(r4)
    1e48:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    1e4c:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
    1e50:	84 4c 0a 00 	mov	r12,	10(r4)	;0x000a(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    1e54:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    1e58:	b0 12 ca 13 	call	#0x13ca	
    1e5c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    1e60:	94 42 28 03 	mov	&0x0328,2(r4)	;0x0002(r4)
    1e64:	02 00 
    if (ptcb != (OS_TCB *)0) {
    1e66:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    1e6a:	d7 24       	jz	$+432    	;abs 0x201a
        OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
    1e6c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1e70:	1f 4f 0e 00 	mov	14(r15),r15	;0x000e(r15)
    1e74:	82 4f 28 03 	mov	r15,	&0x0328	
        OS_EXIT_CRITICAL();
    1e78:	2f 44       	mov	@r4,	r15	
    1e7a:	b0 12 d0 13 	call	#0x13d0	
        ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
    1e7e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1e82:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    1e86:	00 00 
        ptcb->OSTCBPrio      = prio;                       /* Load task priority into TCB              */
    1e88:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1e8c:	df 44 04 00 	mov.b	4(r4),	28(r15)	;0x0004(r4), 0x001c(r15)
    1e90:	1c 00 
        ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
    1e92:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1e96:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
        ptcb->OSTCBPendTO    = FALSE;                      /* Clear the Pend timeout flag              */
    1e9a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1e9e:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
        ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */
    1ea2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ea6:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
    1eaa:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1eae:	9f 44 14 00 	mov	20(r4),	2(r15)	;0x0014(r4), 0x0002(r15)
    1eb2:	02 00 
        ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
    1eb4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1eb8:	9f 44 10 00 	mov	16(r4),	6(r15)	;0x0010(r4), 0x0006(r15)
    1ebc:	06 00 
    1ebe:	9f 44 12 00 	mov	18(r4),	8(r15)	;0x0012(r4), 0x0008(r15)
    1ec2:	08 00 
        ptcb->OSTCBStkBottom = pbos;                       /* Store pointer to bottom of stack         */
    1ec4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ec8:	9f 44 08 00 	mov	8(r4),	4(r15)	;0x0008(r4), 0x0004(r15)
    1ecc:	04 00 
        ptcb->OSTCBOpt       = opt;                        /* Store task options                       */
    1ece:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ed2:	9f 44 16 00 	mov	22(r4),	10(r15)	;0x0016(r4), 0x000a(r15)
    1ed6:	0a 00 
        ptcb->OSTCBId        = id;                         /* Store task ID                            */
    1ed8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1edc:	9f 44 0a 00 	mov	10(r4),	12(r15)	;0x000a(r4), 0x000c(r15)
    1ee0:	0c 00 

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq    = OS_NO_ERR;
#endif

        ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
    1ee2:	5e 44 04 00 	mov.b	4(r4),	r14	;0x0004(r4)
    1ee6:	12 c3       	clrc			
    1ee8:	4e 10       	rrc.b	r14		
    1eea:	4e 11       	rra.b	r14		
    1eec:	4e 11       	rra.b	r14		
    1eee:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ef2:	cf 4e 1e 00 	mov.b	r14,	30(r15)	;0x001e(r15)
        ptcb->OSTCBBitY      = OSMapTbl[ptcb->OSTCBY];
    1ef6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1efa:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1efe:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1f00:	5e 4f 14 15 	mov.b	5396(r15),r14	;0x1514(r15)
    1f04:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f08:	cf 4e 20 00 	mov.b	r14,	32(r15)	;0x0020(r15)
        ptcb->OSTCBX         = (INT8U)(prio & 0x07);
    1f0c:	5e 44 04 00 	mov.b	4(r4),	r14	;0x0004(r4)
    1f10:	7e f0 07 00 	and.b	#7,	r14	;#0x0007
    1f14:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f18:	cf 4e 1d 00 	mov.b	r14,	29(r15)	;0x001d(r15)
        ptcb->OSTCBBitX      = OSMapTbl[ptcb->OSTCBX];
    1f1c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f20:	5f 4f 1d 00 	mov.b	29(r15),r15	;0x001d(r15)
    1f24:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1f26:	5e 4f 14 15 	mov.b	5396(r15),r14	;0x1514(r15)
    1f2a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f2e:	cf 4e 1f 00 	mov.b	r14,	31(r15)	;0x001f(r15)

#if OS_EVENT_EN
        ptcb->OSTCBEventPtr  = (OS_EVENT *)0;              /* Task is not pending on an event          */
    1f32:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f36:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
    1f3a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f3e:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
    1f42:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f46:	8f 43 22 00 	mov	#0,	34(r15)	;r3 As==00, 0x0022(r15)
    1f4a:	8f 43 24 00 	mov	#0,	36(r15)	;r3 As==00, 0x0024(r15)
        ptcb->OSTCBCyclesStart = 0L;
    1f4e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f52:	8f 43 2a 00 	mov	#0,	42(r15)	;r3 As==00, 0x002a(r15)
    1f56:	8f 43 2c 00 	mov	#0,	44(r15)	;r3 As==00, 0x002c(r15)
        ptcb->OSTCBCyclesTot   = 0L;
    1f5a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f5e:	8f 43 26 00 	mov	#0,	38(r15)	;r3 As==00, 0x0026(r15)
    1f62:	8f 43 28 00 	mov	#0,	40(r15)	;r3 As==00, 0x0028(r15)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
    1f66:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f6a:	8f 43 2e 00 	mov	#0,	46(r15)	;r3 As==00, 0x002e(r15)
        ptcb->OSTCBStkUsed     = 0L;
    1f6e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f72:	8f 43 30 00 	mov	#0,	48(r15)	;r3 As==00, 0x0030(r15)
    1f76:	8f 43 32 00 	mov	#0,	50(r15)	;r3 As==00, 0x0032(r15)
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif

#if OS_VERSION >= 204
        OSTCBInitHook(ptcb);
    1f7a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f7e:	b0 12 fc 14 	call	#0x14fc	
#endif

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
    1f82:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f86:	b0 12 e4 13 	call	#0x13e4	
        
        OS_ENTER_CRITICAL();
    1f8a:	b0 12 ca 13 	call	#0x13ca	
    1f8e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        OSTCBPrioTbl[prio] = ptcb;
    1f92:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    1f96:	0f 5f       	rla	r15		
    1f98:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    1f9c:	9f 44 02 00 	mov	2(r4),	0(r15)	;0x0002(r4), 0x0000(r15)
    1fa0:	00 00 
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
    1fa2:	1e 42 20 03 	mov	&0x0320,r14	
    1fa6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1faa:	8f 4e 0e 00 	mov	r14,	14(r15)	;0x000e(r15)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
    1fae:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fb2:	8f 43 10 00 	mov	#0,	16(r15)	;r3 As==00, 0x0010(r15)
        if (OSTCBList != (OS_TCB *)0) {
    1fb6:	1f 42 20 03 	mov	&0x0320,r15	
    1fba:	0f 93       	tst	r15		
    1fbc:	05 24       	jz	$+12     	;abs 0x1fc8
            OSTCBList->OSTCBPrev = ptcb;
    1fbe:	1f 42 20 03 	mov	&0x0320,r15	
    1fc2:	9f 44 02 00 	mov	2(r4),	16(r15)	;0x0002(r4), 0x0010(r15)
    1fc6:	10 00 
        }
        OSTCBList               = ptcb;
    1fc8:	92 44 02 00 	mov	2(r4),	&0x0320	;0x0002(r4)
    1fcc:	20 03 
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
    1fce:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fd2:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    1fd6:	5f 42 4c 03 	mov.b	&0x034c,r15	
    1fda:	4f de       	bis.b	r14,	r15	
    1fdc:	c2 4f 4c 03 	mov.b	r15,	&0x034c	
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    1fe0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fe4:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1fe8:	4d 4f       	mov.b	r15,	r13	
    1fea:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fee:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1ff2:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1ff4:	5e 4f 4e 03 	mov.b	846(r15),r14	;0x034e(r15)
    1ff8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ffc:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    2000:	4f de       	bis.b	r14,	r15	
    2002:	cd 4f 4e 03 	mov.b	r15,	846(r13);0x034e(r13)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
    2006:	5f 42 2a 03 	mov.b	&0x032a,r15	
    200a:	5f 53       	inc.b	r15		
    200c:	c2 4f 2a 03 	mov.b	r15,	&0x032a	
        OS_EXIT_CRITICAL();
    2010:	2f 44       	mov	@r4,	r15	
    2012:	b0 12 d0 13 	call	#0x13d0	
        return (OS_NO_ERR);
    2016:	4f 43       	clr.b	r15		
    2018:	05 3c       	jmp	$+12     	;abs 0x2024
    }
    OS_EXIT_CRITICAL();
    201a:	2f 44       	mov	@r4,	r15	
    201c:	b0 12 d0 13 	call	#0x13d0	
    return (OS_NO_MORE_TCB);
    2020:	7f 40 46 00 	mov.b	#70,	r15	;#0x0046
}
    2024:	31 50 0c 00 	add	#12,	r1	;#0x000c
    2028:	34 41       	pop	r4		
    202a:	30 41       	ret			

0000202c <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *err)
{
    202c:	04 12       	push	r4		
    202e:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    2032:	04 41       	mov	r1,	r4	
    2034:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2038:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    203c:	c4 4d 0a 00 	mov.b	r13,	10(r4)	;0x000a(r4)
    2040:	84 4c 0c 00 	mov	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    2044:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
    2048:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    204c:	6f 4f       	mov.b	@r15,	r15	
    204e:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    2052:	06 24       	jz	$+14     	;abs 0x2060
        *err = OS_ERR_EVENT_TYPE;
    2054:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2058:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    205c:	0f 43       	clr	r15		
    205e:	77 3c       	jmp	$+240    	;abs 0x214e
    }
    if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
    2060:	5f 44 0a 00 	mov.b	10(r4),	r15	;0x000a(r4)
    2064:	4f 93       	tst.b	r15		
    2066:	06 34       	jge	$+14     	;abs 0x2074
        wait_type &= ~OS_FLAG_CONSUME;
    2068:	f4 f0 7f 00 	and.b	#127,	10(r4)	;#0x007f, 0x000a(r4)
    206c:	0a 00 
        consume    = TRUE;
    206e:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2072:	02 3c       	jmp	$+6      	;abs 0x2078
    } else {
        consume    = FALSE;
    2074:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    }
/*$PAGE*/
    *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwise.  */
    2078:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    207c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OS_ENTER_CRITICAL();
    2080:	b0 12 ca 13 	call	#0x13ca	
    2084:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (wait_type) {
    2088:	5f 44 0a 00 	mov.b	10(r4),	r15	;0x000a(r4)
    208c:	2f 93       	cmp	#2,	r15	;r3 As==10
    208e:	04 24       	jz	$+10     	;abs 0x2098
    2090:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    2094:	29 24       	jz	$+84     	;abs 0x20e8
    2096:	4f 3c       	jmp	$+160    	;abs 0x2136
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    2098:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    209c:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    20a0:	0e 4f       	mov	r15,	r14	
    20a2:	1e f4 08 00 	and	8(r4),	r14	;0x0008(r4)
    20a6:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    20aa:	94 94 08 00 	cmp	8(r4),	4(r4)	;0x0008(r4), 0x0004(r4)
    20ae:	04 00 
    20b0:	10 20       	jnz	$+34     	;abs 0x20d2
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    20b2:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    20b6:	13 20       	jnz	$+40     	;abs 0x20de
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    20b8:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    20bc:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    20c0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    20c4:	3f e3       	inv	r15		
    20c6:	0e ff       	and	r15,	r14	
    20c8:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    20cc:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    20d0:	07 3c       	jmp	$+16     	;abs 0x20e0
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
    20d2:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    20d6:	ff 40 98 ff 	mov.b	#-104,	0(r15)	;#0xff98, 0x0000(r15)
    20da:	00 00 
    20dc:	01 3c       	jmp	$+4      	;abs 0x20e0
    switch (wait_type) {
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    20de:	03 43       	nop			
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
    20e0:	2f 44       	mov	@r4,	r15	
    20e2:	b0 12 d0 13 	call	#0x13d0	
    20e6:	31 3c       	jmp	$+100    	;abs 0x214a
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    20e8:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    20ec:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    20f0:	0e 4f       	mov	r15,	r14	
    20f2:	1e f4 08 00 	and	8(r4),	r14	;0x0008(r4)
    20f6:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    20fa:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    20fe:	10 24       	jz	$+34     	;abs 0x2120
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    2100:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2104:	13 20       	jnz	$+40     	;abs 0x212c
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    2106:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    210a:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    210e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2112:	3f e3       	inv	r15		
    2114:	0e ff       	and	r15,	r14	
    2116:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    211a:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    211e:	07 3c       	jmp	$+16     	;abs 0x212e
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
    2120:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2124:	ff 40 98 ff 	mov.b	#-104,	0(r15)	;#0xff98, 0x0000(r15)
    2128:	00 00 
    212a:	01 3c       	jmp	$+4      	;abs 0x212e

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    212c:	03 43       	nop			
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
    212e:	2f 44       	mov	@r4,	r15	
    2130:	b0 12 d0 13 	call	#0x13d0	
    2134:	0a 3c       	jmp	$+22     	;abs 0x214a
             OS_EXIT_CRITICAL();
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
    2136:	2f 44       	mov	@r4,	r15	
    2138:	b0 12 d0 13 	call	#0x13d0	
             flags_rdy = (OS_FLAGS)0;
    213c:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
             *err      = OS_FLAG_ERR_WAIT_TYPE;
    2140:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2144:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    2148:	00 00 
             break;
    }
    return (flags_rdy);
    214a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    214e:	31 50 0e 00 	add	#14,	r1	;#0x000e
    2152:	34 41       	pop	r4		
    2154:	30 41       	ret			

00002156 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *err)
{
    2156:	04 12       	push	r4		
    2158:	31 82       	sub	#8,	r1	;r2 As==11
    215a:	04 41       	mov	r1,	r4	
    215c:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2160:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr;



    cpu_sr = 0;                                     /* Prevent compiler warning                        */
    2164:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
    2168:	5f 42 52 03 	mov.b	&0x0352,r15	
    216c:	4f 93       	tst.b	r15		
    216e:	07 24       	jz	$+16     	;abs 0x217e
        *err = OS_ERR_CREATE_ISR;                   /* ... can't CREATE from an ISR                    */
    2170:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2174:	ff 40 8d ff 	mov.b	#-115,	0(r15)	;#0xff8d, 0x0000(r15)
    2178:	00 00 
        return ((OS_FLAG_GRP *)0);
    217a:	0f 43       	clr	r15		
    217c:	30 3c       	jmp	$+98     	;abs 0x21de
    }
    OS_ENTER_CRITICAL();
    217e:	b0 12 ca 13 	call	#0x13ca	
    2182:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
    2186:	94 42 d2 05 	mov	&0x05d2,2(r4)	;0x0002(r4)
    218a:	02 00 
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
    218c:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2190:	1c 24       	jz	$+58     	;abs 0x21ca
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
    2192:	1f 42 d2 05 	mov	&0x05d2,r15	
    2196:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    219a:	82 4f d2 05 	mov	r15,	&0x05d2	
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
    219e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    21a2:	ff 40 05 00 	mov.b	#5,	0(r15)	;#0x0005, 0x0000(r15)
    21a6:	00 00 
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
    21a8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    21ac:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    21b0:	04 00 
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
    21b2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    21b6:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        OS_EXIT_CRITICAL();
    21ba:	2f 44       	mov	@r4,	r15	
    21bc:	b0 12 d0 13 	call	#0x13d0	
        *err                 = OS_NO_ERR;
    21c0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    21c4:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    21c8:	08 3c       	jmp	$+18     	;abs 0x21da
    } else {
        OS_EXIT_CRITICAL();
    21ca:	2f 44       	mov	@r4,	r15	
    21cc:	b0 12 d0 13 	call	#0x13d0	
        *err                 = OS_FLAG_GRP_DEPLETED;
    21d0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    21d4:	ff 40 9a ff 	mov.b	#-102,	0(r15)	;#0xff9a, 0x0000(r15)
    21d8:	00 00 
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
    21da:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    21de:	31 52       	add	#8,	r1	;r2 As==11
    21e0:	34 41       	pop	r4		
    21e2:	30 41       	ret			

000021e4 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *err)
{
    21e4:	04 12       	push	r4		
    21e6:	31 50 e6 ff 	add	#-26,	r1	;#0xffe6
    21ea:	04 41       	mov	r1,	r4	
    21ec:	84 4f 12 00 	mov	r15,	18(r4)	;0x0012(r4)
    21f0:	84 4e 14 00 	mov	r14,	20(r4)	;0x0014(r4)
    21f4:	c4 4d 16 00 	mov.b	r13,	22(r4)	;0x0016(r4)
    21f8:	84 4c 18 00 	mov	r12,	24(r4)	;0x0018(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    21fc:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
    2200:	5f 42 52 03 	mov.b	&0x0352,r15	
    2204:	4f 93       	tst.b	r15		
    2206:	06 24       	jz	$+14     	;abs 0x2214
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
    2208:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    220c:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((OS_FLAGS)0);
    2210:	0f 43       	clr	r15		
    2212:	fd 3c       	jmp	$+508    	;abs 0x240e
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
    2214:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2218:	6f 4f       	mov.b	@r15,	r15	
    221a:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    221e:	06 24       	jz	$+14     	;abs 0x222c
        *err = OS_ERR_EVENT_TYPE;
    2220:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2224:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    2228:	0f 43       	clr	r15		
    222a:	f1 3c       	jmp	$+484    	;abs 0x240e
    }
    if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
    222c:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    2230:	4f 93       	tst.b	r15		
    2232:	06 34       	jge	$+14     	;abs 0x2240
        wait_type &= ~OS_FLAG_CONSUME;
    2234:	f4 f0 7f 00 	and.b	#127,	22(r4)	;#0x007f, 0x0016(r4)
    2238:	16 00 
        consume    = TRUE;
    223a:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    223e:	02 3c       	jmp	$+6      	;abs 0x2244
    } else {
        consume    = FALSE;
    2240:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    2244:	b0 12 ca 13 	call	#0x13ca	
    2248:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (wait_type) {
    224c:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    2250:	2f 93       	cmp	#2,	r15	;r3 As==10
    2252:	04 24       	jz	$+10     	;abs 0x225c
    2254:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    2258:	3e 24       	jz	$+126    	;abs 0x22d6
    225a:	79 3c       	jmp	$+244    	;abs 0x234e
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    225c:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2260:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2264:	0e 4f       	mov	r15,	r14	
    2266:	1e f4 14 00 	and	20(r4),	r14	;0x0014(r4)
    226a:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    226e:	94 94 14 00 	cmp	20(r4),	4(r4)	;0x0014(r4), 0x0004(r4)
    2272:	04 00 
    2274:	1e 20       	jnz	$+62     	;abs 0x22b2
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    2276:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    227a:	0c 20       	jnz	$+26     	;abs 0x2294
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    227c:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2280:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2284:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2288:	3f e3       	inv	r15		
    228a:	0e ff       	and	r15,	r14	
    228c:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2290:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    2294:	1f 42 54 03 	mov	&0x0354,r15	
    2298:	9f 44 04 00 	mov	4(r4),	22(r15)	;0x0004(r4), 0x0016(r15)
    229c:	16 00 
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    229e:	2f 44       	mov	@r4,	r15	
    22a0:	b0 12 d0 13 	call	#0x13d0	
                 *err                    = OS_NO_ERR;
    22a4:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    22a8:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
                 return (flags_rdy);
    22ac:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    22b0:	ae 3c       	jmp	$+350    	;abs 0x240e
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    22b2:	5c 44 16 00 	mov.b	22(r4),	r12	;0x0016(r4)
    22b6:	1d 44 14 00 	mov	20(r4),	r13	;0x0014(r4)
    22ba:	0e 44       	mov	r4,	r14	
    22bc:	3e 50 06 00 	add	#6,	r14	;#0x0006
    22c0:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22c4:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    22c8:	b0 12 e4 25 	call	#0x25e4	
    22cc:	21 53       	incd	r1		
                 OS_EXIT_CRITICAL();
    22ce:	2f 44       	mov	@r4,	r15	
    22d0:	b0 12 d0 13 	call	#0x13d0	
    22d4:	49 3c       	jmp	$+148    	;abs 0x2368
             }
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    22d6:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22da:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    22de:	0e 4f       	mov	r15,	r14	
    22e0:	1e f4 14 00 	and	20(r4),	r14	;0x0014(r4)
    22e4:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    22e8:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    22ec:	1e 24       	jz	$+62     	;abs 0x232a
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    22ee:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    22f2:	0c 20       	jnz	$+26     	;abs 0x230c
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    22f4:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22f8:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    22fc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2300:	3f e3       	inv	r15		
    2302:	0e ff       	and	r15,	r14	
    2304:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2308:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    230c:	1f 42 54 03 	mov	&0x0354,r15	
    2310:	9f 44 04 00 	mov	4(r4),	22(r15)	;0x0004(r4), 0x0016(r15)
    2314:	16 00 
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    2316:	2f 44       	mov	@r4,	r15	
    2318:	b0 12 d0 13 	call	#0x13d0	
                 *err                    = OS_NO_ERR;
    231c:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2320:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
                 return (flags_rdy);
    2324:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2328:	72 3c       	jmp	$+230    	;abs 0x240e
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    232a:	5c 44 16 00 	mov.b	22(r4),	r12	;0x0016(r4)
    232e:	1d 44 14 00 	mov	20(r4),	r13	;0x0014(r4)
    2332:	0e 44       	mov	r4,	r14	
    2334:	3e 50 06 00 	add	#6,	r14	;#0x0006
    2338:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    233c:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    2340:	b0 12 e4 25 	call	#0x25e4	
    2344:	21 53       	incd	r1		
                 OS_EXIT_CRITICAL();
    2346:	2f 44       	mov	@r4,	r15	
    2348:	b0 12 d0 13 	call	#0x13d0	
    234c:	0d 3c       	jmp	$+28     	;abs 0x2368
             }
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
    234e:	2f 44       	mov	@r4,	r15	
    2350:	b0 12 d0 13 	call	#0x13d0	
             flags_rdy = (OS_FLAGS)0;
    2354:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
             *err      = OS_FLAG_ERR_WAIT_TYPE;
    2358:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    235c:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    2360:	00 00 
             return (flags_rdy);
    2362:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2366:	53 3c       	jmp	$+168    	;abs 0x240e
    }
    OS_Sched();                                            /* Find next HPT ready to run               */
    2368:	b0 12 5e 1d 	call	#0x1d5e	
    OS_ENTER_CRITICAL();
    236c:	b0 12 ca 13 	call	#0x13ca	
    2370:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {                   /* Have we timed-out?                       */
    2374:	1f 42 54 03 	mov	&0x0354,r15	
    2378:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    237c:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    237e:	1a 20       	jnz	$+54     	;abs 0x23b4
        OSTCBCur->OSTCBPendTO = FALSE;
    2380:	1f 42 54 03 	mov	&0x0354,r15	
    2384:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
        OS_FlagUnlink(&node);
    2388:	0f 44       	mov	r4,	r15	
    238a:	3f 50 06 00 	add	#6,	r15	;#0x0006
    238e:	b0 12 f0 27 	call	#0x27f0	
        OSTCBCur->OSTCBStat   = OS_STAT_RDY;               /* Yes, make task ready-to-run              */
    2392:	1f 42 54 03 	mov	&0x0354,r15	
    2396:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
        OS_EXIT_CRITICAL();
    239a:	2f 44       	mov	@r4,	r15	
    239c:	b0 12 d0 13 	call	#0x13d0	
        flags_rdy             = (OS_FLAGS)0;
    23a0:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
        *err                  = OS_TIMEOUT;                /* Indicate that we timed-out waiting       */
    23a4:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    23a8:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    23ac:	00 00 
        return (flags_rdy);
    23ae:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    23b2:	2d 3c       	jmp	$+92     	;abs 0x240e
    } 
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
    23b4:	1f 42 54 03 	mov	&0x0354,r15	
    23b8:	94 4f 16 00 	mov	22(r15),4(r4)	;0x0016(r15), 0x0004(r4)
    23bc:	04 00 
    if (consume == TRUE) {                                 /* See if we need to consume the flags      */
    23be:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    23c2:	1c 20       	jnz	$+58     	;abs 0x23fc
        switch (wait_type) {
    23c4:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    23c8:	2f 83       	decd	r15		
    23ca:	2f 93       	cmp	#2,	r15	;r3 As==10
    23cc:	0d 2c       	jc	$+28     	;abs 0x23e8
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
    23ce:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    23d2:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    23d6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    23da:	3f e3       	inv	r15		
    23dc:	0e ff       	and	r15,	r14	
    23de:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    23e2:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    23e6:	0a 3c       	jmp	$+22     	;abs 0x23fc
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
    23e8:	2f 44       	mov	@r4,	r15	
    23ea:	b0 12 d0 13 	call	#0x13d0	
                 *err = OS_FLAG_ERR_WAIT_TYPE;
    23ee:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    23f2:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    23f6:	00 00 
                 return ((OS_FLAGS)0);
    23f8:	0f 43       	clr	r15		
    23fa:	09 3c       	jmp	$+20     	;abs 0x240e
        }
    }
    OS_EXIT_CRITICAL();
    23fc:	2f 44       	mov	@r4,	r15	
    23fe:	b0 12 d0 13 	call	#0x13d0	
    *err = OS_NO_ERR;                                      /* Event(s) must have occurred              */
    2402:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2406:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (flags_rdy);
    240a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    240e:	31 50 1a 00 	add	#26,	r1	;#0x001a
    2412:	34 41       	pop	r4		
    2414:	30 41       	ret			

00002416 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
    2416:	04 12       	push	r4		
    2418:	21 82       	sub	#4,	r1	;r2 As==10
    241a:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    241c:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    2420:	b0 12 ca 13 	call	#0x13ca	
    2424:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    flags = OSTCBCur->OSTCBFlagsRdy;
    2428:	1f 42 54 03 	mov	&0x0354,r15	
    242c:	94 4f 16 00 	mov	22(r15),2(r4)	;0x0016(r15), 0x0002(r4)
    2430:	02 00 
    OS_EXIT_CRITICAL();
    2432:	2f 44       	mov	@r4,	r15	
    2434:	b0 12 d0 13 	call	#0x13d0	
    return (flags);
    2438:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    243c:	21 52       	add	#4,	r1	;r2 As==10
    243e:	34 41       	pop	r4		
    2440:	30 41       	ret			

00002442 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *err)
{
    2442:	04 12       	push	r4		
    2444:	31 50 ec ff 	add	#-20,	r1	;#0xffec
    2448:	04 41       	mov	r1,	r4	
    244a:	84 4f 0c 00 	mov	r15,	12(r4)	;0x000c(r4)
    244e:	84 4e 0e 00 	mov	r14,	14(r4)	;0x000e(r4)
    2452:	c4 4d 10 00 	mov.b	r13,	16(r4)	;0x0010(r4)
    2456:	84 4c 12 00 	mov	r12,	18(r4)	;0x0012(r4)
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                      /* Prevent compiler warning                       */
    245a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
    245e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2462:	6f 4f       	mov.b	@r15,	r15	
    2464:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    2468:	06 24       	jz	$+14     	;abs 0x2476
        *err = OS_ERR_EVENT_TYPE;
    246a:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    246e:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    2472:	0f 43       	clr	r15		
    2474:	b3 3c       	jmp	$+360    	;abs 0x25dc
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    2476:	b0 12 ca 13 	call	#0x13ca	
    247a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (opt) {
    247e:	5f 44 10 00 	mov.b	16(r4),	r15	;0x0010(r4)
    2482:	0f 93       	tst	r15		
    2484:	03 24       	jz	$+8      	;abs 0x248c
    2486:	1f 93       	cmp	#1,	r15	;r3 As==01
    2488:	0e 24       	jz	$+30     	;abs 0x24a6
    248a:	19 3c       	jmp	$+52     	;abs 0x24be
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
    248c:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2490:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2494:	1f 44 0e 00 	mov	14(r4),	r15	;0x000e(r4)
    2498:	3f e3       	inv	r15		
    249a:	0e ff       	and	r15,	r14	
    249c:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24a0:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    24a4:	16 3c       	jmp	$+46     	;abs 0x24d2
             break;

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
    24a6:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24aa:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    24ae:	0e 4f       	mov	r15,	r14	
    24b0:	1e d4 0e 00 	bis	14(r4),	r14	;0x000e(r4)
    24b4:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24b8:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    24bc:	0a 3c       	jmp	$+22     	;abs 0x24d2
             break;

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
    24be:	2f 44       	mov	@r4,	r15	
    24c0:	b0 12 d0 13 	call	#0x13d0	
             *err = OS_FLAG_INVALID_OPT;
    24c4:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    24c8:	ff 40 99 ff 	mov.b	#-103,	0(r15)	;#0xff99, 0x0000(r15)
    24cc:	00 00 
             return ((OS_FLAGS)0);
    24ce:	0f 43       	clr	r15		
    24d0:	85 3c       	jmp	$+268    	;abs 0x25dc
    }
    sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
    24d2:	c4 43 08 00 	mov.b	#0,	8(r4)	;r3 As==00, 0x0008(r4)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    24d6:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24da:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    24de:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)
    24e2:	5f 3c       	jmp	$+192    	;abs 0x25a2
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
        switch (pnode->OSFlagNodeWaitType) {
    24e4:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    24e8:	5f 4f 0a 00 	mov.b	10(r15),r15	;0x000a(r15)
    24ec:	7f f3       	and.b	#-1,	r15	;r3 As==11
    24ee:	2f 93       	cmp	#2,	r15	;r3 As==10
    24f0:	04 24       	jz	$+10     	;abs 0x24fa
    24f2:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    24f6:	22 24       	jz	$+70     	;abs 0x253c
    24f8:	3e 3c       	jmp	$+126    	;abs 0x2576
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
    24fa:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24fe:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2502:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2506:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    250a:	0d 4e       	mov	r14,	r13	
    250c:	0d ff       	and	r15,	r13	
    250e:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
    2512:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2516:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    251a:	1f 94 04 00 	cmp	4(r4),	r15	;0x0004(r4)
    251e:	35 20       	jnz	$+108    	;abs 0x258a
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    2520:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2524:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2528:	b0 12 48 27 	call	#0x2748	
    252c:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
                     if (rdy == TRUE) {                     
    2530:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2534:	2c 20       	jnz	$+90     	;abs 0x258e
                         sched = TRUE;                        /* When done we will reschedule          */
    2536:	d4 43 08 00 	mov.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    253a:	2e 3c       	jmp	$+94     	;abs 0x2598
                     }
                 }
                 break;

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
    253c:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2540:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2544:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2548:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    254c:	0d 4e       	mov	r14,	r13	
    254e:	0d ff       	and	r15,	r13	
    2550:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
                 if (flags_rdy != (OS_FLAGS)0) {
    2554:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    2558:	1c 24       	jz	$+58     	;abs 0x2592
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    255a:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    255e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2562:	b0 12 48 27 	call	#0x2748	
    2566:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
                     if (rdy == TRUE) {                      
    256a:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    256e:	13 20       	jnz	$+40     	;abs 0x2596
                         sched = TRUE;                        /* When done we will reschedule          */
    2570:	d4 43 08 00 	mov.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    2574:	11 3c       	jmp	$+36     	;abs 0x2598
                     }
                 }
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
    2576:	2f 44       	mov	@r4,	r15	
    2578:	b0 12 d0 13 	call	#0x13d0	
                 *err = OS_FLAG_ERR_WAIT_TYPE;
    257c:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2580:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    2584:	00 00 
                 return ((OS_FLAGS)0);
    2586:	0f 43       	clr	r15		
    2588:	29 3c       	jmp	$+84     	;abs 0x25dc
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                     
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
    258a:	03 43       	nop			
    258c:	05 3c       	jmp	$+12     	;abs 0x2598
    258e:	03 43       	nop			
    2590:	03 3c       	jmp	$+8      	;abs 0x2598
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                      
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
    2592:	03 43       	nop			
    2594:	01 3c       	jmp	$+4      	;abs 0x2598
    2596:	03 43       	nop			
            default:
                 OS_EXIT_CRITICAL();
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    2598:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    259c:	2f 4f       	mov	@r15,	r15	
    259e:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)
             *err = OS_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
    25a2:	84 93 0a 00 	tst	10(r4)		;0x000a(r4)
    25a6:	9e 23       	jnz	$-194    	;abs 0x24e4
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    25a8:	2f 44       	mov	@r4,	r15	
    25aa:	b0 12 d0 13 	call	#0x13d0	
    if (sched == TRUE) {
    25ae:	d4 93 08 00 	cmp.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    25b2:	02 20       	jnz	$+6      	;abs 0x25b8
        OS_Sched();
    25b4:	b0 12 5e 1d 	call	#0x1d5e	
    }
    OS_ENTER_CRITICAL();
    25b8:	b0 12 ca 13 	call	#0x13ca	
    25bc:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    flags_cur = pgrp->OSFlagFlags;
    25c0:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    25c4:	94 4f 04 00 	mov	4(r15),	6(r4)	;0x0004(r15), 0x0006(r4)
    25c8:	06 00 
    OS_EXIT_CRITICAL();
    25ca:	2f 44       	mov	@r4,	r15	
    25cc:	b0 12 d0 13 	call	#0x13d0	
    *err      = OS_NO_ERR;
    25d0:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    25d4:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (flags_cur);
    25d8:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
}
    25dc:	31 50 14 00 	add	#20,	r1	;#0x0014
    25e0:	34 41       	pop	r4		
    25e2:	30 41       	ret			

000025e4 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
    25e4:	04 12       	push	r4		
    25e6:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    25ea:	04 41       	mov	r1,	r4	
    25ec:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    25f0:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    25f4:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
    25f8:	c4 4c 0a 00 	mov.b	r12,	10(r4)	;0x000a(r4)
    OS_FLAG_NODE  *pnode_next;
	INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
    25fc:	1f 42 54 03 	mov	&0x0354,r15	
    2600:	1e 42 54 03 	mov	&0x0354,r14	
    2604:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    2608:	7e d0 20 00 	bis.b	#32,	r14	;#0x0020
    260c:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO     = FALSE;
    2610:	1f 42 54 03 	mov	&0x0354,r15	
    2614:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
    2618:	1f 42 54 03 	mov	&0x0354,r15	
    261c:	9f 44 10 00 	mov	16(r4),	24(r15)	;0x0010(r4), 0x0018(r15)
    2620:	18 00 
    OSTCBCur->OSTCBEventPtr   = (OS_EVENT *)0;
    2622:	1f 42 54 03 	mov	&0x0354,r15	
    2626:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
    262a:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    262e:	9f 44 08 00 	mov	8(r4),	8(r15)	;0x0008(r4), 0x0008(r15)
    2632:	08 00 
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
    2634:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2638:	df 44 0a 00 	mov.b	10(r4),	10(r15)	;0x000a(r4), 0x000a(r15)
    263c:	0a 00 
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
    263e:	1e 42 54 03 	mov	&0x0354,r14	
    2642:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2646:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
    264a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    264e:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2652:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2656:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    pnode->OSFlagNodePrev     = (void *)0;
    265a:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    265e:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
    2662:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2666:	9f 44 04 00 	mov	4(r4),	6(r15)	;0x0004(r4), 0x0006(r15)
    266a:	06 00 
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    266c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2670:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    2674:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
    2678:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    267c:	05 24       	jz	$+12     	;abs 0x2688
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
    267e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2682:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    2686:	02 00 
    }
    pgrp->OSFlagWaitList = (void *)pnode;
    2688:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    268c:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    2690:	02 00 
                                                      
    y            =  OSTCBCur->OSTCBY;		 	      /* Suspend current task until flag(s) received   */
    2692:	1f 42 54 03 	mov	&0x0354,r15	
    2696:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    269a:	00 00 
	OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
    269c:	6d 44       	mov.b	@r4,	r13	
    269e:	6f 44       	mov.b	@r4,	r15	
    26a0:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    26a4:	4e 4f       	mov.b	r15,	r14	
    26a6:	1f 42 54 03 	mov	&0x0354,r15	
    26aa:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    26ae:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    26b0:	4f fe       	and.b	r14,	r15	
    26b2:	cd 4f 4e 03 	mov.b	r15,	846(r13);0x034e(r13)
    if (OSRdyTbl[y] == 0x00) {
    26b6:	6f 44       	mov.b	@r4,	r15	
    26b8:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    26bc:	4f 93       	tst.b	r15		
    26be:	0b 20       	jnz	$+24     	;abs 0x26d6
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
    26c0:	1f 42 54 03 	mov	&0x0354,r15	
    26c4:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    26c8:	4e 4f       	mov.b	r15,	r14	
    26ca:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    26cc:	5f 42 4c 03 	mov.b	&0x034c,r15	
    26d0:	4f fe       	and.b	r14,	r15	
    26d2:	c2 4f 4c 03 	mov.b	r15,	&0x034c	
    }
}
    26d6:	31 50 0c 00 	add	#12,	r1	;#0x000c
    26da:	34 41       	pop	r4		
    26dc:	30 41       	ret			

000026de <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
    26de:	04 12       	push	r4		
    26e0:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    26e4:	04 41       	mov	r1,	r4	
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    26e6:	3f 40 0c 03 	mov	#780,	r15	;#0x030c
    26ea:	3e 40 12 00 	mov	#18,	r14	;#0x0012
    26ee:	b0 12 f8 1c 	call	#0x1cf8	
    pgrp1 = &OSFlagTbl[0];
    26f2:	b4 40 0c 03 	mov	#780,	2(r4)	;#0x030c, 0x0002(r4)
    26f6:	02 00 
    pgrp2 = &OSFlagTbl[1];
    26f8:	b4 40 12 03 	mov	#786,	0(r4)	;#0x0312, 0x0000(r4)
    26fc:	00 00 
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
    26fe:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    2702:	10 3c       	jmp	$+34     	;abs 0x2724
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    2704:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2708:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
    270c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2710:	af 44 02 00 	mov	@r4,	2(r15)	;0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
    2714:	b4 50 06 00 	add	#6,	2(r4)	;#0x0006, 0x0002(r4)
    2718:	02 00 
        pgrp2++;
    271a:	b4 50 06 00 	add	#6,	0(r4)	;#0x0006, 0x0000(r4)
    271e:	00 00 


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
    2720:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    2724:	a4 93 04 00 	cmp	#2,	4(r4)	;r3 As==10, 0x0004(r4)
    2728:	ed 2b       	jnc	$-36     	;abs 0x2704
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    272a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    272e:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    pgrp1->OSFlagWaitList = (void *)0;
    2732:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2736:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
    OSFlagFreeList        = (OS_FLAG_GRP *)&OSFlagTbl[0];
    273a:	b2 40 0c 03 	mov	#780,	&0x05d2	;#0x030c
    273e:	d2 05 
#endif
}
    2740:	31 50 06 00 	add	#6,	r1	;#0x0006
    2744:	34 41       	pop	r4		
    2746:	30 41       	ret			

00002748 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
    2748:	04 12       	push	r4		
    274a:	31 82       	sub	#8,	r1	;r2 As==11
    274c:	04 41       	mov	r1,	r4	
    274e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2752:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
    2756:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    275a:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    275e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    ptcb->OSTCBDly      = 0;
    2762:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2766:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)
    ptcb->OSTCBFlagsRdy = flags_rdy;
    276a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    276e:	9f 44 06 00 	mov	6(r4),	22(r15)	;0x0006(r4), 0x0016(r15)
    2772:	16 00 
    ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
    2774:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2778:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    277c:	4e 4f       	mov.b	r15,	r14	
    277e:	7e f0 df ff 	and.b	#-33,	r14	;#0xffdf
    2782:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2786:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    ptcb->OSTCBPendTO   = FALSE;
    278a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    278e:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
    2792:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2796:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    279a:	4f 93       	tst.b	r15		
    279c:	1f 20       	jnz	$+64     	;abs 0x27dc
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
    279e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27a2:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    27a6:	5f 42 4c 03 	mov.b	&0x034c,r15	
    27aa:	4f de       	bis.b	r14,	r15	
    27ac:	c2 4f 4c 03 	mov.b	r15,	&0x034c	
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    27b0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27b4:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    27b8:	4d 4f       	mov.b	r15,	r13	
    27ba:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27be:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    27c2:	7f f3       	and.b	#-1,	r15	;r3 As==11
    27c4:	5e 4f 4e 03 	mov.b	846(r15),r14	;0x034e(r15)
    27c8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27cc:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    27d0:	4f de       	bis.b	r14,	r15	
    27d2:	cd 4f 4e 03 	mov.b	r15,	846(r13);0x034e(r13)
        sched                   = TRUE;
    27d6:	d4 43 00 00 	mov.b	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    27da:	02 3c       	jmp	$+6      	;abs 0x27e0
    } else {
        sched                   = FALSE;
    27dc:	c4 43 00 00 	mov.b	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    OS_FlagUnlink(pnode);
    27e0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    27e4:	b0 12 f0 27 	call	#0x27f0	
    return (sched);
    27e8:	6f 44       	mov.b	@r4,	r15	
}
    27ea:	31 52       	add	#8,	r1	;r2 As==11
    27ec:	34 41       	pop	r4		
    27ee:	30 41       	ret			

000027f0 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
    27f0:	04 12       	push	r4		
    27f2:	31 82       	sub	#8,	r1	;r2 As==11
    27f4:	04 41       	mov	r1,	r4	
    27f6:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    27fa:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    27fe:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    2802:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    2806:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    280a:	2f 4f       	mov	@r15,	r15	
    280c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
    2810:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2814:	11 20       	jnz	$+36     	;abs 0x2838
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
    2816:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    281a:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    281e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
    2822:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2826:	af 44 02 00 	mov	@r4,	2(r15)	;0x0002(r15)
        if (pnode_next != (OS_FLAG_NODE *)0) {
    282a:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    282e:	10 24       	jz	$+34     	;abs 0x2850
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
    2830:	2f 44       	mov	@r4,	r15	
    2832:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    2836:	0d 3c       	jmp	$+28     	;abs 0x2852
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
    2838:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    283c:	af 44 00 00 	mov	@r4,	0(r15)	;0x0000(r15)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
    2840:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    2844:	06 24       	jz	$+14     	;abs 0x2852
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
    2846:	2f 44       	mov	@r4,	r15	
    2848:	9f 44 02 00 	mov	2(r4),	2(r15)	;0x0002(r4), 0x0002(r15)
    284c:	02 00 
    284e:	01 3c       	jmp	$+4      	;abs 0x2852
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
    2850:	03 43       	nop			
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
#endif
}
    2852:	31 52       	add	#8,	r1	;r2 As==11
    2854:	34 41       	pop	r4		
    2856:	30 41       	ret			

00002858 <OSMboxAccept>:
*********************************************************************************************************
*/

#if OS_MBOX_ACCEPT_EN > 0
void  *OSMboxAccept (OS_EVENT *pevent)
{
    2858:	04 12       	push	r4		
    285a:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    285e:	04 41       	mov	r1,	r4	
    2860:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                               /* Allocate storage for CPU status register  */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                           /* Prevent compiler warning                  */
    2864:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
    2868:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    286c:	6f 4f       	mov.b	@r15,	r15	
    286e:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2870:	02 24       	jz	$+6      	;abs 0x2876
        return ((void *)0);
    2872:	0f 43       	clr	r15		
    2874:	12 3c       	jmp	$+38     	;abs 0x289a
    }
    OS_ENTER_CRITICAL();
    2876:	b0 12 ca 13 	call	#0x13ca	
    287a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    msg                = pevent->OSEventPtr;
    287e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2882:	94 4f 04 00 	mov	4(r15),	2(r4)	;0x0004(r15), 0x0002(r4)
    2886:	02 00 
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
    2888:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    288c:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
    OS_EXIT_CRITICAL();
    2890:	2f 44       	mov	@r4,	r15	
    2892:	b0 12 d0 13 	call	#0x13d0	
    return (msg);                                         /* Return the message received (or NULL)     */
    2896:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    289a:	31 50 06 00 	add	#6,	r1	;#0x0006
    289e:	34 41       	pop	r4		
    28a0:	30 41       	ret			

000028a2 <OSMboxCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSMboxCreate (void *msg)
{
    28a2:	04 12       	push	r4		
    28a4:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    28a8:	04 41       	mov	r1,	r4	
    28aa:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    28ae:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    28b2:	5f 42 52 03 	mov.b	&0x0352,r15	
    28b6:	4f 93       	tst.b	r15		
    28b8:	02 24       	jz	$+6      	;abs 0x28be
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    28ba:	0f 43       	clr	r15		
    28bc:	2a 3c       	jmp	$+86     	;abs 0x2912
    }
    OS_ENTER_CRITICAL();
    28be:	b0 12 ca 13 	call	#0x13ca	
    28c2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
    28c6:	94 42 50 03 	mov	&0x0350,2(r4)	;0x0002(r4)
    28ca:	02 00 
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
    28cc:	1f 42 50 03 	mov	&0x0350,r15	
    28d0:	0f 93       	tst	r15		
    28d2:	06 24       	jz	$+14     	;abs 0x28e0
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    28d4:	1f 42 50 03 	mov	&0x0350,r15	
    28d8:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    28dc:	82 4f 50 03 	mov	r15,	&0x0350	
    }
    OS_EXIT_CRITICAL();
    28e0:	2f 44       	mov	@r4,	r15	
    28e2:	b0 12 d0 13 	call	#0x13d0	
    if (pevent != (OS_EVENT *)0) {
    28e6:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    28ea:	11 24       	jz	$+36     	;abs 0x290e
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
    28ec:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    28f0:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        pevent->OSEventCnt     = 0;
    28f4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    28f8:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
        pevent->OSEventPtr     = msg;            /* Deposit message in event control block             */
    28fc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2900:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2904:	04 00 
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);
    2906:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    290a:	b0 12 54 1b 	call	#0x1b54	
    }
    return (pevent);                             /* Return pointer to event control block              */
    290e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    2912:	31 50 06 00 	add	#6,	r1	;#0x0006
    2916:	34 41       	pop	r4		
    2918:	30 41       	ret			

0000291a <OSMboxPend>:
*                            if you didn't pass the proper pointer to the event control block.
*********************************************************************************************************
*/

void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    291a:	04 12       	push	r4		
    291c:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    2920:	04 41       	mov	r1,	r4	
    2922:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2926:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    292a:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    292e:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
    2932:	5f 42 52 03 	mov.b	&0x0352,r15	
    2936:	4f 93       	tst.b	r15		
    2938:	06 24       	jz	$+14     	;abs 0x2946
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
    293a:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    293e:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((void *)0);
    2942:	0f 43       	clr	r15		
    2944:	72 3c       	jmp	$+230    	;abs 0x2a2a
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    2946:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    294a:	6f 4f       	mov.b	@r15,	r15	
    294c:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    294e:	06 24       	jz	$+14     	;abs 0x295c
        *err = OS_ERR_EVENT_TYPE;
    2950:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2954:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((void *)0);
    2958:	0f 43       	clr	r15		
    295a:	67 3c       	jmp	$+208    	;abs 0x2a2a
    }
    OS_ENTER_CRITICAL();
    295c:	b0 12 ca 13 	call	#0x13ca	
    2960:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    msg = pevent->OSEventPtr;
    2964:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2968:	94 4f 04 00 	mov	4(r15),	2(r4)	;0x0004(r15), 0x0002(r4)
    296c:	02 00 
    if (msg != (void *)0) {                           /* See if there is already a message             */
    296e:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2972:	0e 24       	jz	$+30     	;abs 0x2990
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
    2974:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2978:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
        OS_EXIT_CRITICAL();
    297c:	2f 44       	mov	@r4,	r15	
    297e:	b0 12 d0 13 	call	#0x13d0	
        *err = OS_NO_ERR;
    2982:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2986:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        return (msg);                                 /* Return the message received (or NULL)         */
    298a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    298e:	4d 3c       	jmp	$+156    	;abs 0x2a2a
    }
    OSTCBCur->OSTCBStat  |= OS_STAT_MBOX;             /* Message not available, task will pend         */
    2990:	1f 42 54 03 	mov	&0x0354,r15	
    2994:	1e 42 54 03 	mov	&0x0354,r14	
    2998:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    299c:	6e d3       	bis.b	#2,	r14	;r3 As==10
    299e:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO = FALSE;
    29a2:	1f 42 54 03 	mov	&0x0354,r15	
    29a6:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly    = timeout;                  /* Load timeout in TCB                           */
    29aa:	1f 42 54 03 	mov	&0x0354,r15	
    29ae:	9f 44 06 00 	mov	6(r4),	24(r15)	;0x0006(r4), 0x0018(r15)
    29b2:	18 00 
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    29b4:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    29b8:	b0 12 12 1a 	call	#0x1a12	
    OS_EXIT_CRITICAL();
    29bc:	2f 44       	mov	@r4,	r15	
    29be:	b0 12 d0 13 	call	#0x13d0	
    OS_Sched();                                       /* Find next highest priority task ready to run  */
    29c2:	b0 12 5e 1d 	call	#0x1d5e	
    OS_ENTER_CRITICAL();
    29c6:	b0 12 ca 13 	call	#0x13ca	
    29ca:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we were given the message              */
    29ce:	1f 42 54 03 	mov	&0x0354,r15	
    29d2:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    29d6:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    29d8:	0e 20       	jnz	$+30     	;abs 0x29f6
        OS_EventTO(pevent);                           /* Timed out, Make task ready                    */
    29da:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    29de:	b0 12 c2 1a 	call	#0x1ac2	
        OS_EXIT_CRITICAL();
    29e2:	2f 44       	mov	@r4,	r15	
    29e4:	b0 12 d0 13 	call	#0x13d0	
        *err = OS_TIMEOUT;                            /* Indicate that a timeout occured               */
    29e8:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    29ec:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    29f0:	00 00 
        return ((void *)0);                           /* Return a NULL message                         */
    29f2:	0f 43       	clr	r15		
    29f4:	1a 3c       	jmp	$+54     	;abs 0x2a2a
    }
    msg                     = OSTCBCur->OSTCBMsg;
    29f6:	1f 42 54 03 	mov	&0x0354,r15	
    29fa:	94 4f 14 00 	mov	20(r15),2(r4)	;0x0014(r15), 0x0002(r4)
    29fe:	02 00 
    OSTCBCur->OSTCBMsg      = (void *)0;              /* Yes, clear message received                   */
    2a00:	1f 42 54 03 	mov	&0x0354,r15	
    2a04:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    2a08:	1f 42 54 03 	mov	&0x0354,r15	
    2a0c:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;          /* No longer waiting for event                   */
    2a10:	1f 42 54 03 	mov	&0x0354,r15	
    2a14:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    2a18:	2f 44       	mov	@r4,	r15	
    2a1a:	b0 12 d0 13 	call	#0x13d0	
    *err                    = OS_NO_ERR;
    2a1e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2a22:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (msg);                                     /* Return the message received                   */
    2a26:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    2a2a:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2a2e:	34 41       	pop	r4		
    2a30:	30 41       	ret			

00002a32 <OSMboxPost>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_EN > 0
INT8U  OSMboxPost (OS_EVENT *pevent, void *msg)
{
    2a32:	04 12       	push	r4		
    2a34:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2a38:	04 41       	mov	r1,	r4	
    2a3a:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    2a3e:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
    

    
    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2a42:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    2a46:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2a4a:	6f 4f       	mov.b	@r15,	r15	
    2a4c:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2a4e:	02 24       	jz	$+6      	;abs 0x2a54
        return (OS_ERR_EVENT_TYPE);
    2a50:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2a52:	2d 3c       	jmp	$+92     	;abs 0x2aae
    }
    OS_ENTER_CRITICAL();
    2a54:	b0 12 ca 13 	call	#0x13ca	
    2a58:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                     /* See if any task pending on mailbox        */
    2a5c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2a60:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2a64:	4f 93       	tst.b	r15		
    2a66:	0e 24       	jz	$+30     	;abs 0x2a84
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX); /* Ready HPT waiting on event                */
    2a68:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2a6c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2a70:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2a72:	b0 12 d0 18 	call	#0x18d0	
        OS_EXIT_CRITICAL();
    2a76:	2f 44       	mov	@r4,	r15	
    2a78:	b0 12 d0 13 	call	#0x13d0	
        OS_Sched();                                   /* Find highest priority task ready to run       */
    2a7c:	b0 12 5e 1d 	call	#0x1d5e	
        return (OS_NO_ERR);
    2a80:	4f 43       	clr.b	r15		
    2a82:	15 3c       	jmp	$+44     	;abs 0x2aae
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
    2a84:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2a88:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2a8c:	0f 93       	tst	r15		
    2a8e:	06 24       	jz	$+14     	;abs 0x2a9c
        OS_EXIT_CRITICAL();
    2a90:	2f 44       	mov	@r4,	r15	
    2a92:	b0 12 d0 13 	call	#0x13d0	
        return (OS_MBOX_FULL);
    2a96:	7f 40 14 00 	mov.b	#20,	r15	;#0x0014
    2a9a:	09 3c       	jmp	$+20     	;abs 0x2aae
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
    2a9c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2aa0:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2aa4:	04 00 
    OS_EXIT_CRITICAL();
    2aa6:	2f 44       	mov	@r4,	r15	
    2aa8:	b0 12 d0 13 	call	#0x13d0	
    return (OS_NO_ERR);
    2aac:	4f 43       	clr.b	r15		
}
    2aae:	31 50 06 00 	add	#6,	r1	;#0x0006
    2ab2:	34 41       	pop	r4		
    2ab4:	30 41       	ret			

00002ab6 <OSMboxPostOpt>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_OPT_EN > 0
INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
    2ab6:	04 12       	push	r4		
    2ab8:	31 82       	sub	#8,	r1	;r2 As==11
    2aba:	04 41       	mov	r1,	r4	
    2abc:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    2ac0:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    2ac4:	c4 4d 06 00 	mov.b	r13,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2ac8:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    2acc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ad0:	6f 4f       	mov.b	@r15,	r15	
    2ad2:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2ad4:	02 24       	jz	$+6      	;abs 0x2ada
        return (OS_ERR_EVENT_TYPE);
    2ad6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2ad8:	41 3c       	jmp	$+132    	;abs 0x2b5c
    }
    OS_ENTER_CRITICAL();
    2ada:	b0 12 ca 13 	call	#0x13ca	
    2ade:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on mailbox            */
    2ae2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ae6:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2aea:	4f 93       	tst.b	r15		
    2aec:	22 24       	jz	$+70     	;abs 0x2b32
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
    2aee:	5f 44 06 00 	mov.b	6(r4),	r15	;0x0006(r4)
    2af2:	1f f3       	and	#1,	r15	;r3 As==01
    2af4:	4f 93       	tst.b	r15		
    2af6:	0f 24       	jz	$+32     	;abs 0x2b16
    2af8:	07 3c       	jmp	$+16     	;abs 0x2b08
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on mailbox     */           
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);    
    2afa:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2afe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b02:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2b04:	b0 12 d0 18 	call	#0x18d0	
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on mailbox            */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on mailbox     */           
    2b08:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b0c:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2b10:	4f 93       	tst.b	r15		
    2b12:	f3 23       	jnz	$-24     	;abs 0x2afa
    2b14:	07 3c       	jmp	$+16     	;abs 0x2b24
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);    
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);  /* No,  Post to HPT waiting on mbox     */
    2b16:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2b1a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b1e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2b20:	b0 12 d0 18 	call	#0x18d0	
        }
        OS_EXIT_CRITICAL();
    2b24:	2f 44       	mov	@r4,	r15	
    2b26:	b0 12 d0 13 	call	#0x13d0	
        OS_Sched();                                            /* Find HPT ready to run                */
    2b2a:	b0 12 5e 1d 	call	#0x1d5e	
        return (OS_NO_ERR);
    2b2e:	4f 43       	clr.b	r15		
    2b30:	15 3c       	jmp	$+44     	;abs 0x2b5c
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
    2b32:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b36:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2b3a:	0f 93       	tst	r15		
    2b3c:	06 24       	jz	$+14     	;abs 0x2b4a
        OS_EXIT_CRITICAL();
    2b3e:	2f 44       	mov	@r4,	r15	
    2b40:	b0 12 d0 13 	call	#0x13d0	
        return (OS_MBOX_FULL);
    2b44:	7f 40 14 00 	mov.b	#20,	r15	;#0x0014
    2b48:	09 3c       	jmp	$+20     	;abs 0x2b5c
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
    2b4a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b4e:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2b52:	04 00 
    OS_EXIT_CRITICAL();
    2b54:	2f 44       	mov	@r4,	r15	
    2b56:	b0 12 d0 13 	call	#0x13d0	
    return (OS_NO_ERR);
    2b5a:	4f 43       	clr.b	r15		
}
    2b5c:	31 52       	add	#8,	r1	;r2 As==11
    2b5e:	34 41       	pop	r4		
    2b60:	30 41       	ret			

00002b62 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *err)
{
    2b62:	04 12       	push	r4		
    2b64:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    2b68:	04 41       	mov	r1,	r4	
    2b6a:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2b6e:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2b72:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
    2b76:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2b7a:	6f 4f       	mov.b	@r15,	r15	
    2b7c:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    2b7e:	06 24       	jz	$+14     	;abs 0x2b8c
        *err = OS_ERR_EVENT_TYPE;
    2b80:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2b84:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((void *)0);
    2b88:	0f 43       	clr	r15		
    2b8a:	49 3c       	jmp	$+148    	;abs 0x2c1e
    }
    OS_ENTER_CRITICAL();
    2b8c:	b0 12 ca 13 	call	#0x13ca	
    2b90:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    2b94:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2b98:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2b9c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
    2ba0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ba4:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2ba8:	0f 93       	tst	r15		
    2baa:	2d 24       	jz	$+92     	;abs 0x2c06
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
    2bac:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bb0:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2bb4:	a4 4f 04 00 	mov	@r15,	4(r4)	;0x0004(r4)
    2bb8:	0e 4f       	mov	r15,	r14	
    2bba:	2e 53       	incd	r14		
    2bbc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bc0:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
    2bc4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bc8:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2bcc:	0e 4f       	mov	r15,	r14	
    2bce:	3e 53       	add	#-1,	r14	;r3 As==11
    2bd0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bd4:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
    2bd8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bdc:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    2be0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2be4:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2be8:	0e 9f       	cmp	r15,	r14	
    2bea:	08 20       	jnz	$+18     	;abs 0x2bfc
            pq->OSQOut = pq->OSQStart;
    2bec:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bf0:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2bf4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bf8:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        *err = OS_NO_ERR;
    2bfc:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2c00:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    2c04:	07 3c       	jmp	$+16     	;abs 0x2c14
    } else {
        *err = OS_Q_EMPTY;
    2c06:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2c0a:	ff 40 1f 00 	mov.b	#31,	0(r15)	;#0x001f, 0x0000(r15)
    2c0e:	00 00 
        msg  = (void *)0;                        /* Queue is empty                                     */
    2c10:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    }
    OS_EXIT_CRITICAL();
    2c14:	2f 44       	mov	@r4,	r15	
    2c16:	b0 12 d0 13 	call	#0x13d0	
    return (msg);                                /* Return message received (or NULL)                  */
    2c1a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2c1e:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2c22:	34 41       	pop	r4		
    2c24:	30 41       	ret			

00002c26 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
    2c26:	04 12       	push	r4		
    2c28:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    2c2c:	04 41       	mov	r1,	r4	
    2c2e:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2c32:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2c36:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    2c3a:	5f 42 52 03 	mov.b	&0x0352,r15	
    2c3e:	4f 93       	tst.b	r15		
    2c40:	02 24       	jz	$+6      	;abs 0x2c46
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    2c42:	0f 43       	clr	r15		
    2c44:	6d 3c       	jmp	$+220    	;abs 0x2d20
    }
    OS_ENTER_CRITICAL();
    2c46:	b0 12 ca 13 	call	#0x13ca	
    2c4a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
    2c4e:	94 42 50 03 	mov	&0x0350,4(r4)	;0x0004(r4)
    2c52:	04 00 
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
    2c54:	1f 42 50 03 	mov	&0x0350,r15	
    2c58:	0f 93       	tst	r15		
    2c5a:	06 24       	jz	$+14     	;abs 0x2c68
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    2c5c:	1f 42 50 03 	mov	&0x0350,r15	
    2c60:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2c64:	82 4f 50 03 	mov	r15,	&0x0350	
    }
    OS_EXIT_CRITICAL();
    2c68:	2f 44       	mov	@r4,	r15	
    2c6a:	b0 12 d0 13 	call	#0x13d0	
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
    2c6e:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    2c72:	54 24       	jz	$+170    	;abs 0x2d1c
        OS_ENTER_CRITICAL();
    2c74:	b0 12 ca 13 	call	#0x13ca	
    2c78:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
    2c7c:	94 42 4a 03 	mov	&0x034a,2(r4)	;0x0002(r4)
    2c80:	02 00 
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
    2c82:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2c86:	3c 24       	jz	$+122    	;abs 0x2d00
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
    2c88:	1f 42 4a 03 	mov	&0x034a,r15	
    2c8c:	2f 4f       	mov	@r15,	r15	
    2c8e:	82 4f 4a 03 	mov	r15,	&0x034a	
            OS_EXIT_CRITICAL();
    2c92:	2f 44       	mov	@r4,	r15	
    2c94:	b0 12 d0 13 	call	#0x13d0	
            pq->OSQStart           = start;               /*      Initialize the queue                 */
    2c98:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c9c:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    2ca0:	02 00 
            pq->OSQEnd             = &start[size];
    2ca2:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2ca6:	0f 5f       	rla	r15		
    2ca8:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    2cac:	0e 5f       	add	r15,	r14	
    2cae:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cb2:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
            pq->OSQIn              = start;
    2cb6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cba:	9f 44 06 00 	mov	6(r4),	6(r15)	;0x0006(r4), 0x0006(r15)
    2cbe:	06 00 
            pq->OSQOut             = start;
    2cc0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cc4:	9f 44 06 00 	mov	6(r4),	8(r15)	;0x0006(r4), 0x0008(r15)
    2cc8:	08 00 
            pq->OSQSize            = size;
    2cca:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cce:	9f 44 08 00 	mov	8(r4),	10(r15)	;0x0008(r4), 0x000a(r15)
    2cd2:	0a 00 
            pq->OSQEntries         = 0;
    2cd4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cd8:	8f 43 0c 00 	mov	#0,	12(r15)	;r3 As==00, 0x000c(r15)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
    2cdc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2ce0:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
            pevent->OSEventCnt     = 0;
    2ce4:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2ce8:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
            pevent->OSEventPtr     = pq;
    2cec:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2cf0:	9f 44 02 00 	mov	2(r4),	4(r15)	;0x0002(r4), 0x0004(r15)
    2cf4:	04 00 
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
            pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
    2cf6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2cfa:	b0 12 54 1b 	call	#0x1b54	
    2cfe:	0e 3c       	jmp	$+30     	;abs 0x2d1c
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
    2d00:	1e 42 50 03 	mov	&0x0350,r14	
    2d04:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d08:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
            OSEventFreeList    = pevent;
    2d0c:	92 44 04 00 	mov	4(r4),	&0x0350	;0x0004(r4)
    2d10:	50 03 
            OS_EXIT_CRITICAL();
    2d12:	2f 44       	mov	@r4,	r15	
    2d14:	b0 12 d0 13 	call	#0x13d0	
            pevent = (OS_EVENT *)0;
    2d18:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
        }
    }
    return (pevent);
    2d1c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2d20:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2d24:	34 41       	pop	r4		
    2d26:	30 41       	ret			

00002d28 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
    2d28:	04 12       	push	r4		
    2d2a:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2d2e:	04 41       	mov	r1,	r4	
    2d30:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2d34:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
    2d38:	b0 12 ca 13 	call	#0x13ca	
    2d3c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
    2d40:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d44:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2d48:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    pq->OSQIn      = pq->OSQStart;
    2d4c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d50:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2d54:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d58:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    pq->OSQOut     = pq->OSQStart;
    2d5c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d60:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2d64:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d68:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    pq->OSQEntries = 0;
    2d6c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d70:	8f 43 0c 00 	mov	#0,	12(r15)	;r3 As==00, 0x000c(r15)
    OS_EXIT_CRITICAL();
    2d74:	2f 44       	mov	@r4,	r15	
    2d76:	b0 12 d0 13 	call	#0x13d0	
    return (OS_NO_ERR);
    2d7a:	4f 43       	clr.b	r15		
}
    2d7c:	31 50 06 00 	add	#6,	r1	;#0x0006
    2d80:	34 41       	pop	r4		
    2d82:	30 41       	ret			

00002d84 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    2d84:	04 12       	push	r4		
    2d86:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    2d8a:	04 41       	mov	r1,	r4	
    2d8c:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2d90:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    2d94:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2d98:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    2d9c:	5f 42 52 03 	mov.b	&0x0352,r15	
    2da0:	4f 93       	tst.b	r15		
    2da2:	06 24       	jz	$+14     	;abs 0x2db0
        *err = OS_ERR_PEND_ISR;                  /* ... can't PEND from an ISR                         */
    2da4:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2da8:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((void *)0);
    2dac:	0f 43       	clr	r15		
    2dae:	8f 3c       	jmp	$+288    	;abs 0x2ece
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
        *err = OS_ERR_EVENT_TYPE;
        return ((void *)0);
    }
#endif
    OS_ENTER_CRITICAL();
    2db0:	b0 12 ca 13 	call	#0x13ca	
    2db4:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    2db8:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2dbc:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2dc0:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
    2dc4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2dc8:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2dcc:	0f 93       	tst	r15		
    2dce:	32 24       	jz	$+102    	;abs 0x2e34
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
    2dd0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2dd4:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2dd8:	a4 4f 04 00 	mov	@r15,	4(r4)	;0x0004(r4)
    2ddc:	0e 4f       	mov	r15,	r14	
    2dde:	2e 53       	incd	r14		
    2de0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2de4:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
    2de8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2dec:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2df0:	0e 4f       	mov	r15,	r14	
    2df2:	3e 53       	add	#-1,	r14	;r3 As==11
    2df4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2df8:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
    2dfc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e00:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    2e04:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e08:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2e0c:	0e 9f       	cmp	r15,	r14	
    2e0e:	08 20       	jnz	$+18     	;abs 0x2e20
            pq->OSQOut = pq->OSQStart;
    2e10:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e14:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2e18:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e1c:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        OS_EXIT_CRITICAL();
    2e20:	2f 44       	mov	@r4,	r15	
    2e22:	b0 12 d0 13 	call	#0x13d0	
        *err = OS_NO_ERR;
    2e26:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2e2a:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        return (msg);                            /* Return message received                            */
    2e2e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2e32:	4d 3c       	jmp	$+156    	;abs 0x2ece
    }
    OSTCBCur->OSTCBStat   |= OS_STAT_Q;          /* Task will have to pend for a message to be posted  */
    2e34:	1f 42 54 03 	mov	&0x0354,r15	
    2e38:	1e 42 54 03 	mov	&0x0354,r14	
    2e3c:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    2e40:	6e d2       	bis.b	#4,	r14	;r2 As==10
    2e42:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO  = FALSE;
    2e46:	1f 42 54 03 	mov	&0x0354,r15	
    2e4a:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly     = timeout;            /* Load timeout into TCB                              */
    2e4e:	1f 42 54 03 	mov	&0x0354,r15	
    2e52:	9f 44 08 00 	mov	8(r4),	24(r15)	;0x0008(r4), 0x0018(r15)
    2e56:	18 00 
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
    2e58:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2e5c:	b0 12 12 1a 	call	#0x1a12	
    OS_EXIT_CRITICAL();
    2e60:	2f 44       	mov	@r4,	r15	
    2e62:	b0 12 d0 13 	call	#0x13d0	
    OS_Sched();                                  /* Find next highest priority task ready to run       */
    2e66:	b0 12 5e 1d 	call	#0x1d5e	
    OS_ENTER_CRITICAL();
    2e6a:	b0 12 ca 13 	call	#0x13ca	
    2e6e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {         /* Was task readied because of a timeout?             */
    2e72:	1f 42 54 03 	mov	&0x0354,r15	
    2e76:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    2e7a:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2e7c:	0e 20       	jnz	$+30     	;abs 0x2e9a
        OS_EventTO(pevent);                      /* Yes                                                */
    2e7e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2e82:	b0 12 c2 1a 	call	#0x1ac2	
        OS_EXIT_CRITICAL();
    2e86:	2f 44       	mov	@r4,	r15	
    2e88:	b0 12 d0 13 	call	#0x13d0	
        *err = OS_TIMEOUT;                       /*     Indicate a timeout occured                     */
    2e8c:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2e90:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    2e94:	00 00 
        return ((void *)0);                      /*     No message received                            */
    2e96:	0f 43       	clr	r15		
    2e98:	1a 3c       	jmp	$+54     	;abs 0x2ece
    }
    msg                     = OSTCBCur->OSTCBMsg;/* No, Extract message from TCB (Put there by QPost)  */
    2e9a:	1f 42 54 03 	mov	&0x0354,r15	
    2e9e:	94 4f 14 00 	mov	20(r15),4(r4)	;0x0014(r15), 0x0004(r4)
    2ea2:	04 00 
    OSTCBCur->OSTCBMsg      = (void *)0;
    2ea4:	1f 42 54 03 	mov	&0x0354,r15	
    2ea8:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    2eac:	1f 42 54 03 	mov	&0x0354,r15	
    2eb0:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;     /*     No longer waiting for event                    */
    2eb4:	1f 42 54 03 	mov	&0x0354,r15	
    2eb8:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    2ebc:	2f 44       	mov	@r4,	r15	
    2ebe:	b0 12 d0 13 	call	#0x13d0	
    *err                    = OS_NO_ERR;
    2ec2:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2ec6:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (msg);                                /*     Return message received                        */
    2eca:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2ece:	31 50 0c 00 	add	#12,	r1	;#0x000c
    2ed2:	34 41       	pop	r4		
    2ed4:	30 41       	ret			

00002ed6 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *msg)
{
    2ed6:	04 12       	push	r4		
    2ed8:	31 82       	sub	#8,	r1	;r2 As==11
    2eda:	04 41       	mov	r1,	r4	
    2edc:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2ee0:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    2ee4:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
    2ee8:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2eec:	6f 4f       	mov.b	@r15,	r15	
    2eee:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    2ef0:	02 24       	jz	$+6      	;abs 0x2ef6
        return (OS_ERR_EVENT_TYPE);
    2ef2:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2ef4:	5b 3c       	jmp	$+184    	;abs 0x2fac
    }
    OS_ENTER_CRITICAL();
    2ef6:	b0 12 ca 13 	call	#0x13ca	
    2efa:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                  /* See if any task pending on queue             */
    2efe:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f02:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2f06:	4f 93       	tst.b	r15		
    2f08:	0e 24       	jz	$+30     	;abs 0x2f26
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q); /* Ready highest priority task waiting on event */
    2f0a:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    2f0e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f12:	6d 42       	mov.b	#4,	r13	;r2 As==10
    2f14:	b0 12 d0 18 	call	#0x18d0	
        OS_EXIT_CRITICAL();
    2f18:	2f 44       	mov	@r4,	r15	
    2f1a:	b0 12 d0 13 	call	#0x13d0	
        OS_Sched();                                    /* Find highest priority task ready to run      */
    2f1e:	b0 12 5e 1d 	call	#0x1d5e	
        return (OS_NO_ERR);
    2f22:	4f 43       	clr.b	r15		
    2f24:	43 3c       	jmp	$+136    	;abs 0x2fac
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
    2f26:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f2a:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2f2e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
    2f32:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f36:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    2f3a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f3e:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    2f42:	0e 9f       	cmp	r15,	r14	
    2f44:	06 28       	jnc	$+14     	;abs 0x2f52
        OS_EXIT_CRITICAL();
    2f46:	2f 44       	mov	@r4,	r15	
    2f48:	b0 12 d0 13 	call	#0x13d0	
        return (OS_Q_FULL);
    2f4c:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    2f50:	2d 3c       	jmp	$+92     	;abs 0x2fac
    }
    *pq->OSQIn++ = msg;                                /* Insert message into queue                    */
    2f52:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f56:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    2f5a:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    2f5e:	00 00 
    2f60:	0e 4f       	mov	r15,	r14	
    2f62:	2e 53       	incd	r14		
    2f64:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f68:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
    2f6c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f70:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2f74:	0e 4f       	mov	r15,	r14	
    2f76:	1e 53       	inc	r14		
    2f78:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f7c:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
    2f80:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f84:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    2f88:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f8c:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2f90:	0e 9f       	cmp	r15,	r14	
    2f92:	08 20       	jnz	$+18     	;abs 0x2fa4
        pq->OSQIn = pq->OSQStart;
    2f94:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f98:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2f9c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fa0:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    }
    OS_EXIT_CRITICAL();
    2fa4:	2f 44       	mov	@r4,	r15	
    2fa6:	b0 12 d0 13 	call	#0x13d0	
    return (OS_NO_ERR);
    2faa:	4f 43       	clr.b	r15		
}
    2fac:	31 52       	add	#8,	r1	;r2 As==11
    2fae:	34 41       	pop	r4		
    2fb0:	30 41       	ret			

00002fb2 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *msg)
{
    2fb2:	04 12       	push	r4		
    2fb4:	31 82       	sub	#8,	r1	;r2 As==11
    2fb6:	04 41       	mov	r1,	r4	
    2fb8:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2fbc:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2fc0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
    2fc4:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2fc8:	6f 4f       	mov.b	@r15,	r15	
    2fca:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    2fcc:	02 24       	jz	$+6      	;abs 0x2fd2
        return (OS_ERR_EVENT_TYPE);
    2fce:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2fd0:	5f 3c       	jmp	$+192    	;abs 0x3090
    }
    OS_ENTER_CRITICAL();
    2fd2:	b0 12 ca 13 	call	#0x13ca	
    2fd6:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
    2fda:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2fde:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2fe2:	4f 93       	tst.b	r15		
    2fe4:	0e 24       	jz	$+30     	;abs 0x3002
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);/* Ready highest priority task waiting on event  */
    2fe6:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    2fea:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2fee:	6d 42       	mov.b	#4,	r13	;r2 As==10
    2ff0:	b0 12 d0 18 	call	#0x18d0	
        OS_EXIT_CRITICAL();
    2ff4:	2f 44       	mov	@r4,	r15	
    2ff6:	b0 12 d0 13 	call	#0x13d0	
        OS_Sched();                                   /* Find highest priority task ready to run       */
    2ffa:	b0 12 5e 1d 	call	#0x1d5e	
        return (OS_NO_ERR);
    2ffe:	4f 43       	clr.b	r15		
    3000:	47 3c       	jmp	$+144    	;abs 0x3090
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    3002:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3006:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    300a:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
    300e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3012:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    3016:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    301a:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    301e:	0e 9f       	cmp	r15,	r14	
    3020:	06 28       	jnc	$+14     	;abs 0x302e
        OS_EXIT_CRITICAL();
    3022:	2f 44       	mov	@r4,	r15	
    3024:	b0 12 d0 13 	call	#0x13d0	
        return (OS_Q_FULL);
    3028:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    302c:	31 3c       	jmp	$+100    	;abs 0x3090
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
    302e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3032:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    3036:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    303a:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    303e:	0e 9f       	cmp	r15,	r14	
    3040:	08 20       	jnz	$+18     	;abs 0x3052
        pq->OSQOut = pq->OSQEnd;
    3042:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3046:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    304a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    304e:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    }
    pq->OSQOut--;
    3052:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3056:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    305a:	0e 4f       	mov	r15,	r14	
    305c:	2e 83       	decd	r14		
    305e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3062:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    *pq->OSQOut = msg;                                /* Insert message into queue                     */
    3066:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    306a:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    306e:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    3072:	00 00 
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    3074:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3078:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    307c:	0e 4f       	mov	r15,	r14	
    307e:	1e 53       	inc	r14		
    3080:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3084:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    OS_EXIT_CRITICAL();
    3088:	2f 44       	mov	@r4,	r15	
    308a:	b0 12 d0 13 	call	#0x13d0	
    return (OS_NO_ERR);
    308e:	4f 43       	clr.b	r15		
}
    3090:	31 52       	add	#8,	r1	;r2 As==11
    3092:	34 41       	pop	r4		
    3094:	30 41       	ret			

00003096 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
    3096:	04 12       	push	r4		
    3098:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    309c:	04 41       	mov	r1,	r4	
    309e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    30a2:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    30a6:	c4 4d 08 00 	mov.b	r13,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
                     


    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    30aa:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
    30ae:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    30b2:	6f 4f       	mov.b	@r15,	r15	
    30b4:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    30b6:	02 24       	jz	$+6      	;abs 0x30bc
        return (OS_ERR_EVENT_TYPE);
    30b8:	5f 43       	mov.b	#1,	r15	;r3 As==01
    30ba:	97 3c       	jmp	$+304    	;abs 0x31ea
    }
    OS_ENTER_CRITICAL();
    30bc:	b0 12 ca 13 	call	#0x13ca	
    30c0:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
    30c4:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    30c8:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    30cc:	4f 93       	tst.b	r15		
    30ce:	22 24       	jz	$+70     	;abs 0x3114
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
    30d0:	5f 44 08 00 	mov.b	8(r4),	r15	;0x0008(r4)
    30d4:	1f f3       	and	#1,	r15	;r3 As==01
    30d6:	4f 93       	tst.b	r15		
    30d8:	0f 24       	jz	$+32     	;abs 0x30f8
    30da:	07 3c       	jmp	$+16     	;abs 0x30ea
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
    30dc:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    30e0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    30e4:	6d 42       	mov.b	#4,	r13	;r2 As==10
    30e6:	b0 12 d0 18 	call	#0x18d0	
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
    30ea:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    30ee:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    30f2:	4f 93       	tst.b	r15		
    30f4:	f3 23       	jnz	$-24     	;abs 0x30dc
    30f6:	07 3c       	jmp	$+16     	;abs 0x3106
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);  /* No,  Post to HPT waiting on queue       */
    30f8:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    30fc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3100:	6d 42       	mov.b	#4,	r13	;r2 As==10
    3102:	b0 12 d0 18 	call	#0x18d0	
        }
        OS_EXIT_CRITICAL();
    3106:	2f 44       	mov	@r4,	r15	
    3108:	b0 12 d0 13 	call	#0x13d0	
        OS_Sched();                                         /* Find highest priority task ready to run */
    310c:	b0 12 5e 1d 	call	#0x1d5e	
        return (OS_NO_ERR);
    3110:	4f 43       	clr.b	r15		
    3112:	6b 3c       	jmp	$+216    	;abs 0x31ea
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    3114:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3118:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    311c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
    3120:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3124:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    3128:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    312c:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    3130:	0e 9f       	cmp	r15,	r14	
    3132:	06 28       	jnc	$+14     	;abs 0x3140
        OS_EXIT_CRITICAL();
    3134:	2f 44       	mov	@r4,	r15	
    3136:	b0 12 d0 13 	call	#0x13d0	
        return (OS_Q_FULL);
    313a:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    313e:	55 3c       	jmp	$+172    	;abs 0x31ea
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
    3140:	5f 44 08 00 	mov.b	8(r4),	r15	;0x0008(r4)
    3144:	2f f3       	and	#2,	r15	;r3 As==10
    3146:	24 24       	jz	$+74     	;abs 0x3190
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
    3148:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    314c:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    3150:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3154:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    3158:	0e 9f       	cmp	r15,	r14	
    315a:	08 20       	jnz	$+18     	;abs 0x316c
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
    315c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3160:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    3164:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3168:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        pq->OSQOut--;
    316c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3170:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    3174:	0e 4f       	mov	r15,	r14	
    3176:	2e 83       	decd	r14		
    3178:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    317c:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        *pq->OSQOut = msg;                            /*      Insert message into queue                */
    3180:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3184:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    3188:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    318c:	00 00 
    318e:	1f 3c       	jmp	$+64     	;abs 0x31ce
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = msg;                           /*      Insert message into queue                */
    3190:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3194:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    3198:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    319c:	00 00 
    319e:	0e 4f       	mov	r15,	r14	
    31a0:	2e 53       	incd	r14		
    31a2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31a6:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
    31aa:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31ae:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    31b2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31b6:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    31ba:	0e 9f       	cmp	r15,	r14	
    31bc:	08 20       	jnz	$+18     	;abs 0x31ce
            pq->OSQIn = pq->OSQStart;
    31be:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31c2:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    31c6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31ca:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    31ce:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31d2:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    31d6:	0e 4f       	mov	r15,	r14	
    31d8:	1e 53       	inc	r14		
    31da:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31de:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    OS_EXIT_CRITICAL();
    31e2:	2f 44       	mov	@r4,	r15	
    31e4:	b0 12 d0 13 	call	#0x13d0	
    return (OS_NO_ERR);
    31e8:	4f 43       	clr.b	r15		
}
    31ea:	31 50 0a 00 	add	#10,	r1	;#0x000a
    31ee:	34 41       	pop	r4		
    31f0:	30 41       	ret			

000031f2 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
    31f2:	04 12       	push	r4		
    31f4:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    31f8:	04 41       	mov	r1,	r4	
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    31fa:	3f 40 2c 03 	mov	#812,	r15	;#0x032c
    31fe:	3e 40 1c 00 	mov	#28,	r14	;#0x001c
    3202:	b0 12 f8 1c 	call	#0x1cf8	
    pq1 = &OSQTbl[0];
    3206:	b4 40 2c 03 	mov	#812,	2(r4)	;#0x032c, 0x0002(r4)
    320a:	02 00 
    pq2 = &OSQTbl[1];
    320c:	b4 40 3a 03 	mov	#826,	0(r4)	;#0x033a, 0x0000(r4)
    3210:	00 00 
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
    3212:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    3216:	0c 3c       	jmp	$+26     	;abs 0x3230
        pq1->OSQPtr = pq2;
    3218:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    321c:	af 44 00 00 	mov	@r4,	0(r15)	;0x0000(r15)
        pq1++;
    3220:	b4 50 0e 00 	add	#14,	2(r4)	;#0x000e, 0x0002(r4)
    3224:	02 00 
        pq2++;
    3226:	b4 50 0e 00 	add	#14,	0(r4)	;#0x000e, 0x0000(r4)
    322a:	00 00 


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
    322c:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    3230:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    3234:	f1 27       	jz	$-28     	;abs 0x3218
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
    3236:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    323a:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OSQFreeList = &OSQTbl[0];
    323e:	b2 40 2c 03 	mov	#812,	&0x034a	;#0x032c
    3242:	4a 03 
#endif
}
    3244:	31 50 06 00 	add	#6,	r1	;#0x0006
    3248:	34 41       	pop	r4		
    324a:	30 41       	ret			

0000324c <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
    324c:	04 12       	push	r4		
    324e:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3252:	04 41       	mov	r1,	r4	
    3254:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    3258:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
    325c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3260:	6f 4f       	mov.b	@r15,	r15	
    3262:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    3266:	02 24       	jz	$+6      	;abs 0x326c
        return (0);
    3268:	0f 43       	clr	r15		
    326a:	1b 3c       	jmp	$+56     	;abs 0x32a2
    }
    OS_ENTER_CRITICAL();
    326c:	b0 12 ca 13 	call	#0x13ca	
    3270:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    cnt = pevent->OSEventCnt;
    3274:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3278:	94 4f 02 00 	mov	2(r15),	2(r4)	;0x0002(r15), 0x0002(r4)
    327c:	02 00 
    if (cnt > 0) {                                    /* See if resource is available                  */
    327e:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3282:	0a 24       	jz	$+22     	;abs 0x3298
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
    3284:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3288:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    328c:	0e 4f       	mov	r15,	r14	
    328e:	3e 53       	add	#-1,	r14	;r3 As==11
    3290:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3294:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
    }
    OS_EXIT_CRITICAL();
    3298:	2f 44       	mov	@r4,	r15	
    329a:	b0 12 d0 13 	call	#0x13d0	
    return (cnt);                                     /* Return semaphore count                        */
    329e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    32a2:	31 50 06 00 	add	#6,	r1	;#0x0006
    32a6:	34 41       	pop	r4		
    32a8:	30 41       	ret			

000032aa <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
    32aa:	04 12       	push	r4		
    32ac:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    32b0:	04 41       	mov	r1,	r4	
    32b2:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    32b6:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
    32ba:	5f 42 52 03 	mov.b	&0x0352,r15	
    32be:	4f 93       	tst.b	r15		
    32c0:	02 24       	jz	$+6      	;abs 0x32c6
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
    32c2:	0f 43       	clr	r15		
    32c4:	2b 3c       	jmp	$+88     	;abs 0x331c
    }
    OS_ENTER_CRITICAL();
    32c6:	b0 12 ca 13 	call	#0x13ca	
    32ca:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
    32ce:	94 42 50 03 	mov	&0x0350,2(r4)	;0x0002(r4)
    32d2:	02 00 
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
    32d4:	1f 42 50 03 	mov	&0x0350,r15	
    32d8:	0f 93       	tst	r15		
    32da:	06 24       	jz	$+14     	;abs 0x32e8
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    32dc:	1f 42 50 03 	mov	&0x0350,r15	
    32e0:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    32e4:	82 4f 50 03 	mov	r15,	&0x0350	
    }
    OS_EXIT_CRITICAL();
    32e8:	2f 44       	mov	@r4,	r15	
    32ea:	b0 12 d0 13 	call	#0x13d0	
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
    32ee:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    32f2:	12 24       	jz	$+38     	;abs 0x3318
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
    32f4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    32f8:	ff 40 03 00 	mov.b	#3,	0(r15)	;#0x0003, 0x0000(r15)
    32fc:	00 00 
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
    32fe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3302:	9f 44 04 00 	mov	4(r4),	2(r15)	;0x0004(r4), 0x0002(r15)
    3306:	02 00 
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
    3308:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    330c:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
    3310:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3314:	b0 12 54 1b 	call	#0x1b54	
    }
    return (pevent);
    3318:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    331c:	31 50 06 00 	add	#6,	r1	;#0x0006
    3320:	34 41       	pop	r4		
    3322:	30 41       	ret			

00003324 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/

void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    3324:	04 12       	push	r4		
    3326:	31 82       	sub	#8,	r1	;r2 As==11
    3328:	04 41       	mov	r1,	r4	
    332a:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    332e:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    3332:	84 4d 06 00 	mov	r13,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    3336:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
    333a:	5f 42 52 03 	mov.b	&0x0352,r15	
    333e:	4f 93       	tst.b	r15		
    3340:	05 24       	jz	$+12     	;abs 0x334c
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
    3342:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3346:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
    334a:	64 3c       	jmp	$+202    	;abs 0x3414
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
    334c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3350:	6f 4f       	mov.b	@r15,	r15	
    3352:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    3356:	05 24       	jz	$+12     	;abs 0x3362
        *err = OS_ERR_EVENT_TYPE;
    3358:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    335c:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
    3360:	59 3c       	jmp	$+180    	;abs 0x3414
        return;
    }
    OS_ENTER_CRITICAL();
    3362:	b0 12 ca 13 	call	#0x13ca	
    3366:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
    336a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    336e:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    3372:	0f 93       	tst	r15		
    3374:	12 24       	jz	$+38     	;abs 0x339a
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
    3376:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    337a:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    337e:	0e 4f       	mov	r15,	r14	
    3380:	3e 53       	add	#-1,	r14	;r3 As==11
    3382:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3386:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
        OS_EXIT_CRITICAL();
    338a:	2f 44       	mov	@r4,	r15	
    338c:	b0 12 d0 13 	call	#0x13d0	
        *err = OS_NO_ERR;
    3390:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3394:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    3398:	3d 3c       	jmp	$+124    	;abs 0x3414
        return;
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat   |= OS_STAT_SEM;             /* Resource not available, pend on semaphore     */
    339a:	1f 42 54 03 	mov	&0x0354,r15	
    339e:	1e 42 54 03 	mov	&0x0354,r14	
    33a2:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    33a6:	5e d3       	bis.b	#1,	r14	;r3 As==01
    33a8:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO  = FALSE;
    33ac:	1f 42 54 03 	mov	&0x0354,r15	
    33b0:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly     = timeout;                 /* Store pend timeout in TCB                     */
    33b4:	1f 42 54 03 	mov	&0x0354,r15	
    33b8:	9f 44 04 00 	mov	4(r4),	24(r15)	;0x0004(r4), 0x0018(r15)
    33bc:	18 00 
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    33be:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33c2:	b0 12 12 1a 	call	#0x1a12	
    OS_EXIT_CRITICAL();
    33c6:	2f 44       	mov	@r4,	r15	
    33c8:	b0 12 d0 13 	call	#0x13d0	
    OS_Sched();                                       /* Find next highest priority task ready         */
    33cc:	b0 12 5e 1d 	call	#0x1d5e	
    OS_ENTER_CRITICAL();
    33d0:	b0 12 ca 13 	call	#0x13ca	
    33d4:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we timedout                            */
    33d8:	1f 42 54 03 	mov	&0x0354,r15	
    33dc:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    33e0:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    33e2:	0d 20       	jnz	$+28     	;abs 0x33fe
        OS_EventTO(pevent);
    33e4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33e8:	b0 12 c2 1a 	call	#0x1ac2	
        OS_EXIT_CRITICAL();
    33ec:	2f 44       	mov	@r4,	r15	
    33ee:	b0 12 d0 13 	call	#0x13d0	
        *err = OS_TIMEOUT;                            /* Indicate that didn't get event within TO      */
    33f2:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    33f6:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    33fa:	00 00 
    33fc:	0b 3c       	jmp	$+24     	;abs 0x3414
        return;
    }
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
    33fe:	1f 42 54 03 	mov	&0x0354,r15	
    3402:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    3406:	2f 44       	mov	@r4,	r15	
    3408:	b0 12 d0 13 	call	#0x13d0	
    *err = OS_NO_ERR;
    340c:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3410:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
}
    3414:	31 52       	add	#8,	r1	;r2 As==11
    3416:	34 41       	pop	r4		
    3418:	30 41       	ret			

0000341a <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
    341a:	04 12       	push	r4		
    341c:	21 82       	sub	#4,	r1	;r2 As==10
    341e:	04 41       	mov	r1,	r4	
    3420:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;                               



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    3424:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
    3428:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    342c:	6f 4f       	mov.b	@r15,	r15	
    342e:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    3432:	02 24       	jz	$+6      	;abs 0x3438
        return (OS_ERR_EVENT_TYPE);
    3434:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3436:	32 3c       	jmp	$+102    	;abs 0x349c
    }
    OS_ENTER_CRITICAL();
    3438:	b0 12 ca 13 	call	#0x13ca	
    343c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                          /* See if any task waiting for semaphore*/
    3440:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3444:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3448:	4f 93       	tst.b	r15		
    344a:	0e 24       	jz	$+30     	;abs 0x3468
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM); /* Ready HPT waiting on event           */
    344c:	5e 43       	mov.b	#1,	r14	;r3 As==01
    344e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3452:	4d 4e       	mov.b	r14,	r13	
    3454:	0e 43       	clr	r14		
    3456:	b0 12 d0 18 	call	#0x18d0	
        OS_EXIT_CRITICAL();
    345a:	2f 44       	mov	@r4,	r15	
    345c:	b0 12 d0 13 	call	#0x13d0	
        OS_Sched();                                            /* Find HPT ready to run                */
    3460:	b0 12 5e 1d 	call	#0x1d5e	
        return (OS_NO_ERR);
    3464:	4f 43       	clr.b	r15		
    3466:	1a 3c       	jmp	$+54     	;abs 0x349c
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
    3468:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    346c:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    3470:	3f 93       	cmp	#-1,	r15	;r3 As==11
    3472:	0f 24       	jz	$+32     	;abs 0x3492
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
    3474:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3478:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    347c:	0e 4f       	mov	r15,	r14	
    347e:	1e 53       	inc	r14		
    3480:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3484:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
        OS_EXIT_CRITICAL();
    3488:	2f 44       	mov	@r4,	r15	
    348a:	b0 12 d0 13 	call	#0x13d0	
        return (OS_NO_ERR);
    348e:	4f 43       	clr.b	r15		
    3490:	05 3c       	jmp	$+12     	;abs 0x349c
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    3492:	2f 44       	mov	@r4,	r15	
    3494:	b0 12 d0 13 	call	#0x13d0	
    return (OS_SEM_OVF);
    3498:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
}
    349c:	21 52       	add	#4,	r1	;r2 As==10
    349e:	34 41       	pop	r4		
    34a0:	30 41       	ret			

000034a2 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
    34a2:	04 12       	push	r4		
    34a4:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    34a8:	04 41       	mov	r1,	r4	
    34aa:	c4 4f 0c 00 	mov.b	r15,	12(r4)	;0x000c(r4)
    34ae:	c4 4e 0d 00 	mov.b	r14,	13(r4)	;0x000d(r4)
#if OS_CRITICAL_METHOD == 3                                     
    OS_CPU_SR    cpu_sr;                                        /* Storage for CPU status register     */



    cpu_sr = 0;                                                 /* Prevent compiler warning            */
    34b2:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
	}
    if (newprio >= OS_LOWEST_PRIO) {
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    34b6:	b0 12 ca 13 	call	#0x13ca	
    34ba:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already exist */
    34be:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    34c2:	0f 5f       	rla	r15		
    34c4:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    34c8:	2f 4f       	mov	@r15,	r15	
    34ca:	0f 93       	tst	r15		
    34cc:	06 24       	jz	$+14     	;abs 0x34da
        OS_EXIT_CRITICAL();
    34ce:	2f 44       	mov	@r4,	r15	
    34d0:	b0 12 d0 13 	call	#0x13d0	
        return (OS_PRIO_EXIST);
    34d4:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
    34d8:	01 3d       	jmp	$+516    	;abs 0x36dc
    } 
    if (oldprio == OS_PRIO_SELF) {                              /* See if changing self                */
    34da:	f4 93 0c 00 	cmp.b	#-1,	12(r4)	;r3 As==11, 0x000c(r4)
    34de:	05 20       	jnz	$+12     	;abs 0x34ea
        oldprio = OSTCBCur->OSTCBPrio;                          /* Yes, get priority                   */
    34e0:	1f 42 54 03 	mov	&0x0354,r15	
    34e4:	d4 4f 1c 00 	mov.b	28(r15),12(r4)	;0x001c(r15), 0x000c(r4)
    34e8:	0c 00 
    }
    ptcb = OSTCBPrioTbl[oldprio];
    34ea:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    34ee:	0f 5f       	rla	r15		
    34f0:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    34f4:	a4 4f 08 00 	mov	@r15,	8(r4)	;0x0008(r4)
    if (ptcb == (OS_TCB *)0) {                                  /* Does task to change exist?          */
    34f8:	84 93 08 00 	tst	8(r4)		;0x0008(r4)
    34fc:	06 20       	jnz	$+14     	;abs 0x350a
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
    34fe:	2f 44       	mov	@r4,	r15	
    3500:	b0 12 d0 13 	call	#0x13d0	
        return (OS_PRIO_ERR);
    3504:	7f 40 29 00 	mov.b	#41,	r15	;#0x0029
    3508:	e9 3c       	jmp	$+468    	;abs 0x36dc
    }                                       
    if (ptcb == (OS_TCB *)1) {                                  /* Is task assigned to Mutex           */
    350a:	94 93 08 00 	cmp	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    350e:	06 20       	jnz	$+14     	;abs 0x351c
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
    3510:	2f 44       	mov	@r4,	r15	
    3512:	b0 12 d0 13 	call	#0x13d0	
        return (OS_TASK_NOT_EXIST);
    3516:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    351a:	e0 3c       	jmp	$+450    	;abs 0x36dc
    }                                       
    y                     = newprio >> 3;                       /* Yes, compute new TCB fields         */
    351c:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    3520:	12 c3       	clrc			
    3522:	4f 10       	rrc.b	r15		
    3524:	4f 11       	rra.b	r15		
    3526:	4f 11       	rra.b	r15		
    3528:	c4 4f 05 00 	mov.b	r15,	5(r4)	;0x0005(r4)
    bity                  = OSMapTbl[y];
    352c:	5f 44 05 00 	mov.b	5(r4),	r15	;0x0005(r4)
    3530:	d4 4f 14 15 	mov.b	5396(r15),3(r4)	;0x1514(r15), 0x0003(r4)
    3534:	03 00 
    x                     = newprio & 0x07;
    3536:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    353a:	7f f0 07 00 	and.b	#7,	r15	;#0x0007
    353e:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
    bitx                  = OSMapTbl[x];
    3542:	5f 44 06 00 	mov.b	6(r4),	r15	;0x0006(r4)
    3546:	d4 4f 14 15 	mov.b	5396(r15),4(r4)	;0x1514(r15), 0x0004(r4)
    354a:	04 00 
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
    354c:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    3550:	0f 5f       	rla	r15		
    3552:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    3556:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
    355a:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    355e:	0f 5f       	rla	r15		
    3560:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    3564:	9f 44 08 00 	mov	8(r4),	0(r15)	;0x0008(r4), 0x0000(r15)
    3568:	00 00 
    y_old                 = ptcb->OSTCBY;
    356a:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    356e:	d4 4f 1e 00 	mov.b	30(r15),2(r4)	;0x001e(r15), 0x0002(r4)
    3572:	02 00 
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0x00) {          /* If task is ready make it not        */
    3574:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3578:	5e 4f 4e 03 	mov.b	846(r15),r14	;0x034e(r15)
    357c:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3580:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    3584:	4f fe       	and.b	r14,	r15	
    3586:	31 24       	jz	$+100    	;abs 0x35ea
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
    3588:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    358c:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3590:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    3594:	4e 4f       	mov.b	r15,	r14	
    3596:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    359a:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    359e:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    35a0:	4f fe       	and.b	r14,	r15	
    35a2:	cd 4f 4e 03 	mov.b	r15,	846(r13);0x034e(r13)
        if (OSRdyTbl[y_old] == 0x00) {
    35a6:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    35aa:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    35ae:	4f 93       	tst.b	r15		
    35b0:	0b 20       	jnz	$+24     	;abs 0x35c8
            OSRdyGrp &= ~ptcb->OSTCBBitY;
    35b2:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    35b6:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    35ba:	4e 4f       	mov.b	r15,	r14	
    35bc:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    35be:	5f 42 4c 03 	mov.b	&0x034c,r15	
    35c2:	4f fe       	and.b	r14,	r15	
    35c4:	c2 4f 4c 03 	mov.b	r15,	&0x034c	
        }
        OSRdyGrp    |= bity;                                    /* Make new priority ready to run      */
    35c8:	5f 42 4c 03 	mov.b	&0x034c,r15	
    35cc:	5f d4 03 00 	bis.b	3(r4),	r15	;0x0003(r4)
    35d0:	c2 4f 4c 03 	mov.b	r15,	&0x034c	
        OSRdyTbl[y] |= bitx;
    35d4:	5e 44 05 00 	mov.b	5(r4),	r14	;0x0005(r4)
    35d8:	5f 44 05 00 	mov.b	5(r4),	r15	;0x0005(r4)
    35dc:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    35e0:	5f d4 04 00 	bis.b	4(r4),	r15	;0x0004(r4)
    35e4:	ce 4f 4e 03 	mov.b	r15,	846(r14);0x034e(r14)
    35e8:	5a 3c       	jmp	$+182    	;abs 0x369e
#if OS_EVENT_EN
    } else {                                                    /* Task was not ready ...              */
        pevent = ptcb->OSTCBEventPtr;
    35ea:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    35ee:	94 4f 12 00 	mov	18(r15),10(r4)	;0x0012(r15), 0x000a(r4)
    35f2:	0a 00 
        if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list     */
    35f4:	84 93 0a 00 	tst	10(r4)		;0x000a(r4)
    35f8:	52 24       	jz	$+166    	;abs 0x369e
            pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
    35fa:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    35fe:	5e 44 02 00 	mov.b	2(r4),	r14	;0x0002(r4)
    3602:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3606:	0f 5e       	add	r14,	r15	
    3608:	3f 50 06 00 	add	#6,	r15	;#0x0006
    360c:	6f 4f       	mov.b	@r15,	r15	
    360e:	4e 4f       	mov.b	r15,	r14	
    3610:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3614:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    3618:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    361a:	4f fe       	and.b	r14,	r15	
    361c:	4e 4f       	mov.b	r15,	r14	
    361e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3622:	0f 5d       	add	r13,	r15	
    3624:	3f 50 06 00 	add	#6,	r15	;#0x0006
    3628:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
            if (pevent->OSEventTbl[y_old] == 0) {
    362c:	5e 44 02 00 	mov.b	2(r4),	r14	;0x0002(r4)
    3630:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3634:	0f 5e       	add	r14,	r15	
    3636:	3f 50 06 00 	add	#6,	r15	;#0x0006
    363a:	6f 4f       	mov.b	@r15,	r15	
    363c:	4f 93       	tst.b	r15		
    363e:	10 20       	jnz	$+34     	;abs 0x3660
                pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
    3640:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3644:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3648:	4e 4f       	mov.b	r15,	r14	
    364a:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    364e:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    3652:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    3654:	4f fe       	and.b	r14,	r15	
    3656:	4e 4f       	mov.b	r15,	r14	
    3658:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    365c:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
            }
            pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list       */
    3660:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3664:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3668:	4e 4f       	mov.b	r15,	r14	
    366a:	5e d4 03 00 	bis.b	3(r4),	r14	;0x0003(r4)
    366e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3672:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
            pevent->OSEventTbl[y] |= bitx;
    3676:	5d 44 05 00 	mov.b	5(r4),	r13	;0x0005(r4)
    367a:	5e 44 05 00 	mov.b	5(r4),	r14	;0x0005(r4)
    367e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3682:	0f 5e       	add	r14,	r15	
    3684:	3f 50 06 00 	add	#6,	r15	;#0x0006
    3688:	6f 4f       	mov.b	@r15,	r15	
    368a:	4e 4f       	mov.b	r15,	r14	
    368c:	5e d4 04 00 	bis.b	4(r4),	r14	;0x0004(r4)
    3690:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3694:	0f 5d       	add	r13,	r15	
    3696:	3f 50 06 00 	add	#6,	r15	;#0x0006
    369a:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
        }
#endif
    }
    ptcb->OSTCBPrio = newprio;                                  /* Set new task priority               */
    369e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36a2:	df 44 0d 00 	mov.b	13(r4),	28(r15)	;0x000d(r4), 0x001c(r15)
    36a6:	1c 00 
    ptcb->OSTCBY    = y;
    36a8:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36ac:	df 44 05 00 	mov.b	5(r4),	30(r15)	;0x0005(r4), 0x001e(r15)
    36b0:	1e 00 
    ptcb->OSTCBX    = x;
    36b2:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36b6:	df 44 06 00 	mov.b	6(r4),	29(r15)	;0x0006(r4), 0x001d(r15)
    36ba:	1d 00 
    ptcb->OSTCBBitY = bity;
    36bc:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36c0:	df 44 03 00 	mov.b	3(r4),	32(r15)	;0x0003(r4), 0x0020(r15)
    36c4:	20 00 
    ptcb->OSTCBBitX = bitx;
    36c6:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36ca:	df 44 04 00 	mov.b	4(r4),	31(r15)	;0x0004(r4), 0x001f(r15)
    36ce:	1f 00 
    OS_EXIT_CRITICAL();
    36d0:	2f 44       	mov	@r4,	r15	
    36d2:	b0 12 d0 13 	call	#0x13d0	
    OS_Sched();                                                 /* Run highest priority task ready     */
    36d6:	b0 12 5e 1d 	call	#0x1d5e	
    return (OS_NO_ERR);
    36da:	4f 43       	clr.b	r15		
}
    36dc:	31 50 0e 00 	add	#14,	r1	;#0x000e
    36e0:	34 41       	pop	r4		
    36e2:	30 41       	ret			

000036e4 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT8U prio)
{
    36e4:	04 12       	push	r4		
    36e6:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    36ea:	04 41       	mov	r1,	r4	
    36ec:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    36f0:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    36f4:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
    36f8:	c4 4c 0c 00 	mov.b	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                              /* Prevent compiler warning                               */
    36fc:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    3700:	b0 12 ca 13 	call	#0x13ca	
    3704:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
    3708:	5f 42 52 03 	mov.b	&0x0352,r15	
    370c:	4f 93       	tst.b	r15		
    370e:	06 24       	jz	$+14     	;abs 0x371c
        OS_EXIT_CRITICAL();
    3710:	2f 44       	mov	@r4,	r15	
    3712:	b0 12 d0 13 	call	#0x13d0	
        return (OS_ERR_TASK_CREATE_ISR);
    3716:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    371a:	4e 3c       	jmp	$+158    	;abs 0x37b8
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
    371c:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    3720:	0f 5f       	rla	r15		
    3722:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    3726:	2f 4f       	mov	@r15,	r15	
    3728:	0f 93       	tst	r15		
    372a:	41 20       	jnz	$+132    	;abs 0x37ae
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
    372c:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    3730:	0f 5f       	rla	r15		
    3732:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    3736:	9f 43 00 00 	mov	#1,	0(r15)	;r3 As==01, 0x0000(r15)
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
    373a:	2f 44       	mov	@r4,	r15	
    373c:	b0 12 d0 13 	call	#0x13d0	
        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, 0);    /* Initialize the task's stack         */
    3740:	1d 44 0a 00 	mov	10(r4),	r13	;0x000a(r4)
    3744:	1e 44 08 00 	mov	8(r4),	r14	;0x0008(r4)
    3748:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    374c:	0c 43       	clr	r12		
    374e:	b0 12 14 14 	call	#0x1414	
    3752:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
    3756:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    375a:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    375e:	03 12       	push	#0		;r3 As==00
    3760:	03 12       	push	#0		;r3 As==00
    3762:	03 12       	push	#0		;r3 As==00
    3764:	03 12       	push	#0		;r3 As==00
    3766:	0c 43       	clr	r12		
    3768:	0d 43       	clr	r13		
    376a:	b0 12 3c 1e 	call	#0x1e3c	
    376e:	31 52       	add	#8,	r1	;r2 As==11
    3770:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
        if (err == OS_NO_ERR) {
    3774:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    3778:	07 20       	jnz	$+16     	;abs 0x3788
            if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has started */
    377a:	5f 42 05 03 	mov.b	&0x0305,r15	
    377e:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    3780:	12 20       	jnz	$+38     	;abs 0x37a6
                OS_Sched();
    3782:	b0 12 5e 1d 	call	#0x1d5e	
    3786:	10 3c       	jmp	$+34     	;abs 0x37a8
            }
        } else {
            OS_ENTER_CRITICAL();
    3788:	b0 12 ca 13 	call	#0x13ca	
    378c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
    3790:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    3794:	0f 5f       	rla	r15		
    3796:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    379a:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
            OS_EXIT_CRITICAL();
    379e:	2f 44       	mov	@r4,	r15	
    37a0:	b0 12 d0 13 	call	#0x13d0	
    37a4:	01 3c       	jmp	$+4      	;abs 0x37a8
        OS_EXIT_CRITICAL();
        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, 0);    /* Initialize the task's stack         */
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
        if (err == OS_NO_ERR) {
            if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has started */
                OS_Sched();
    37a6:	03 43       	nop			
        } else {
            OS_ENTER_CRITICAL();
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
            OS_EXIT_CRITICAL();
        }
        return (err);
    37a8:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    37ac:	05 3c       	jmp	$+12     	;abs 0x37b8
    }
    OS_EXIT_CRITICAL();
    37ae:	2f 44       	mov	@r4,	r15	
    37b0:	b0 12 d0 13 	call	#0x13d0	
    return (OS_PRIO_EXIST);
    37b4:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
}
    37b8:	31 50 0e 00 	add	#14,	r1	;#0x000e
    37bc:	34 41       	pop	r4		
    37be:	30 41       	ret			

000037c0 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
    37c0:	0b 12       	push	r11		
    37c2:	04 12       	push	r4		
    37c4:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    37c8:	04 41       	mov	r1,	r4	
    37ca:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    37ce:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    37d2:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
    37d6:	c4 4c 0c 00 	mov.b	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                              /* Prevent compiler warning                               */
    37da:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    37de:	b0 12 ca 13 	call	#0x13ca	
    37e2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
    37e6:	5f 42 52 03 	mov.b	&0x0352,r15	
    37ea:	4f 93       	tst.b	r15		
    37ec:	06 24       	jz	$+14     	;abs 0x37fa
        OS_EXIT_CRITICAL();
    37ee:	2f 44       	mov	@r4,	r15	
    37f0:	b0 12 d0 13 	call	#0x13d0	
        return (OS_ERR_TASK_CREATE_ISR);
    37f4:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    37f8:	63 3c       	jmp	$+200    	;abs 0x38c0
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
    37fa:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    37fe:	0f 5f       	rla	r15		
    3800:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    3804:	2f 4f       	mov	@r15,	r15	
    3806:	0f 93       	tst	r15		
    3808:	56 20       	jnz	$+174    	;abs 0x38b6
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
    380a:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    380e:	0f 5f       	rla	r15		
    3810:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    3814:	9f 43 00 00 	mov	#1,	0(r15)	;r3 As==01, 0x0000(r15)
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
    3818:	2f 44       	mov	@r4,	r15	
    381a:	b0 12 d0 13 	call	#0x13d0	

        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
    381e:	1d 44 1e 00 	mov	30(r4),	r13	;0x001e(r4)
    3822:	1e 44 18 00 	mov	24(r4),	r14	;0x0018(r4)
    3826:	1f 44 1a 00 	mov	26(r4),	r15	;0x001a(r4)
    382a:	1b 44 16 00 	mov	22(r4),	r11	;0x0016(r4)
    382e:	0c 4d       	mov	r13,	r12	
    3830:	0d 4e       	mov	r14,	r13	
    3832:	0e 4f       	mov	r15,	r14	
    3834:	0f 4b       	mov	r11,	r15	
    3836:	b0 12 e2 39 	call	#0x39e2	

        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, opt); /* Initialize the task's stack          */
    383a:	1c 44 1e 00 	mov	30(r4),	r12	;0x001e(r4)
    383e:	1d 44 0a 00 	mov	10(r4),	r13	;0x000a(r4)
    3842:	1e 44 08 00 	mov	8(r4),	r14	;0x0008(r4)
    3846:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    384a:	b0 12 14 14 	call	#0x1414	
    384e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
    3852:	1d 44 16 00 	mov	22(r4),	r13	;0x0016(r4)
    3856:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    385a:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    385e:	14 12 1e 00 	push	30(r4)		;0x001e(r4)
    3862:	14 12 1c 00 	push	28(r4)		;0x001c(r4)
    3866:	14 12 1a 00 	push	26(r4)		;0x001a(r4)
    386a:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    386e:	1c 44 14 00 	mov	20(r4),	r12	;0x0014(r4)
    3872:	b0 12 3c 1e 	call	#0x1e3c	
    3876:	31 52       	add	#8,	r1	;r2 As==11
    3878:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
        if (err == OS_NO_ERR) {
    387c:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    3880:	07 20       	jnz	$+16     	;abs 0x3890
            if (OSRunning == TRUE) {                           /* Find HPT if multitasking has started */
    3882:	5f 42 05 03 	mov.b	&0x0305,r15	
    3886:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    3888:	12 20       	jnz	$+38     	;abs 0x38ae
                OS_Sched();
    388a:	b0 12 5e 1d 	call	#0x1d5e	
    388e:	10 3c       	jmp	$+34     	;abs 0x38b0
            }
        } else {
            OS_ENTER_CRITICAL();
    3890:	b0 12 ca 13 	call	#0x13ca	
    3894:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
    3898:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    389c:	0f 5f       	rla	r15		
    389e:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    38a2:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
            OS_EXIT_CRITICAL();
    38a6:	2f 44       	mov	@r4,	r15	
    38a8:	b0 12 d0 13 	call	#0x13d0	
    38ac:	01 3c       	jmp	$+4      	;abs 0x38b0

        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, opt); /* Initialize the task's stack          */
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
        if (err == OS_NO_ERR) {
            if (OSRunning == TRUE) {                           /* Find HPT if multitasking has started */
                OS_Sched();
    38ae:	03 43       	nop			
        } else {
            OS_ENTER_CRITICAL();
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
            OS_EXIT_CRITICAL();
        }
        return (err);
    38b0:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    38b4:	05 3c       	jmp	$+12     	;abs 0x38c0
    }
    OS_EXIT_CRITICAL();
    38b6:	2f 44       	mov	@r4,	r15	
    38b8:	b0 12 d0 13 	call	#0x13d0	
    return (OS_PRIO_EXIST);
    38bc:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
}
    38c0:	31 50 0e 00 	add	#14,	r1	;#0x000e
    38c4:	34 41       	pop	r4		
    38c6:	3b 41       	pop	r11		
    38c8:	30 41       	ret			

000038ca <OSTaskStkChk>:
*              OS_TASK_OPT_ERR     if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
    38ca:	04 12       	push	r4		
    38cc:	31 50 ee ff 	add	#-18,	r1	;#0xffee
    38d0:	04 41       	mov	r1,	r4	
    38d2:	c4 4f 0e 00 	mov.b	r15,	14(r4)	;0x000e(r4)
    38d6:	84 4e 10 00 	mov	r14,	16(r4)	;0x0010(r4)
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    38da:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
        if (prio != OS_PRIO_SELF) {        
            return (OS_PRIO_INVALID);
        }
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
    38de:	1f 44 10 00 	mov	16(r4),	r15	;0x0010(r4)
    38e2:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    38e6:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    p_stk_data->OSUsed = 0;
    38ea:	1f 44 10 00 	mov	16(r4),	r15	;0x0010(r4)
    38ee:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
    38f2:	8f 43 06 00 	mov	#0,	6(r15)	;r3 As==00, 0x0006(r15)
    OS_ENTER_CRITICAL();
    38f6:	b0 12 ca 13 	call	#0x13ca	
    38fa:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
    38fe:	f4 93 0e 00 	cmp.b	#-1,	14(r4)	;r3 As==11, 0x000e(r4)
    3902:	05 20       	jnz	$+12     	;abs 0x390e
        prio = OSTCBCur->OSTCBPrio;
    3904:	1f 42 54 03 	mov	&0x0354,r15	
    3908:	d4 4f 1c 00 	mov.b	28(r15),14(r4)	;0x001c(r15), 0x000e(r4)
    390c:	0e 00 
    }
    ptcb = OSTCBPrioTbl[prio];
    390e:	5f 44 0e 00 	mov.b	14(r4),	r15	;0x000e(r4)
    3912:	0f 5f       	rla	r15		
    3914:	3f 50 d4 05 	add	#1492,	r15	;#0x05d4
    3918:	a4 4f 0c 00 	mov	@r15,	12(r4)	;0x000c(r4)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
    391c:	84 93 0c 00 	tst	12(r4)		;0x000c(r4)
    3920:	06 20       	jnz	$+14     	;abs 0x392e
        OS_EXIT_CRITICAL();
    3922:	2f 44       	mov	@r4,	r15	
    3924:	b0 12 d0 13 	call	#0x13d0	
        return (OS_TASK_NOT_EXIST);
    3928:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    392c:	56 3c       	jmp	$+174    	;abs 0x39da
    }
    if (ptcb == (OS_TCB *)1) {
    392e:	94 93 0c 00 	cmp	#1,	12(r4)	;r3 As==01, 0x000c(r4)
    3932:	06 20       	jnz	$+14     	;abs 0x3940
        OS_EXIT_CRITICAL();
    3934:	2f 44       	mov	@r4,	r15	
    3936:	b0 12 d0 13 	call	#0x13d0	
        return (OS_TASK_NOT_EXIST);
    393a:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    393e:	4d 3c       	jmp	$+156    	;abs 0x39da
    }  
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
    3940:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    3944:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    3948:	1f f3       	and	#1,	r15	;r3 As==01
    394a:	06 20       	jnz	$+14     	;abs 0x3958
        OS_EXIT_CRITICAL();
    394c:	2f 44       	mov	@r4,	r15	
    394e:	b0 12 d0 13 	call	#0x13d0	
        return (OS_TASK_OPT_ERR);
    3952:	7f 40 82 ff 	mov.b	#-126,	r15	;#0xff82
    3956:	41 3c       	jmp	$+132    	;abs 0x39da
    }
    free = 0;
    3958:	84 43 06 00 	mov	#0,	6(r4)	;r3 As==00, 0x0006(r4)
    395c:	84 43 08 00 	mov	#0,	8(r4)	;r3 As==00, 0x0008(r4)
    size = ptcb->OSTCBStkSize;
    3960:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    3964:	94 4f 06 00 	mov	6(r15),	2(r4)	;0x0006(r15), 0x0002(r4)
    3968:	02 00 
    396a:	94 4f 08 00 	mov	8(r15),	4(r4)	;0x0008(r15), 0x0004(r4)
    396e:	04 00 
    pchk = ptcb->OSTCBStkBottom;
    3970:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    3974:	94 4f 04 00 	mov	4(r15),	10(r4)	;0x0004(r15), 0x000a(r4)
    3978:	0a 00 
    OS_EXIT_CRITICAL();
    397a:	2f 44       	mov	@r4,	r15	
    397c:	b0 12 d0 13 	call	#0x13d0	
    3980:	04 3c       	jmp	$+10     	;abs 0x398a
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
        free++;
    3982:	94 53 06 00 	inc	6(r4)		;0x0006(r4)
    3986:	84 63 08 00 	adc	8(r4)		;0x0008(r4)
    free = 0;
    size = ptcb->OSTCBStkSize;
    pchk = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
    398a:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    398e:	2e 4f       	mov	@r15,	r14	
    3990:	4f 43       	clr.b	r15		
    3992:	0e 93       	tst	r14		
    3994:	01 20       	jnz	$+4      	;abs 0x3998
    3996:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3998:	a4 53 0a 00 	incd	10(r4)		;0x000a(r4)
    399c:	4f 93       	tst.b	r15		
    399e:	f1 23       	jnz	$-28     	;abs 0x3982
#else
    while (*pchk-- == (OS_STK)0) {
        free++;
    }
#endif
    p_stk_data->OSFree = free * sizeof(OS_STK);           /* Compute number of free bytes on the stack */
    39a0:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    39a4:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    39a8:	0e 5e       	rla	r14		
    39aa:	0f 6f       	rlc	r15		
    39ac:	1d 44 10 00 	mov	16(r4),	r13	;0x0010(r4)
    39b0:	8d 4e 00 00 	mov	r14,	0(r13)	;0x0000(r13)
    39b4:	8d 4f 02 00 	mov	r15,	2(r13)	;0x0002(r13)
    p_stk_data->OSUsed = (size - free) * sizeof(OS_STK);  /* Compute number of bytes used on the stack */
    39b8:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    39bc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    39c0:	1e 84 06 00 	sub	6(r4),	r14	;0x0006(r4)
    39c4:	1f 74 08 00 	subc	8(r4),	r15	;0x0008(r4)
    39c8:	0e 5e       	rla	r14		
    39ca:	0f 6f       	rlc	r15		
    39cc:	1d 44 10 00 	mov	16(r4),	r13	;0x0010(r4)
    39d0:	8d 4e 04 00 	mov	r14,	4(r13)	;0x0004(r13)
    39d4:	8d 4f 06 00 	mov	r15,	6(r13)	;0x0006(r13)
    return (OS_NO_ERR);
    39d8:	4f 43       	clr.b	r15		
}
    39da:	31 50 12 00 	add	#18,	r1	;#0x0012
    39de:	34 41       	pop	r4		
    39e0:	30 41       	ret			

000039e2 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    39e2:	04 12       	push	r4		
    39e4:	31 82       	sub	#8,	r1	;r2 As==11
    39e6:	04 41       	mov	r1,	r4	
    39e8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    39ec:	84 4d 02 00 	mov	r13,	2(r4)	;0x0002(r4)
    39f0:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    39f4:	84 4c 06 00 	mov	r12,	6(r4)	;0x0006(r4)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
    39f8:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    39fc:	1f f3       	and	#1,	r15	;r3 As==01
    39fe:	4f 93       	tst.b	r15		
    3a00:	14 24       	jz	$+42     	;abs 0x3a2a
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
    3a02:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3a06:	2f f3       	and	#2,	r15	;r3 As==10
    3a08:	10 24       	jz	$+34     	;abs 0x3a2a
    3a0a:	09 3c       	jmp	$+20     	;abs 0x3a1e
#if OS_STK_GROWTH == 1                     
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
                size--;
    3a0c:	b4 53 02 00 	add	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
    3a10:	b4 63 04 00 	addc	#-1,	4(r4)	;r3 As==11, 0x0004(r4)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
    3a14:	2f 44       	mov	@r4,	r15	
    3a16:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    3a1a:	a4 53 00 00 	incd	0(r4)		;0x0000(r4)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1                     
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
    3a1e:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3a22:	f4 23       	jnz	$-22     	;abs 0x3a0c
    3a24:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    3a28:	f1 23       	jnz	$-28     	;abs 0x3a0c
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
    3a2a:	31 52       	add	#8,	r1	;r2 As==11
    3a2c:	34 41       	pop	r4		
    3a2e:	30 41       	ret			

00003a30 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
    3a30:	04 12       	push	r4		
    3a32:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3a36:	04 41       	mov	r1,	r4	
    3a38:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    3a3c:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (ticks > 0) {                             /* 0 means no delay!                                  */
    3a40:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    3a44:	33 24       	jz	$+104    	;abs 0x3aac
        OS_ENTER_CRITICAL();
    3a46:	b0 12 ca 13 	call	#0x13ca	
    3a4a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
    3a4e:	1f 42 54 03 	mov	&0x0354,r15	
    3a52:	d4 4f 1e 00 	mov.b	30(r15),2(r4)	;0x001e(r15), 0x0002(r4)
    3a56:	02 00 
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
    3a58:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    3a5c:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3a60:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    3a64:	4e 4f       	mov.b	r15,	r14	
    3a66:	1f 42 54 03 	mov	&0x0354,r15	
    3a6a:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    3a6e:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    3a70:	4f fe       	and.b	r14,	r15	
    3a72:	cd 4f 4e 03 	mov.b	r15,	846(r13);0x034e(r13)
        if (OSRdyTbl[y] == 0) {  
    3a76:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3a7a:	5f 4f 4e 03 	mov.b	846(r15),r15	;0x034e(r15)
    3a7e:	4f 93       	tst.b	r15		
    3a80:	0b 20       	jnz	$+24     	;abs 0x3a98
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
    3a82:	1f 42 54 03 	mov	&0x0354,r15	
    3a86:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    3a8a:	4e 4f       	mov.b	r15,	r14	
    3a8c:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    3a8e:	5f 42 4c 03 	mov.b	&0x034c,r15	
    3a92:	4f fe       	and.b	r14,	r15	
    3a94:	c2 4f 4c 03 	mov.b	r15,	&0x034c	
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
    3a98:	1f 42 54 03 	mov	&0x0354,r15	
    3a9c:	9f 44 04 00 	mov	4(r4),	24(r15)	;0x0004(r4), 0x0018(r15)
    3aa0:	18 00 
        OS_EXIT_CRITICAL();
    3aa2:	2f 44       	mov	@r4,	r15	
    3aa4:	b0 12 d0 13 	call	#0x13d0	
        OS_Sched();                              /* Find next task to run!                             */
    3aa8:	b0 12 5e 1d 	call	#0x1d5e	
    }
}
    3aac:	31 50 06 00 	add	#6,	r1	;#0x0006
    3ab0:	34 41       	pop	r4		
    3ab2:	30 41       	ret			

00003ab4 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U milli)
{
    3ab4:	0b 12       	push	r11		
    3ab6:	0a 12       	push	r10		
    3ab8:	09 12       	push	r9		
    3aba:	08 12       	push	r8		
    3abc:	07 12       	push	r7		
    3abe:	06 12       	push	r6		
    3ac0:	04 12       	push	r4		
    3ac2:	31 50 f0 ff 	add	#-16,	r1	;#0xfff0
    3ac6:	04 41       	mov	r1,	r4	
    3ac8:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
    3acc:	c4 4e 07 00 	mov.b	r14,	7(r4)	;0x0007(r4)
    3ad0:	c4 4d 08 00 	mov.b	r13,	8(r4)	;0x0008(r4)
    3ad4:	84 4c 0a 00 	mov	r12,	10(r4)	;0x000a(r4)
        return (OS_TIME_INVALID_MILLI);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
    3ad8:	5c 44 06 00 	mov.b	6(r4),	r12	;0x0006(r4)
    3adc:	0d 43       	clr	r13		
    3ade:	0e 4c       	mov	r12,	r14	
    3ae0:	0f 4d       	mov	r13,	r15	
    3ae2:	0e 5e       	rla	r14		
    3ae4:	0f 6f       	rlc	r15		
    3ae6:	0e 5e       	rla	r14		
    3ae8:	0f 6f       	rlc	r15		
    3aea:	0e 5e       	rla	r14		
    3aec:	0f 6f       	rlc	r15		
    3aee:	0e 8c       	sub	r12,	r14	
    3af0:	0f 7d       	subc	r13,	r15	
    3af2:	0a 4e       	mov	r14,	r10	
    3af4:	0b 4f       	mov	r15,	r11	
    3af6:	4b ea       	xor.b	r10,	r11	
    3af8:	0b ea       	xor	r10,	r11	
    3afa:	8b 10       	swpb	r11		
    3afc:	7a f3       	and.b	#-1,	r10	;r3 As==11
    3afe:	8a 10       	swpb	r10		
    3b00:	0e 5a       	add	r10,	r14	
    3b02:	0f 6b       	addc	r11,	r15	
    3b04:	0e 5e       	rla	r14		
    3b06:	0f 6f       	rlc	r15		
    3b08:	0e 5c       	add	r12,	r14	
    3b0a:	0f 6d       	addc	r13,	r15	
    3b0c:	0a 4e       	mov	r14,	r10	
    3b0e:	0b 4f       	mov	r15,	r11	
    3b10:	0a 5c       	add	r12,	r10	
    3b12:	0b 6d       	addc	r13,	r11	
    3b14:	5c 44 07 00 	mov.b	7(r4),	r12	;0x0007(r4)
    3b18:	0d 43       	clr	r13		
    3b1a:	0e 4c       	mov	r12,	r14	
    3b1c:	0f 4d       	mov	r13,	r15	
    3b1e:	0e 5e       	rla	r14		
    3b20:	0f 6f       	rlc	r15		
    3b22:	0e 5e       	rla	r14		
    3b24:	0f 6f       	rlc	r15		
    3b26:	0e 5e       	rla	r14		
    3b28:	0f 6f       	rlc	r15		
    3b2a:	0e 5e       	rla	r14		
    3b2c:	0f 6f       	rlc	r15		
    3b2e:	0e 8c       	sub	r12,	r14	
    3b30:	0f 7d       	subc	r13,	r15	
    3b32:	0e 5e       	rla	r14		
    3b34:	0f 6f       	rlc	r15		
    3b36:	0e 5e       	rla	r14		
    3b38:	0f 6f       	rlc	r15		
    3b3a:	0c 4a       	mov	r10,	r12	
    3b3c:	0d 4b       	mov	r11,	r13	
    3b3e:	0c 5e       	add	r14,	r12	
    3b40:	0d 6f       	addc	r15,	r13	
    3b42:	5e 44 08 00 	mov.b	8(r4),	r14	;0x0008(r4)
    3b46:	0f 43       	clr	r15		
    3b48:	0a 4c       	mov	r12,	r10	
    3b4a:	0b 4d       	mov	r13,	r11	
    3b4c:	0a 5e       	add	r14,	r10	
    3b4e:	0b 6f       	addc	r15,	r11	
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    3b50:	0c 4a       	mov	r10,	r12	
    3b52:	0d 4b       	mov	r11,	r13	
    3b54:	0e 4c       	mov	r12,	r14	
    3b56:	0f 4d       	mov	r13,	r15	
    3b58:	0e 5e       	rla	r14		
    3b5a:	0f 6f       	rlc	r15		
    3b5c:	0c 4e       	mov	r14,	r12	
    3b5e:	0d 4f       	mov	r15,	r13	
    3b60:	0c 5a       	add	r10,	r12	
    3b62:	0d 6b       	addc	r11,	r13	
    3b64:	0e 4c       	mov	r12,	r14	
    3b66:	0f 4d       	mov	r13,	r15	
    3b68:	0e 5e       	rla	r14		
    3b6a:	0f 6f       	rlc	r15		
    3b6c:	0e 5e       	rla	r14		
    3b6e:	0f 6f       	rlc	r15		
    3b70:	0e 5e       	rla	r14		
    3b72:	0f 6f       	rlc	r15		
    3b74:	0e 5e       	rla	r14		
    3b76:	0f 6f       	rlc	r15		
    3b78:	0e 5e       	rla	r14		
    3b7a:	0f 6f       	rlc	r15		
    3b7c:	0c 5e       	add	r14,	r12	
    3b7e:	0d 6f       	addc	r15,	r13	
    3b80:	0e 4c       	mov	r12,	r14	
    3b82:	0f 4d       	mov	r13,	r15	
    3b84:	0e 5a       	add	r10,	r14	
    3b86:	0f 6b       	addc	r11,	r15	
    3b88:	84 4e 0c 00 	mov	r14,	12(r4)	;0x000c(r4)
    3b8c:	84 4f 0e 00 	mov	r15,	14(r4)	;0x000e(r4)
    3b90:	1a 44 0a 00 	mov	10(r4),	r10	;0x000a(r4)
    3b94:	0b 43       	clr	r11		
    3b96:	0c 4a       	mov	r10,	r12	
    3b98:	0d 4b       	mov	r11,	r13	
    3b9a:	0e 4c       	mov	r12,	r14	
    3b9c:	0f 4d       	mov	r13,	r15	
    3b9e:	0e 5e       	rla	r14		
    3ba0:	0f 6f       	rlc	r15		
    3ba2:	0c 4e       	mov	r14,	r12	
    3ba4:	0d 4f       	mov	r15,	r13	
    3ba6:	0c 5a       	add	r10,	r12	
    3ba8:	0d 6b       	addc	r11,	r13	
    3baa:	0e 4c       	mov	r12,	r14	
    3bac:	0f 4d       	mov	r13,	r15	
    3bae:	0e 5e       	rla	r14		
    3bb0:	0f 6f       	rlc	r15		
    3bb2:	0e 5e       	rla	r14		
    3bb4:	0f 6f       	rlc	r15		
    3bb6:	0e 5e       	rla	r14		
    3bb8:	0f 6f       	rlc	r15		
    3bba:	0e 5e       	rla	r14		
    3bbc:	0f 6f       	rlc	r15		
    3bbe:	0e 5e       	rla	r14		
    3bc0:	0f 6f       	rlc	r15		
    3bc2:	0c 5e       	add	r14,	r12	
    3bc4:	0d 6f       	addc	r15,	r13	
    3bc6:	0e 4c       	mov	r12,	r14	
    3bc8:	0f 4d       	mov	r13,	r15	
    3bca:	0e 5a       	add	r10,	r14	
    3bcc:	0f 6b       	addc	r11,	r15	
    3bce:	0c 4e       	mov	r14,	r12	
    3bd0:	0d 4f       	mov	r15,	r13	
    3bd2:	3c 50 f4 01 	add	#500,	r12	;#0x01f4
    3bd6:	0d 63       	adc	r13		
    3bd8:	3e 40 e8 03 	mov	#1000,	r14	;#0x03e8
    3bdc:	0f 43       	clr	r15		
    3bde:	0a 4e       	mov	r14,	r10	
    3be0:	0b 4f       	mov	r15,	r11	
    3be2:	b0 12 c8 42 	call	#0x42c8	
    3be6:	0e 4c       	mov	r12,	r14	
    3be8:	0f 4d       	mov	r13,	r15	
        return (OS_TIME_INVALID_MILLI);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
    3bea:	1c 44 0c 00 	mov	12(r4),	r12	;0x000c(r4)
    3bee:	1d 44 0e 00 	mov	14(r4),	r13	;0x000e(r4)
    3bf2:	0c 5e       	add	r14,	r12	
    3bf4:	0d 6f       	addc	r15,	r13	
    3bf6:	84 4c 02 00 	mov	r12,	2(r4)	;0x0002(r4)
    3bfa:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    3bfe:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    3c02:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3c06:	07 43       	clr	r7		
    3c08:	06 4f       	mov	r15,	r6	
    3c0a:	07 43       	clr	r7		
    3c0c:	84 46 00 00 	mov	r6,	0(r4)	;0x0000(r4)
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    3c10:	84 f3 04 00 	and	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    OSTimeDly((INT16U)ticks);
    3c14:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3c18:	b0 12 30 3a 	call	#0x3a30	
    3c1c:	0a 3c       	jmp	$+22     	;abs 0x3c32
    while (loops > 0) {
        OSTimeDly((INT16U)32768u);
    3c1e:	3f 40 00 80 	mov	#-32768,r15	;#0x8000
    3c22:	b0 12 30 3a 	call	#0x3a30	
        OSTimeDly((INT16U)32768u);
    3c26:	3f 40 00 80 	mov	#-32768,r15	;#0x8000
    3c2a:	b0 12 30 3a 	call	#0x3a30	
        loops--;
    3c2e:	b4 53 00 00 	add	#-1,	0(r4)	;r3 As==11, 0x0000(r4)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
    3c32:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    3c36:	f3 23       	jnz	$-24     	;abs 0x3c1e
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_NO_ERR);
    3c38:	4f 43       	clr.b	r15		
}
    3c3a:	31 50 10 00 	add	#16,	r1	;#0x0010
    3c3e:	34 41       	pop	r4		
    3c40:	36 41       	pop	r6		
    3c42:	37 41       	pop	r7		
    3c44:	38 41       	pop	r8		
    3c46:	39 41       	pop	r9		
    3c48:	3a 41       	pop	r10		
    3c4a:	3b 41       	pop	r11		
    3c4c:	30 41       	ret			

00003c4e <initDisplay>:
#include "Display.h"
void initDisplay() {
    3c4e:	04 12       	push	r4		
    3c50:	04 41       	mov	r1,	r4	
  InitOsc();
    3c52:	b0 12 5a 3f 	call	#0x3f5a	
  InitPorts();
    3c56:	b0 12 de 3f 	call	#0x3fde	
  InitLCD();
    3c5a:	b0 12 04 42 	call	#0x4204	
  clearDisplay();
    3c5e:	b0 12 7c 3c 	call	#0x3c7c	
}
    3c62:	34 41       	pop	r4		
    3c64:	30 41       	ret			

00003c66 <putc>:
void putc(char c) {
    3c66:	04 12       	push	r4		
    3c68:	21 83       	decd	r1		
    3c6a:	04 41       	mov	r1,	r4	
    3c6c:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
    SEND_CHAR(c);
    3c70:	6f 44       	mov.b	@r4,	r15	
    3c72:	b0 12 dc 40 	call	#0x40dc	
}
    3c76:	21 53       	incd	r1		
    3c78:	34 41       	pop	r4		
    3c7a:	30 41       	ret			

00003c7c <clearDisplay>:
void clearDisplay() {
    3c7c:	04 12       	push	r4		
    3c7e:	04 41       	mov	r1,	r4	
    SEND_CMD(CLR_DISP);
    3c80:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3c82:	b0 12 70 41 	call	#0x4170	
    Delayx100us(10);
    3c86:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3c8a:	0f 43       	clr	r15		
    3c8c:	b0 12 74 40 	call	#0x4074	
}
    3c90:	34 41       	pop	r4		
    3c92:	30 41       	ret			

00003c94 <gotoSecondLine>:
void gotoSecondLine() {
    3c94:	04 12       	push	r4		
    3c96:	04 41       	mov	r1,	r4	
//    SEND_CMD(CLR_DISP);
    SEND_CMD(DD_RAM_ADDR2);
    3c98:	7f 40 c0 ff 	mov.b	#-64,	r15	;#0xffc0
    3c9c:	b0 12 70 41 	call	#0x4170	
}
    3ca0:	34 41       	pop	r4		
    3ca2:	30 41       	ret			

00003ca4 <printString>:
void printString(char *String) {
    3ca4:	04 12       	push	r4		
    3ca6:	21 83       	decd	r1		
    3ca8:	04 41       	mov	r1,	r4	
    3caa:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    3cae:	06 3c       	jmp	$+14     	;abs 0x3cbc
  while(*String)
    putc(*String++);
    3cb0:	2f 44       	mov	@r4,	r15	
    3cb2:	6f 4f       	mov.b	@r15,	r15	
    3cb4:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    3cb8:	b0 12 66 3c 	call	#0x3c66	
void gotoSecondLine() {
//    SEND_CMD(CLR_DISP);
    SEND_CMD(DD_RAM_ADDR2);
}
void printString(char *String) {
  while(*String)
    3cbc:	2f 44       	mov	@r4,	r15	
    3cbe:	6f 4f       	mov.b	@r15,	r15	
    3cc0:	4f 93       	tst.b	r15		
    3cc2:	f6 23       	jnz	$-18     	;abs 0x3cb0
    putc(*String++);
}
    3cc4:	21 53       	incd	r1		
    3cc6:	34 41       	pop	r4		
    3cc8:	30 41       	ret			

00003cca <HexDigit>:
char HexDigit(int digitvalue) {
    3cca:	04 12       	push	r4		
    3ccc:	21 83       	decd	r1		
    3cce:	04 41       	mov	r1,	r4	
    3cd0:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
  if (digitvalue < 10)
    3cd4:	b4 90 0a 00 	cmp	#10,	0(r4)	;#0x000a, 0x0000(r4)
    3cd8:	00 00 
    3cda:	04 34       	jge	$+10     	;abs 0x3ce4
    return(digitvalue + '0');
    3cdc:	2f 44       	mov	@r4,	r15	
    3cde:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3ce2:	03 3c       	jmp	$+8      	;abs 0x3cea
  else
    return(digitvalue + 'A' - 10);
    3ce4:	2f 44       	mov	@r4,	r15	
    3ce6:	7f 50 37 00 	add.b	#55,	r15	;#0x0037
}
    3cea:	21 53       	incd	r1		
    3cec:	34 41       	pop	r4		
    3cee:	30 41       	ret			

00003cf0 <printByte>:
void printByte(unsigned int theByte) {
    3cf0:	04 12       	push	r4		
    3cf2:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3cf6:	04 41       	mov	r1,	r4	
    3cf8:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
  char HexBuffer[3];
  HexBuffer[2] = 0;
    3cfc:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
  HexBuffer[1] = HexDigit(theByte & 0x000f);
    3d00:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3d04:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d08:	b0 12 ca 3c 	call	#0x3cca	
    3d0c:	c4 4f 01 00 	mov.b	r15,	1(r4)	;0x0001(r4)
  theByte = theByte >> 4;
    3d10:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3d14:	12 c3       	clrc			
    3d16:	0f 10       	rrc	r15		
    3d18:	0f 11       	rra	r15		
    3d1a:	0f 11       	rra	r15		
    3d1c:	0f 11       	rra	r15		
    3d1e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
  HexBuffer[0] = HexDigit(theByte & 0x000f);
    3d22:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3d26:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d2a:	b0 12 ca 3c 	call	#0x3cca	
    3d2e:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
  printString(HexBuffer);
    3d32:	0f 44       	mov	r4,	r15	
    3d34:	b0 12 a4 3c 	call	#0x3ca4	
}
    3d38:	31 50 06 00 	add	#6,	r1	;#0x0006
    3d3c:	34 41       	pop	r4		
    3d3e:	30 41       	ret			

00003d40 <printHex>:
void printHex(unsigned int Number) {
    3d40:	04 12       	push	r4		
    3d42:	31 82       	sub	#8,	r1	;r2 As==11
    3d44:	04 41       	mov	r1,	r4	
    3d46:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
  char HexBuffer[5];
  HexBuffer[4] = 0;
    3d4a:	c4 43 04 00 	mov.b	#0,	4(r4)	;r3 As==00, 0x0004(r4)
  HexBuffer[3] = HexDigit(Number & 0x000f);
    3d4e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3d52:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d56:	b0 12 ca 3c 	call	#0x3cca	
    3d5a:	c4 4f 03 00 	mov.b	r15,	3(r4)	;0x0003(r4)
  Number = Number >> 4;
    3d5e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3d62:	12 c3       	clrc			
    3d64:	0f 10       	rrc	r15		
    3d66:	0f 11       	rra	r15		
    3d68:	0f 11       	rra	r15		
    3d6a:	0f 11       	rra	r15		
    3d6c:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
  HexBuffer[2] = HexDigit(Number & 0x000f);
    3d70:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3d74:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d78:	b0 12 ca 3c 	call	#0x3cca	
    3d7c:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
  Number = Number >> 4;
    3d80:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3d84:	12 c3       	clrc			
    3d86:	0f 10       	rrc	r15		
    3d88:	0f 11       	rra	r15		
    3d8a:	0f 11       	rra	r15		
    3d8c:	0f 11       	rra	r15		
    3d8e:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
  HexBuffer[1] = HexDigit(Number & 0x000f);
    3d92:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3d96:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d9a:	b0 12 ca 3c 	call	#0x3cca	
    3d9e:	c4 4f 01 00 	mov.b	r15,	1(r4)	;0x0001(r4)
  Number = Number >> 4;
    3da2:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3da6:	12 c3       	clrc			
    3da8:	0f 10       	rrc	r15		
    3daa:	0f 11       	rra	r15		
    3dac:	0f 11       	rra	r15		
    3dae:	0f 11       	rra	r15		
    3db0:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
  HexBuffer[0] = HexDigit(Number & 0x000f);
    3db4:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3db8:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3dbc:	b0 12 ca 3c 	call	#0x3cca	
    3dc0:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
  printString(HexBuffer);
    3dc4:	0f 44       	mov	r4,	r15	
    3dc6:	b0 12 a4 3c 	call	#0x3ca4	
}
    3dca:	31 52       	add	#8,	r1	;r2 As==11
    3dcc:	34 41       	pop	r4		
    3dce:	30 41       	ret			

00003dd0 <printDecimal>:
void printDecimal(int Number) {
    3dd0:	0b 12       	push	r11		
    3dd2:	0a 12       	push	r10		
    3dd4:	09 12       	push	r9		
    3dd6:	08 12       	push	r8		
    3dd8:	04 12       	push	r4		
    3dda:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3dde:	04 41       	mov	r1,	r4	
    3de0:	84 4f 0c 00 	mov	r15,	12(r4)	;0x000c(r4)
  // need to move to long int to account for
  // negative 32768
  char DecimalBuffer[7];
  long lNumber = Number;
    3de4:	94 44 0c 00 	mov	12(r4),	0(r4)	;0x000c(r4), 0x0000(r4)
    3de8:	00 00 
    3dea:	a4 44 02 00 	mov	@r4,	2(r4)	;0x0002(r4)
    3dee:	94 54 02 00 	rla	2(r4)		;0x0002(r4)
    3df2:	02 00 
    3df4:	94 74 02 00 	subc	2(r4),	2(r4)	;0x0002(r4), 0x0002(r4)
    3df8:	02 00 
    3dfa:	b4 e3 02 00 	xor	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
  DecimalBuffer[6] = 0;
    3dfe:	c4 43 0a 00 	mov.b	#0,	10(r4)	;r3 As==00, 0x000a(r4)
  if (lNumber < 0) {
    3e02:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3e06:	0f 34       	jge	$+32     	;abs 0x3e26
    DecimalBuffer[0] = '-';
    3e08:	f4 40 2d 00 	mov.b	#45,	4(r4)	;#0x002d, 0x0004(r4)
    3e0c:	04 00 
    lNumber = -lNumber;
    3e0e:	2e 44       	mov	@r4,	r14	
    3e10:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3e14:	3e e3       	inv	r14		
    3e16:	3f e3       	inv	r15		
    3e18:	1e 53       	inc	r14		
    3e1a:	0f 63       	adc	r15		
    3e1c:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3e20:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    3e24:	03 3c       	jmp	$+8      	;abs 0x3e2c
  } else
    DecimalBuffer[0] = '+';
    3e26:	f4 40 2b 00 	mov.b	#43,	4(r4)	;#0x002b, 0x0004(r4)
    3e2a:	04 00 
  DecimalBuffer[5] = (lNumber % 10)+'0';
    3e2c:	2c 44       	mov	@r4,	r12	
    3e2e:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3e32:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3e36:	0f 43       	clr	r15		
    3e38:	0a 4e       	mov	r14,	r10	
    3e3a:	0b 4f       	mov	r15,	r11	
    3e3c:	b0 12 f2 42 	call	#0x42f2	
    3e40:	4f 4e       	mov.b	r14,	r15	
    3e42:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3e46:	c4 4f 09 00 	mov.b	r15,	9(r4)	;0x0009(r4)
  lNumber = lNumber / 10;
    3e4a:	2c 44       	mov	@r4,	r12	
    3e4c:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3e50:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3e54:	0f 43       	clr	r15		
    3e56:	0a 4e       	mov	r14,	r10	
    3e58:	0b 4f       	mov	r15,	r11	
    3e5a:	b0 12 f2 42 	call	#0x42f2	
    3e5e:	0e 4c       	mov	r12,	r14	
    3e60:	0f 4d       	mov	r13,	r15	
    3e62:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3e66:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
  DecimalBuffer[4] = (lNumber % 10)+'0';
    3e6a:	2c 44       	mov	@r4,	r12	
    3e6c:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3e70:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3e74:	0f 43       	clr	r15		
    3e76:	0a 4e       	mov	r14,	r10	
    3e78:	0b 4f       	mov	r15,	r11	
    3e7a:	b0 12 f2 42 	call	#0x42f2	
    3e7e:	4f 4e       	mov.b	r14,	r15	
    3e80:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3e84:	c4 4f 08 00 	mov.b	r15,	8(r4)	;0x0008(r4)
  lNumber = lNumber / 10;
    3e88:	2c 44       	mov	@r4,	r12	
    3e8a:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3e8e:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3e92:	0f 43       	clr	r15		
    3e94:	0a 4e       	mov	r14,	r10	
    3e96:	0b 4f       	mov	r15,	r11	
    3e98:	b0 12 f2 42 	call	#0x42f2	
    3e9c:	0e 4c       	mov	r12,	r14	
    3e9e:	0f 4d       	mov	r13,	r15	
    3ea0:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3ea4:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
  DecimalBuffer[3] = (lNumber % 10)+'0';
    3ea8:	2c 44       	mov	@r4,	r12	
    3eaa:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3eae:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3eb2:	0f 43       	clr	r15		
    3eb4:	0a 4e       	mov	r14,	r10	
    3eb6:	0b 4f       	mov	r15,	r11	
    3eb8:	b0 12 f2 42 	call	#0x42f2	
    3ebc:	4f 4e       	mov.b	r14,	r15	
    3ebe:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3ec2:	c4 4f 07 00 	mov.b	r15,	7(r4)	;0x0007(r4)
  lNumber = lNumber / 10;
    3ec6:	2c 44       	mov	@r4,	r12	
    3ec8:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3ecc:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3ed0:	0f 43       	clr	r15		
    3ed2:	0a 4e       	mov	r14,	r10	
    3ed4:	0b 4f       	mov	r15,	r11	
    3ed6:	b0 12 f2 42 	call	#0x42f2	
    3eda:	0e 4c       	mov	r12,	r14	
    3edc:	0f 4d       	mov	r13,	r15	
    3ede:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3ee2:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
  DecimalBuffer[2] = (lNumber % 10)+'0';
    3ee6:	2c 44       	mov	@r4,	r12	
    3ee8:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3eec:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3ef0:	0f 43       	clr	r15		
    3ef2:	0a 4e       	mov	r14,	r10	
    3ef4:	0b 4f       	mov	r15,	r11	
    3ef6:	b0 12 f2 42 	call	#0x42f2	
    3efa:	4f 4e       	mov.b	r14,	r15	
    3efc:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3f00:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
  lNumber = lNumber / 10;
    3f04:	2c 44       	mov	@r4,	r12	
    3f06:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f0a:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f0e:	0f 43       	clr	r15		
    3f10:	0a 4e       	mov	r14,	r10	
    3f12:	0b 4f       	mov	r15,	r11	
    3f14:	b0 12 f2 42 	call	#0x42f2	
    3f18:	0e 4c       	mov	r12,	r14	
    3f1a:	0f 4d       	mov	r13,	r15	
    3f1c:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3f20:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
  DecimalBuffer[1] = (lNumber % 10)+'0';
    3f24:	2c 44       	mov	@r4,	r12	
    3f26:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f2a:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f2e:	0f 43       	clr	r15		
    3f30:	0a 4e       	mov	r14,	r10	
    3f32:	0b 4f       	mov	r15,	r11	
    3f34:	b0 12 f2 42 	call	#0x42f2	
    3f38:	4f 4e       	mov.b	r14,	r15	
    3f3a:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3f3e:	c4 4f 05 00 	mov.b	r15,	5(r4)	;0x0005(r4)
  printString(DecimalBuffer);
    3f42:	0f 44       	mov	r4,	r15	
    3f44:	2f 52       	add	#4,	r15	;r2 As==10
    3f46:	b0 12 a4 3c 	call	#0x3ca4	
}
    3f4a:	31 50 0e 00 	add	#14,	r1	;#0x000e
    3f4e:	34 41       	pop	r4		
    3f50:	38 41       	pop	r8		
    3f52:	39 41       	pop	r9		
    3f54:	3a 41       	pop	r10		
    3f56:	3b 41       	pop	r11		
    3f58:	30 41       	ret			

00003f5a <InitOsc>:


void InitOsc(void)
{
    3f5a:	04 12       	push	r4		
    3f5c:	04 41       	mov	r1,	r4	
  WDTCTL = WDTPW | WDTHOLD;                      // stop watchdog timer
    3f5e:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    3f62:	20 01 

  BCSCTL1 |= XTS;                                // XT1 as high-frequency
    3f64:	5f 42 57 00 	mov.b	&0x0057,r15	
    3f68:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    3f6c:	c2 4f 57 00 	mov.b	r15,	&0x0057	
  _BIC_SR(OSCOFF);                               // turn on XT1 oscillator
    3f70:	32 c0 20 00 	bic	#32,	r2	;#0x0020

  do                                             // wait in loop until crystal is stable
    IFG1 &= ~OFIFG;
    3f74:	5f 42 02 00 	mov.b	&0x0002,r15	
    3f78:	6f c3       	bic.b	#2,	r15	;r3 As==10
    3f7a:	c2 4f 02 00 	mov.b	r15,	&0x0002	
  while (IFG1 & OFIFG);
    3f7e:	5f 42 02 00 	mov.b	&0x0002,r15	
    3f82:	7f f3       	and.b	#-1,	r15	;r3 As==11
    3f84:	2f f3       	and	#2,	r15	;r3 As==10
    3f86:	f6 23       	jnz	$-18     	;abs 0x3f74

  BCSCTL1 |= DIVA0;                              // ACLK = XT1 / 2
    3f88:	5f 42 57 00 	mov.b	&0x0057,r15	
    3f8c:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    3f90:	c2 4f 57 00 	mov.b	r15,	&0x0057	
  BCSCTL1 &= ~DIVA1;
    3f94:	5f 42 57 00 	mov.b	&0x0057,r15	
    3f98:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    3f9c:	c2 4f 57 00 	mov.b	r15,	&0x0057	

  IE1 &= ~WDTIE;                                 // disable WDT int.
    3fa0:	5f 42 00 00 	mov.b	&0x0000,r15	
    3fa4:	5f c3       	bic.b	#1,	r15	;r3 As==01
    3fa6:	c2 4f 00 00 	mov.b	r15,	&0x0000	
  IFG1 &= ~WDTIFG;                               // clear WDT int. flag
    3faa:	5f 42 02 00 	mov.b	&0x0002,r15	
    3fae:	5f c3       	bic.b	#1,	r15	;r3 As==01
    3fb0:	c2 4f 02 00 	mov.b	r15,	&0x0002	

  WDTCTL = WDTPW | WDTTMSEL | WDTCNTCL | WDTSSEL | WDTIS1; // use WDT as timer, flag each
    3fb4:	b2 40 1e 5a 	mov	#23070,	&0x0120	;#0x5a1e
    3fb8:	20 01 
                                                           // 512 pulses from ACLK

  while (!(IFG1 & WDTIFG));                      // count 1024 pulses from XT1 (until XT1's
    3fba:	5f 42 02 00 	mov.b	&0x0002,r15	
    3fbe:	7f f3       	and.b	#-1,	r15	;r3 As==11
    3fc0:	1f f3       	and	#1,	r15	;r3 As==01
    3fc2:	fb 27       	jz	$-8      	;abs 0x3fba
                                                 // amplitude is OK)

  IFG1 &= ~OFIFG;                                // clear osc. fault int. flag
    3fc4:	5f 42 02 00 	mov.b	&0x0002,r15	
    3fc8:	6f c3       	bic.b	#2,	r15	;r3 As==10
    3fca:	c2 4f 02 00 	mov.b	r15,	&0x0002	
  BCSCTL2 |= SELM0 | SELM1;                      // set XT1 as MCLK
    3fce:	5f 42 58 00 	mov.b	&0x0058,r15	
    3fd2:	7f d0 c0 ff 	bis.b	#-64,	r15	;#0xffc0
    3fd6:	c2 4f 58 00 	mov.b	r15,	&0x0058	
}
    3fda:	34 41       	pop	r4		
    3fdc:	30 41       	ret			

00003fde <InitPorts>:

void InitPorts(void)
{
    3fde:	04 12       	push	r4		
    3fe0:	04 41       	mov	r1,	r4	
  P1SEL = 0;                                     //
    3fe2:	c2 43 26 00 	mov.b	#0,	&0x0026	;r3 As==00
  P1OUT = 0;                                     //
    3fe6:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00
  P1DIR = BIT5 | BIT6;                           //enable only Relay outputs
    3fea:	f2 40 60 00 	mov.b	#96,	&0x0022	;#0x0060
    3fee:	22 00 

  P2SEL = 0;
    3ff0:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00
  P2OUT = 0;
    3ff4:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00
  P2DIR = ~BIT0;                                //only P2.0 is input
    3ff8:	f2 40 fe ff 	mov.b	#-2,	&0x002a	;#0xfffe
    3ffc:	2a 00 

  P3SEL |= BIT4 | BIT5;                         //enable UART0
    3ffe:	5f 42 1b 00 	mov.b	&0x001b,r15	
    4002:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    4006:	c2 4f 1b 00 	mov.b	r15,	&0x001b	
  P3DIR |= BIT4;                                //enable TXD0 as output
    400a:	5f 42 1a 00 	mov.b	&0x001a,r15	
    400e:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    4012:	c2 4f 1a 00 	mov.b	r15,	&0x001a	
  P3DIR &= ~BIT5;                               //enable RXD0 as input
    4016:	5f 42 1a 00 	mov.b	&0x001a,r15	
    401a:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    401e:	c2 4f 1a 00 	mov.b	r15,	&0x001a	

  P4SEL = 0;
    4022:	c2 43 1f 00 	mov.b	#0,	&0x001f	;r3 As==00
  P4OUT = 0;
    4026:	c2 43 1d 00 	mov.b	#0,	&0x001d	;r3 As==00
  P4DIR = BIT2 | BIT3;                          //only buzzer pins are outputs
    402a:	f2 40 0c 00 	mov.b	#12,	&0x001e	;#0x000c
    402e:	1e 00 

  //P6SEL = 0x80;
  //P6OUT = 0;
 // P6DIR = 0x00;                                  // all output
}
    4030:	34 41       	pop	r4		
    4032:	30 41       	ret			

00004034 <Delay>:

void Delay (unsigned long int a)
	
{
    4034:	04 12       	push	r4		
    4036:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    403a:	04 41       	mov	r1,	r4	
    403c:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    4040:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
  int k;
  for (k=0 ; k != a; ++k) {
    4044:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    4048:	06 3c       	jmp	$+14     	;abs 0x4056
    _NOP();
    404a:	03 43       	nop			
    _NOP();
    404c:	03 43       	nop			
    _NOP();
    404e:	03 43       	nop			
    _NOP();
    4050:	03 43       	nop			

void Delay (unsigned long int a)
	
{
  int k;
  for (k=0 ; k != a; ++k) {
    4052:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    4056:	2e 44       	mov	@r4,	r14	
    4058:	0f 4e       	mov	r14,	r15	
    405a:	0f 5f       	rla	r15		
    405c:	0f 7f       	subc	r15,	r15	
    405e:	3f e3       	inv	r15		
    4060:	1e 94 02 00 	cmp	2(r4),	r14	;0x0002(r4)
    4064:	f2 23       	jnz	$-26     	;abs 0x404a
    4066:	1f 94 04 00 	cmp	4(r4),	r15	;0x0004(r4)
    406a:	ef 23       	jnz	$-32     	;abs 0x404a
    _NOP();
    _NOP();
    _NOP();
    _NOP();
  }
}
    406c:	31 50 06 00 	add	#6,	r1	;#0x0006
    4070:	34 41       	pop	r4		
    4072:	30 41       	ret			

00004074 <Delayx100us>:

void Delayx100us(unsigned long int b)
{
    4074:	04 12       	push	r4		
    4076:	31 82       	sub	#8,	r1	;r2 As==11
    4078:	04 41       	mov	r1,	r4	
    407a:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    407e:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
  long int j;
  
  for (j=0; j!=b; ++j) Delay (_100us);
    4082:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    4086:	84 43 02 00 	mov	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    408a:	09 3c       	jmp	$+20     	;abs 0x409e
    408c:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    4090:	0f 43       	clr	r15		
    4092:	b0 12 34 40 	call	#0x4034	
    4096:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    409a:	84 63 02 00 	adc	2(r4)		;0x0002(r4)
    409e:	2e 44       	mov	@r4,	r14	
    40a0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    40a4:	1e 94 04 00 	cmp	4(r4),	r14	;0x0004(r4)
    40a8:	f1 23       	jnz	$-28     	;abs 0x408c
    40aa:	1f 94 06 00 	cmp	6(r4),	r15	;0x0006(r4)
    40ae:	ee 23       	jnz	$-34     	;abs 0x408c
}
    40b0:	31 52       	add	#8,	r1	;r2 As==11
    40b2:	34 41       	pop	r4		
    40b4:	30 41       	ret			

000040b6 <_E>:


void _E(void)
{
    40b6:	04 12       	push	r4		
    40b8:	04 41       	mov	r1,	r4	
        bitset(P2OUT,E);		//toggle E for LCD
    40ba:	5f 42 29 00 	mov.b	&0x0029,r15	
    40be:	7f d2       	bis.b	#8,	r15	;r2 As==11
    40c0:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	Delay(_10us);
    40c4:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    40c8:	0f 43       	clr	r15		
    40ca:	b0 12 34 40 	call	#0x4034	
	bitclr(P2OUT,E);
    40ce:	5f 42 29 00 	mov.b	&0x0029,r15	
    40d2:	7f c2       	bic.b	#8,	r15	;r2 As==11
    40d4:	c2 4f 29 00 	mov.b	r15,	&0x0029	
}
    40d8:	34 41       	pop	r4		
    40da:	30 41       	ret			

000040dc <SEND_CHAR>:


void SEND_CHAR (unsigned char d)
{
    40dc:	04 12       	push	r4		
    40de:	21 82       	sub	#4,	r1	;r2 As==10
    40e0:	04 41       	mov	r1,	r4	
    40e2:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
        int temp;
	Delayx100us(5);                 //.5ms	
    40e6:	3e 40 05 00 	mov	#5,	r14	;#0x0005
    40ea:	0f 43       	clr	r15		
    40ec:	b0 12 74 40 	call	#0x4074	
	temp = d & 0xf0;		//get upper nibble	
    40f0:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    40f4:	0e 4f       	mov	r15,	r14	
    40f6:	3e f0 f0 00 	and	#240,	r14	;#0x00f0
    40fa:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    40fe:	5f 42 29 00 	mov.b	&0x0029,r15	
    4102:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    4106:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    410a:	2f 44       	mov	@r4,	r15	
    410c:	4e 4f       	mov.b	r15,	r14	
    410e:	5f 42 29 00 	mov.b	&0x0029,r15	
    4112:	4f de       	bis.b	r14,	r15	
    4114:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitset(P2OUT,RS);     	        //set LCD to data mode
    4118:	5f 42 29 00 	mov.b	&0x0029,r15	
    411c:	6f d2       	bis.b	#4,	r15	;r2 As==10
    411e:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	_E();                           //toggle E for LCD
    4122:	b0 12 b6 40 	call	#0x40b6	
	temp = d & 0x0f;
    4126:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    412a:	0e 4f       	mov	r15,	r14	
    412c:	3e f0 0f 00 	and	#15,	r14	;#0x000f
    4130:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	temp = temp << 4;               //get down nibble
    4134:	2f 44       	mov	@r4,	r15	
    4136:	0f 5f       	rla	r15		
    4138:	0f 5f       	rla	r15		
    413a:	0f 5f       	rla	r15		
    413c:	0f 5f       	rla	r15		
    413e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    4142:	5f 42 29 00 	mov.b	&0x0029,r15	
    4146:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    414a:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    414e:	2f 44       	mov	@r4,	r15	
    4150:	4e 4f       	mov.b	r15,	r14	
    4152:	5f 42 29 00 	mov.b	&0x0029,r15	
    4156:	4f de       	bis.b	r14,	r15	
    4158:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitset(P2OUT,RS);   	        //set LCD to data mode
    415c:	5f 42 29 00 	mov.b	&0x0029,r15	
    4160:	6f d2       	bis.b	#4,	r15	;r2 As==10
    4162:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	_E();                           //toggle E for LCD
    4166:	b0 12 b6 40 	call	#0x40b6	
}
    416a:	21 52       	add	#4,	r1	;r2 As==10
    416c:	34 41       	pop	r4		
    416e:	30 41       	ret			

00004170 <SEND_CMD>:

void SEND_CMD (unsigned char e)
{
    4170:	04 12       	push	r4		
    4172:	21 82       	sub	#4,	r1	;r2 As==10
    4174:	04 41       	mov	r1,	r4	
    4176:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
        int temp;
	Delayx100us(10);                //10ms
    417a:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    417e:	0f 43       	clr	r15		
    4180:	b0 12 74 40 	call	#0x4074	
	temp = e & 0xf0;		//get upper nibble	
    4184:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    4188:	0e 4f       	mov	r15,	r14	
    418a:	3e f0 f0 00 	and	#240,	r14	;#0x00f0
    418e:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    4192:	5f 42 29 00 	mov.b	&0x0029,r15	
    4196:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    419a:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;               //send CMD to LCD
    419e:	2f 44       	mov	@r4,	r15	
    41a0:	4e 4f       	mov.b	r15,	r14	
    41a2:	5f 42 29 00 	mov.b	&0x0029,r15	
    41a6:	4f de       	bis.b	r14,	r15	
    41a8:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitclr(P2OUT,RS);     	        //set LCD to CMD mode
    41ac:	5f 42 29 00 	mov.b	&0x0029,r15	
    41b0:	6f c2       	bic.b	#4,	r15	;r2 As==10
    41b2:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	_E();                           //toggle E for LCD
    41b6:	b0 12 b6 40 	call	#0x40b6	
	temp = e & 0x0f;
    41ba:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    41be:	0e 4f       	mov	r15,	r14	
    41c0:	3e f0 0f 00 	and	#15,	r14	;#0x000f
    41c4:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	temp = temp << 4;               //get down nibble
    41c8:	2f 44       	mov	@r4,	r15	
    41ca:	0f 5f       	rla	r15		
    41cc:	0f 5f       	rla	r15		
    41ce:	0f 5f       	rla	r15		
    41d0:	0f 5f       	rla	r15		
    41d2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    41d6:	5f 42 29 00 	mov.b	&0x0029,r15	
    41da:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    41de:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    41e2:	2f 44       	mov	@r4,	r15	
    41e4:	4e 4f       	mov.b	r15,	r14	
    41e6:	5f 42 29 00 	mov.b	&0x0029,r15	
    41ea:	4f de       	bis.b	r14,	r15	
    41ec:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitclr(P2OUT,RS);   	        //set LCD to CMD mode
    41f0:	5f 42 29 00 	mov.b	&0x0029,r15	
    41f4:	6f c2       	bic.b	#4,	r15	;r2 As==10
    41f6:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	_E();                           //toggle E for LCD
    41fa:	b0 12 b6 40 	call	#0x40b6	
}
    41fe:	21 52       	add	#4,	r1	;r2 As==10
    4200:	34 41       	pop	r4		
    4202:	30 41       	ret			

00004204 <InitLCD>:

void InitLCD(void)
{
    4204:	04 12       	push	r4		
    4206:	04 41       	mov	r1,	r4	
    bitclr(P2OUT,RS);
    4208:	5f 42 29 00 	mov.b	&0x0029,r15	
    420c:	6f c2       	bic.b	#4,	r15	;r2 As==10
    420e:	c2 4f 29 00 	mov.b	r15,	&0x0029	
    Delayx100us(250);                   //Delay 100ms
    4212:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4216:	0f 43       	clr	r15		
    4218:	b0 12 74 40 	call	#0x4074	
    Delayx100us(250);
    421c:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4220:	0f 43       	clr	r15		
    4222:	b0 12 74 40 	call	#0x4074	
    Delayx100us(250);
    4226:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    422a:	0f 43       	clr	r15		
    422c:	b0 12 74 40 	call	#0x4074	
    Delayx100us(250);
    4230:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4234:	0f 43       	clr	r15		
    4236:	b0 12 74 40 	call	#0x4074	
    LCD_Data |= BIT4 | BIT5;            //D7-D4 = 0011
    423a:	5f 42 29 00 	mov.b	&0x0029,r15	
    423e:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    4242:	c2 4f 29 00 	mov.b	r15,	&0x0029	
    LCD_Data &= ~BIT6 & ~BIT7;
    4246:	5f 42 29 00 	mov.b	&0x0029,r15	
    424a:	7f f0 3f 00 	and.b	#63,	r15	;#0x003f
    424e:	c2 4f 29 00 	mov.b	r15,	&0x0029	
    _E();                               //toggle E for LCD
    4252:	b0 12 b6 40 	call	#0x40b6	
    Delayx100us(100);                   //10ms
    4256:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    425a:	0f 43       	clr	r15		
    425c:	b0 12 74 40 	call	#0x4074	
    _E();                               //toggle E for LCD
    4260:	b0 12 b6 40 	call	#0x40b6	
    Delayx100us(100);                   //10ms
    4264:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    4268:	0f 43       	clr	r15		
    426a:	b0 12 74 40 	call	#0x4074	
    _E();                               //toggle E for LCD
    426e:	b0 12 b6 40 	call	#0x40b6	
    Delayx100us(100);                   //10ms
    4272:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    4276:	0f 43       	clr	r15		
    4278:	b0 12 74 40 	call	#0x4074	
    LCD_Data &= ~BIT4;
    427c:	5f 42 29 00 	mov.b	&0x0029,r15	
    4280:	7f f0 ef ff 	and.b	#-17,	r15	;#0xffef
    4284:	c2 4f 29 00 	mov.b	r15,	&0x0029	
    _E();                               //toggle E for LCD
    4288:	b0 12 b6 40 	call	#0x40b6	

    SEND_CMD(DISP_ON);
    428c:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    4290:	b0 12 70 41 	call	#0x4170	
    SEND_CMD(CLR_DISP);
    4294:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4296:	b0 12 70 41 	call	#0x4170	
    Delayx100us(250);
    429a:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    429e:	0f 43       	clr	r15		
    42a0:	b0 12 74 40 	call	#0x4074	
    Delayx100us(250);
    42a4:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    42a8:	0f 43       	clr	r15		
    42aa:	b0 12 74 40 	call	#0x4074	
    Delayx100us(250);
    42ae:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    42b2:	0f 43       	clr	r15		
    42b4:	b0 12 74 40 	call	#0x4074	
    Delayx100us(250);
    42b8:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    42bc:	0f 43       	clr	r15		
    42be:	b0 12 74 40 	call	#0x4074	
}
    42c2:	34 41       	pop	r4		
    42c4:	30 41       	ret			

000042c6 <_unexpected_>:
    42c6:	00 13       	reti			

000042c8 <__udivmodsi4>:
    42c8:	0f ef       	xor	r15,	r15	
    42ca:	0e ee       	xor	r14,	r14	
    42cc:	39 40 21 00 	mov	#33,	r9	;#0x0021
    42d0:	0a 3c       	jmp	$+22     	;abs 0x42e6
    42d2:	08 10       	rrc	r8		
    42d4:	0e 6e       	rlc	r14		
    42d6:	0f 6f       	rlc	r15		
    42d8:	0f 9b       	cmp	r11,	r15	
    42da:	05 28       	jnc	$+12     	;abs 0x42e6
    42dc:	02 20       	jnz	$+6      	;abs 0x42e2
    42de:	0e 9a       	cmp	r10,	r14	
    42e0:	02 28       	jnc	$+6      	;abs 0x42e6
    42e2:	0e 8a       	sub	r10,	r14	
    42e4:	0f 7b       	subc	r11,	r15	
    42e6:	0c 6c       	rlc	r12		
    42e8:	0d 6d       	rlc	r13		
    42ea:	08 68       	rlc	r8		
    42ec:	19 83       	dec	r9		
    42ee:	f1 23       	jnz	$-28     	;abs 0x42d2
    42f0:	30 41       	ret			

000042f2 <__divmodsi4>:
    42f2:	08 43       	clr	r8		
    42f4:	3d b0 00 80 	bit	#-32768,r13	;#0x8000
    42f8:	05 24       	jz	$+12     	;abs 0x4304
    42fa:	3d e3       	inv	r13		
    42fc:	3c e3       	inv	r12		
    42fe:	1c 53       	inc	r12		
    4300:	0d 63       	adc	r13		
    4302:	28 d2       	bis	#4,	r8	;r2 As==10
    4304:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    4308:	05 24       	jz	$+12     	;abs 0x4314
    430a:	3b e3       	inv	r11		
    430c:	3a e3       	inv	r10		
    430e:	1a 53       	inc	r10		
    4310:	0b 63       	adc	r11		
    4312:	38 d2       	bis	#8,	r8	;r2 As==11
    4314:	b0 12 c8 42 	call	#0x42c8	
    4318:	08 10       	rrc	r8		
    431a:	28 b2       	bit	#4,	r8	;r2 As==10
    431c:	08 24       	jz	$+18     	;abs 0x432e
    431e:	3e e3       	inv	r14		
    4320:	3f e3       	inv	r15		
    4322:	1e 53       	inc	r14		
    4324:	0f 63       	adc	r15		
    4326:	3c e3       	inv	r12		
    4328:	3d e3       	inv	r13		
    432a:	1c 53       	inc	r12		
    432c:	0d 63       	adc	r13		
    432e:	38 b2       	bit	#8,	r8	;r2 As==11
    4330:	04 24       	jz	$+10     	;abs 0x433a
    4332:	3c e3       	inv	r12		
    4334:	3d e3       	inv	r13		
    4336:	1c 53       	inc	r12		
    4338:	0d 63       	adc	r13		
    433a:	30 41       	ret			

0000433c <__stop_progExec__>:
    433c:	ff 3f       	jmp	$+0      	;abs 0x433c

Disassembly of section .vectors:

0000ffe0 <InterruptVectors>:
    ffe0:	30 11 30 11 30 11 30 11 30 11 30 11 64 13 30 11     0.0.0.0.0.0.d.0.
    fff0:	30 11 30 11 30 11 30 11 30 11 30 11 30 11 00 11     0.0.0.0.0.0.0...
