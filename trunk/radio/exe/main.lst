
exe/main.elf:     file format elf32-msp430

SYMBOL TABLE:
00001100 l    d  .text	00000000 .text
00000200 l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
0000012e l       *ABS*	00000000 TA0IV
00000160 l       *ABS*	00000000 TA0CTL
00000170 l       *ABS*	00000000 TA0R
00000162 l       *ABS*	00000000 TA0CCTL0
00000164 l       *ABS*	00000000 TA0CCTL1
00000172 l       *ABS*	00000000 TA0CCR0
00000174 l       *ABS*	00000000 TA0CCR1
00000166 l       *ABS*	00000000 TA0CCTL2
00000176 l       *ABS*	00000000 TA0CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000190 l       *ABS*	00000000 TBR
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000004 l       *ABS*	00000000 ME1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000005 l       *ABS*	00000000 ME2
00000002 l       *ABS*	00000000 PUSH_BYTES
00001130 l       .text	00000000 _branch_to_unexpected_
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 main.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
0000012e l       *ABS*	00000000 TA0IV
00000160 l       *ABS*	00000000 TA0CTL
00000170 l       *ABS*	00000000 TA0R
00000162 l       *ABS*	00000000 TA0CCTL0
00000164 l       *ABS*	00000000 TA0CCTL1
00000172 l       *ABS*	00000000 TA0CCR0
00000174 l       *ABS*	00000000 TA0CCR1
00000166 l       *ABS*	00000000 TA0CCTL2
00000176 l       *ABS*	00000000 TA0CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000190 l       *ABS*	00000000 TBR
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000004 l       *ABS*	00000000 ME1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000005 l       *ABS*	00000000 ME2
000013ce l       .text	00000000 TA0_ISR
000013fe l       .text	00000000 L1
0000141a l       .text	00000000 L2
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_core.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001c6a l     F .text	00000028 OS_InitMisc
00001c92 l     F .text	00000042 OS_InitRdyList
00001d08 l     F .text	0000006c OS_InitTCBList
00001c00 l     F .text	0000006a OS_InitEventList
00001cd4 l     F .text	00000034 OS_InitTaskIdle
00000000 l    df *ABS*	00000000 os_flag.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00002660 l     F .text	000000fa OS_FlagBlock
000027c4 l     F .text	000000a8 OS_FlagTaskRdy
00000000 l    df *ABS*	00000000 os_mbox.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_mem.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_mutex.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_q.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_sem.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_task.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_time.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Display.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 ServiceOutput.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 GestionMode.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 StatLogger.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 TraitementInput.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 g       *ABS*	00000000 __data_size
0000144e g     F .text	00000010 OSTaskCreateHook
00003fd6 g     F .text	00000084 InitOsc
000016b2 g     F .text	00000022 OSIntEnter
00004412 g     F .text	00000036 setVolume
00001476 g     F .text	00000008 OSTaskStatHook
0000030c g     O .bss	00000001 OSLockNesting
0000030d g     O .bss	00000001 OSRunning
00004158 g     F .text	00000094 SEND_CHAR
00003d20 g     F .text	00000026 printString
0000143e g     F .text	00000008 OSInitHookBegin
0000030e g     O .bss	00000004 OSIdleCtr
00001eb8 g     F .text	000001f0 OS_TCBInit
00000312 g     O .bss	00000001 OSPrioHighRdy
0000145e g     F .text	00000010 OSTaskDelHook
0000468c g       .text	00000000 _etext
00003cf8 g     F .text	00000018 clearDisplay
00001320 g     F .text	00000000 OSStartHighRdy
0000383c g     F .text	0000010a OSTaskCreateExt
00002492 g     F .text	0000002c OSFlagPendGetFlagsRdy
000020a8 g     F .text	0000012a OSFlagAccept
00002da4 g     F .text	0000005c OSQFlush
00002bde g     F .text	000000c4 OSQAccept
00003760 g     F .text	000000dc OSTaskCreate
0000351e g     F .text	00000242 OSTaskChangePrio
000003a0 g       *ABS*	00000000 __bss_size
00000314 g     O .bss	00000012 OSFlagTbl
0000468a  w      .text	00000000 __stop_progExec__
00001130  w      .text	00000000 vector_ffe0
00004132 g     F .text	00000026 _E
000016d4 g     F .text	000000c2 OSIntExit
00000326 g     O .bss	00000001 OSPrioCur
00003e4c g     F .text	0000018a printDecimal
0000134c g       .text	00000000 OSCtxSw
00004448 g     F .text	000000f2 sendOverSPI
000045c8 g     F .text	0000004c GestionMode
00003d6c g     F .text	00000050 printByte
00000328 g     O .bss	00000002 OSTCBList
0000032a g     O .bss	00000001 OSTickStepState
00002f52 g     F .text	000000dc OSQPost
0000286c g     F .text	00000068 OS_FlagUnlink
00001d9e g     F .text	0000003c OS_MemCopy
00001dda g     F .text	000000a8 OS_Sched
0000032c g     O .bss	00000004 OSCtxSwCtr
000013ce g       .text	00000000 vector_ffec
00001576 g     F .text	00000008 OSTimeTickHook
00001130  w      .text	00000000 vector_fff0
0000468c g       *ABS*	00000000 __data_load_start
000033a0 g     F .text	000000f6 OSSemPend
0000157e g     O .text	00000008 OSMapTbl
00001130 g       .text	00000000 __dtors_end
00001130  w      .text	00000000 vector_fffc
00001566 g     F .text	00000010 OSTCBInitHook
00002aae g     F .text	00000084 OSMboxPost
00003ce2 g     F .text	00000016 putch
0000275a g     F .text	0000006a OS_FlagInit
00001130  w      .text	00000000 vector_ffe4
000032c8 g     F .text	0000005e OSSemAccept
0000139e g       .text	00000000 OSIntCtxSw
00003d46 g     F .text	00000026 HexDigit
00000330 g     O .bss	00000002 OSTCBFreeList
0000ffe0 g     O .vectors	00000020 InterruptVectors
0000453a g     F .text	0000008e ModeStep
00004342 g     F .text	0000007c ServiceOutput
00000202 g     O .bss	00000002 mode
000040f0 g     F .text	00000042 Delayx100us
0000111c  w      .text	00000000 __do_clear_bss
00001d74 g     F .text	0000002a OS_MemClr
0000147e g     F .text	000000e0 OSTaskStkInit
0000193a g     F .text	00000142 OS_EventTaskRdy
00002e00 g     F .text	00000152 OSQPend
000041ec g     F .text	00000094 SEND_CMD
00003aac g     F .text	00000084 OSTimeDly
00000332 g     O .bss	00000001 OSTaskCtr
00003b30 g     F .text	0000019a OSTimeDlyHMSM
0000130c g       .text	00000000 vector_ffe2
00003496 g     F .text	00000088 OSSemPost
00001252 g       .text	00000000 vector_ffe8
00004614  w      .text	00000000 _unexpected_
00001130  w      .text	00000000 vector_fffa
00004280 g     F .text	000000c2 InitLCD
00000334 g     O .bss	00000046 OSQTbl
00001100  w      .text	00000000 _reset_vector__
00001130 g       .text	00000000 __ctors_start
0000037a g     O .bss	00000002 OSTCBHighRdy
0000037c g     O .bss	00000002 OSQFreeList
0000110a  w      .text	00000000 __do_copy_data
00001252 g     F .text	000000ba ButtInterrupt
0000037e g     O .bss	00000001 OSRdyGrp
00000200 g       .bss	00000000 __bss_start
00001130  w      .text	00000000 vector_ffee
00001130  w      .text	00000000 vector_fff4
00000204 g     O .bss	00000002 count_int_me
00001146 g     F .text	00000108 main
00001130  w      .text	00000000 vector_fff8
00001586 g     O .text	00000100 OSUnMapTbl
00000200 g     O .bss	00000002 global_pb_gd
00001130  w      .text	00000000 vector_fff2
000024be g     F .text	000001a2 OSFlagPost
00003cca g     F .text	00000018 initDisplay
00001a7c g     F .text	000000b0 OS_EventTaskWait
00001796 g     F .text	00000066 OSStart
0000302e g     F .text	000000e4 OSQPostFront
00000380 g     O .bss	00000003 OSRdyTbl
00010000 g       .vectors	00000000 _vectors_end
00002ca2 g     F .text	00000102 OSQCreate
00003112 g     F .text	0000015c OSQPostOpt
000017fc g     F .text	00000132 OSTimeTick
00001130  w      .text	00000000 vector_ffe6
00003326 g     F .text	0000007a OSSemCreate
0000405a g     F .text	00000056 InitPorts
000021d2 g     F .text	0000008e OSFlagCreate
00000206 g     O .bss	00000002 StkServiceOutput
00000384 g     O .bss	00000002 OSEventFreeList
00003dbc g     F .text	00000090 printHex
00001100  w      .text	00000000 __init_stack
00002260 g     F .text	00000232 OSFlagPend
00000208 g     O .bss	00000002 StkGestionMode
000040b0 g     F .text	00000040 Delay
0000020a g     O .bss	00000080 TaskStartStk2
00001446 g     F .text	00000008 OSInitHookEnd
00001130 g       .text	00000000 __dtors_start
00001130 g       .text	00000000 __ctors_end
00004640 g       .text	00000000 __divmodsi4
00000a00 g       *ABS*	00000000 __stack
0000291e g     F .text	00000078 OSMboxCreate
0000143a g     F .text	00000000 OSCPURestoreSR
00000200 g       .text	00000000 _edata
000005a0 g       .bss	00000000 _end
00000386 g     O .bss	00000001 OSIntNesting
0000028a g     O .bss	00000080 TaskStartStk
00001434 g     F .text	00000000 OSCPUSaveSR
00002996 g     F .text	00000118 OSMboxPend
00003946 g     F .text	00000118 OSTaskStkChk
00000388 g     O .bss	00000002 OSTCBCur
000043be g     F .text	00000054 setFrequency
00004616 g       .text	00000000 __udivmodsi4
000028d4 g     F .text	0000004a OSMboxAccept
00001686 g     F .text	0000002c OSInit
00001b2c g     F .text	00000092 OS_EventTO
0000326e g     F .text	0000005a OS_QInit
00001130  w      .text	00000000 vector_fff6
0000130c g     F .text	00000014 TelInterrupt
0000038a g     O .bss	00000080 OSTaskIdleStk
00002b32 g     F .text	000000ac OSMboxPostOpt
0000155e g     F .text	00000008 OSTaskSwHook
0000040a g     O .bss	00000032 OSEventTbl
00001104  w      .text	00000000 __low_level_init
0000043c g     O .bss	00000138 OSTCBTbl
0000112c  w      .text	00000000 __jump_to_main
00003d10 g     F .text	00000010 gotoSecondLine
00000200 g       .text	00000000 __data_start
00000574 g     O .bss	00000002 OSFlagFreeList
00000576 g     O .bss	0000002a OSTCBPrioTbl
00000120  w      *ABS*	00000000 __WDTCTL
0000030a g     O .bss	00000002 OSISRStkPtr
00001130  w      .text	00000000 vector_ffea
0000192e g     F .text	0000000c OSVersion
00003a5e g     F .text	0000004e OS_TaskStkClr
00001bbe g     F .text	00000042 OS_EventWaitListInit
0000146e g     F .text	00000008 OSTaskIdleHook
00001e82 g     F .text	00000036 OS_TaskIdle



Disassembly of section .text:

00001100 <__init_stack>:
    1100:	31 40 00 0a 	mov	#2560,	r1	;#0x0a00

00001104 <__low_level_init>:
    1104:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    1108:	20 01 

0000110a <__do_copy_data>:
    110a:	3f 40 00 00 	mov	#0,	r15	;#0x0000
    110e:	0f 93       	tst	r15		
    1110:	05 24       	jz	$+12     	;abs 0x111c
    1112:	2f 83       	decd	r15		
    1114:	9f 4f 8c 46 	mov	18060(r15),512(r15);0x468c(r15), 0x0200(r15)
    1118:	00 02 
    111a:	fb 23       	jnz	$-8      	;abs 0x1112

0000111c <__do_clear_bss>:
    111c:	3f 40 a0 03 	mov	#928,	r15	;#0x03a0
    1120:	0f 93       	tst	r15		
    1122:	04 24       	jz	$+10     	;abs 0x112c
    1124:	1f 83       	dec	r15		
    1126:	cf 43 00 02 	mov.b	#0,	512(r15);r3 As==00, 0x0200(r15)
    112a:	fc 23       	jnz	$-6      	;abs 0x1124

0000112c <__jump_to_main>:
    112c:	30 40 46 11 	br	#0x1146	

00001130 <__ctors_end>:
    1130:	30 40 14 46 	br	#0x4614	
    1134:	53 74       	.word	0x7453;	????	Illegal as 2-op instr
    1136:	61 72       	subc.b	#4,	r1	;r2 As==10
    1138:	74 69       	addc.b	@r9+,	r4	
    113a:	6e 67       	addc.b	@r7,	r14	
    113c:	00 53       	add	#0,	r0	;r3 As==00
    113e:	74 61       	addc.b	@r1+,	r4	
    1140:	72 74       	subc.b	@r4+,	r2	
    1142:	20 4f       	br	@r15		
    1144:	53 00       	.word	0x0053;	????	

00001146 <main>:
 *********************************************************************************************************
 *                                                MAIN
 *********************************************************************************************************
 */

int main(void) {
    1146:	31 40 e8 09 	mov	#2536,	r1	;#0x09e8
    114a:	04 41       	mov	r1,	r4	

	WDTCTL = WDTCTL_INIT; //Init watchdog timer
    114c:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    1150:	20 01 

	P6OUT = P1OUT_INIT; //Init output data of port1
    1152:	c2 43 35 00 	mov.b	#0,	&0x0035	;r3 As==00
	P6OUT = P1OUT_INIT; //Init output data of port2
    1156:	c2 43 35 00 	mov.b	#0,	&0x0035	;r3 As==00

	P6SEL = P1SEL_INIT; //Select port or module -function on port1
    115a:	c2 43 37 00 	mov.b	#0,	&0x0037	;r3 As==00
	P6SEL = P2SEL_INIT; //Select port or module -function on port2
    115e:	c2 43 37 00 	mov.b	#0,	&0x0037	;r3 As==00

	P6DIR = P1DIR_INIT; //Init port direction register of port1
    1162:	f2 43 36 00 	mov.b	#-1,	&0x0036	;r3 As==11
	P6DIR = P2DIR_INIT; //Init port direction register of port2
    1166:	f2 43 36 00 	mov.b	#-1,	&0x0036	;r3 As==11

	P1IES = P1IES_INIT; //init port interrupts
    116a:	d2 43 24 00 	mov.b	#1,	&0x0024	;r3 As==01
	P2IES = P2IES_INIT;
    116e:	c2 43 2c 00 	mov.b	#0,	&0x002c	;r3 As==00
	P1IE = 0xff;
    1172:	f2 43 25 00 	mov.b	#-1,	&0x0025	;r3 As==11
	P2IE = P2IE_INIT;
    1176:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00
// changement au vue de tournier , 3 lignes
	P2SEL = 0;
    117a:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00
	P2OUT = 0;
    117e:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00
	P2DIR = ~BIT0; //only P2.0 is input
    1182:	f2 40 fe ff 	mov.b	#-2,	&0x002a	;#0xfffe
    1186:	2a 00 

	/*Initialisation ineruptions Buttons et Irda*/

	//Pour avoir les pins en interruptions, il faut configurer
	P1SEL = 0; //
    1188:	c2 43 26 00 	mov.b	#0,	&0x0026	;r3 As==00
	P2SEL = 0; // sélection "input/output" (0) au lieu de "périphérique" (1)
    118c:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00
	P1DIR = ~BIT0;
    1190:	f2 40 fe ff 	mov.b	#-2,	&0x0022	;#0xfffe
    1194:	22 00 
	P2DIR = ~BIT0;
    1196:	f2 40 fe ff 	mov.b	#-2,	&0x002a	;#0xfffe
    119a:	2a 00 
	P1IES = 1;
    119c:	d2 43 24 00 	mov.b	#1,	&0x0024	;r3 As==01
	P2IES = 0; //-> savoir si c'est un front montant (0) ou descendant (1)
    11a0:	c2 43 2c 00 	mov.b	#0,	&0x002c	;r3 As==00
	P1IFG = 0;
    11a4:	c2 43 23 00 	mov.b	#0,	&0x0023	;r3 As==00
	P2IFG = 0;
    11a8:	c2 43 2b 00 	mov.b	#0,	&0x002b	;r3 As==00
	//	il faut utiliser eint(); pour enable global interrupt, P1IE = 1 et P2IE = 1
	/*Fin initialisation*/

	eint();
    11ac:	32 d2       	eint			
	InitPorts();
    11ae:	b0 12 5a 40 	call	#0x405a	
	initDisplay();
    11b2:	b0 12 ca 3c 	call	#0x3cca	
	clearDisplay();
    11b6:	b0 12 f8 3c 	call	#0x3cf8	
	printString("Starting");
    11ba:	3f 40 34 11 	mov	#4404,	r15	;#0x1134
    11be:	b0 12 20 3d 	call	#0x3d20	

	WDTCTL = WDTPW + WDTHOLD; /* Disable the watchdog timer   */
    11c2:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    11c6:	20 01 
	//   P6DIR = 0x01;                       /* P1.0 is the only output.     */
	//  P6OUT = 0x00;                       /* P1.0 initially low.          */

	// TIMERA Configuration             /* Configure TIMERA for the system Tick source. */
	//
	TACTL = TASSEL1 + TACLR; /* Clear the Timer and set SMCLK as the source. */
    11c8:	b2 40 04 02 	mov	#516,	&0x0160	;#0x0204
    11cc:	60 01 
	TACTL |= 0x00C0; /* Input divider is /8.  		*/
    11ce:	1f 42 60 01 	mov	&0x0160,r15	
    11d2:	3f d0 c0 00 	bis	#192,	r15	;#0x00c0
    11d6:	82 4f 60 01 	mov	r15,	&0x0160	
	TACCTL0 = CCIE; /* Enable the TACCR0 interrupt. */
    11da:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    11de:	62 01 
	TACCR0 = 2304; /* Load the TACCR0 register.    	*/
    11e0:	b2 40 00 09 	mov	#2304,	&0x0172	;#0x0900
    11e4:	72 01 

	OSInit(); /* Initialize uC/OS-II                     */
    11e6:	b0 12 86 16 	call	#0x1686	

	/*  P6OUT = 0;*/

	void *CommMsg[10];
	OS_EVENT *msgQServiceOutput = OSQCreate(&CommMsg[0], 10);
    11ea:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    11ee:	0f 44       	mov	r4,	r15	
    11f0:	2f 52       	add	#4,	r15	;r2 As==10
    11f2:	b0 12 a2 2c 	call	#0x2ca2	
    11f6:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	INT8U prio = 0;
    11fa:	c4 43 00 00 	mov.b	#0,	0(r4)	;r3 As==00, 0x0000(r4)

	OSTaskCreate(GestionMode, (void *) msgQServiceOutput,
    11fe:	3e 40 08 03 	mov	#776,	r14	;#0x0308
    1202:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1206:	6c 44       	mov.b	@r4,	r12	
    1208:	0d 4e       	mov	r14,	r13	
    120a:	0e 4f       	mov	r15,	r14	
    120c:	3f 40 c8 45 	mov	#17864,	r15	;#0x45c8
    1210:	b0 12 60 37 	call	#0x3760	
			&TaskStartStk[TASK_STK_SIZE - 1], prio);

	prio = 5;
    1214:	f4 40 05 00 	mov.b	#5,	0(r4)	;#0x0005, 0x0000(r4)
    1218:	00 00 

	OSTaskCreate(ServiceOutput, (void *) msgQServiceOutput,
    121a:	3e 40 88 02 	mov	#648,	r14	;#0x0288
    121e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1222:	6c 44       	mov.b	@r4,	r12	
    1224:	0d 4e       	mov	r14,	r13	
    1226:	0e 4f       	mov	r15,	r14	
    1228:	3f 40 42 43 	mov	#17218,	r15	;#0x4342
    122c:	b0 12 60 37 	call	#0x3760	
			&TaskStartStk2[TASK_STK_SIZE - 1], prio);
	clearDisplay();
    1230:	b0 12 f8 3c 	call	#0x3cf8	
	printString("Start OS");
    1234:	3f 40 3d 11 	mov	#4413,	r15	;#0x113d
    1238:	b0 12 20 3d 	call	#0x3d20	
	count_int_me = 0;
    123c:	82 43 04 02 	mov	#0,	&0x0204	;r3 As==00
	OSStart();
    1240:	b0 12 96 17 	call	#0x1796	
	return (0);
    1244:	0f 43       	clr	r15		
}
    1246:	31 50 18 00 	add	#24,	r1	;#0x0018
    124a:	30 40 8a 46 	br	#0x468a	
    124e:	49 6e       	addc.b	r14,	r9	
	...

00001252 <ButtInterrupt>:
 *********************************************************************************************************
 *                                            STARTUP TASK
 *********************************************************************************************************
 */

interrupt (PORT1_VECTOR) ButtInterrupt(void) {
    1252:	0f 12       	push	r15		
    1254:	0e 12       	push	r14		
    1256:	0d 12       	push	r13		
    1258:	0c 12       	push	r12		
    125a:	04 12       	push	r4		
    125c:	31 82       	sub	#8,	r1	;r2 As==11
    125e:	04 41       	mov	r1,	r4	
	INT8U poll = 0;
    1260:	c4 43 03 00 	mov.b	#0,	3(r4)	;r3 As==00, 0x0003(r4)
	uint8_t P4Buffer;
	InputEvent Message;
	OS_CPU_SR cpu_sr = 0;
    1264:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)

	//désactiver les interruptions
	P1IE = 0;
    1268:	c2 43 25 00 	mov.b	#0,	&0x0025	;r3 As==00
	OS_ENTER_CRITICAL(); /*save cpu status register locally end restore it when finished*/
    126c:	b0 12 34 14 	call	#0x1434	
    1270:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	OSIntEnter();
    1274:	b0 12 b2 16 	call	#0x16b2	

	//remise du sémaphore à 0
	P1IFG = 0;
    1278:	c2 43 23 00 	mov.b	#0,	&0x0023	;r3 As==00
	clearDisplay();
    127c:	b0 12 f8 3c 	call	#0x3cf8	
	printDecimal(count_int_me++);
    1280:	1f 42 04 02 	mov	&0x0204,r15	
    1284:	0e 4f       	mov	r15,	r14	
    1286:	1f 53       	inc	r15		
    1288:	82 4f 04 02 	mov	r15,	&0x0204	
    128c:	0f 4e       	mov	r14,	r15	
    128e:	b0 12 4c 3e 	call	#0x3e4c	
	//récupérer les informations des boutons
	Message.bEvent = 4;
    1292:	a4 42 04 00 	mov	#4,	4(r4)	;r2 As==10, 0x0004(r4)

	//while (Message.bEvent == 4)
	{
		P4Buffer = P4IN;
    1296:	d4 42 1c 00 	mov.b	&0x001c,2(r4)	;0x0002(r4)
    129a:	02 00 
		gotoSecondLine();
    129c:	b0 12 10 3d 	call	#0x3d10	
		printString("In");
    12a0:	3f 40 4e 12 	mov	#4686,	r15	;#0x124e
    12a4:	b0 12 20 3d 	call	#0x3d20	
		if (!(P4Buffer & 0x10)) {
    12a8:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    12ac:	3f f0 10 00 	and	#16,	r15	;#0x0010
    12b0:	02 20       	jnz	$+6      	;abs 0x12b6
			Message.bEvent = 0;
    12b2:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)

		}
		if (!(P4Buffer & 0x20)) {
    12b6:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    12ba:	3f f0 20 00 	and	#32,	r15	;#0x0020
    12be:	02 20       	jnz	$+6      	;abs 0x12c4
			Message.bEvent = 1;
    12c0:	94 43 04 00 	mov	#1,	4(r4)	;r3 As==01, 0x0004(r4)

		}
		if (!(P4Buffer & 0x40)) {
    12c4:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    12c8:	3f f0 40 00 	and	#64,	r15	;#0x0040
    12cc:	02 20       	jnz	$+6      	;abs 0x12d2
			Message.bEvent = 2;
    12ce:	a4 43 04 00 	mov	#2,	4(r4)	;r3 As==10, 0x0004(r4)

		}
		if (!(P4Buffer & 0x80)) {
    12d2:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    12d6:	4f 93       	tst.b	r15		
    12d8:	03 38       	jl	$+8      	;abs 0x12e0
			Message.bEvent = 3;
    12da:	b4 40 03 00 	mov	#3,	4(r4)	;#0x0003, 0x0004(r4)
    12de:	04 00 
		}

		//Pour éviter de rester bloqué en cas d'erreur on incrémente une variable et on la compare avec une valeur arbitraire
		//On assigne une valeur "ERREUR" au message, on pourra le traiter de façon particulière
	}
	printDecimal(Message.bEvent);
    12e0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    12e4:	b0 12 4c 3e 	call	#0x3e4c	
	printByte(P4IN);
    12e8:	5f 42 1c 00 	mov.b	&0x001c,r15	
    12ec:	b0 12 6c 3d 	call	#0x3d6c	

	//todo:les transmettre par MailBox ou MessageQueue au TraitementInput

	OSIntExit();
    12f0:	b0 12 d4 16 	call	#0x16d4	
	OS_EXIT_CRITICAL();
    12f4:	2f 44       	mov	@r4,	r15	
    12f6:	b0 12 3a 14 	call	#0x143a	
	//réactiver les interruptions
	P1IE = 0xFF;
    12fa:	f2 43 25 00 	mov.b	#-1,	&0x0025	;r3 As==11
}
    12fe:	31 52       	add	#8,	r1	;r2 As==11
    1300:	34 41       	pop	r4		
    1302:	3c 41       	pop	r12		
    1304:	3d 41       	pop	r13		
    1306:	3e 41       	pop	r14		
    1308:	3f 41       	pop	r15		
    130a:	00 13       	reti			

0000130c <TelInterrupt>:

//todo: a finir
interrupt (PORT2_VECTOR) TelInterrupt(void) {
    130c:	04 12       	push	r4		
    130e:	04 41       	mov	r1,	r4	
	//désactiver les interruptions
	P2IE = 0;
    1310:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00

	//remise des sémaphores à 0
	P2IFG = 0;
    1314:	c2 43 2b 00 	mov.b	#0,	&0x002b	;r3 As==00
	//récupération des infos -> lesquelles et comment? Comment marche la liaison série?

	//transmission par MB ou MQ au traitement input

	//réactiver les interruptions
	P2IE = 1;
    1318:	d2 43 2d 00 	mov.b	#1,	&0x002d	;r3 As==01
}
    131c:	34 41       	pop	r4		
    131e:	00 13       	reti			

00001320 <OSStartHighRdy>:

	.global OSStartHighRdy
	.type OSStartHighRdy, @function

OSStartHighRdy:	
            call     #OSTaskSwHook
    1320:	b0 12 5e 15 	call	#0x155e	

            mov.b    #1, &OSRunning         /* kernel running */
    1324:	d2 43 0d 03 	mov.b	#1,	&0x030d	;r3 As==01

            mov.w    r1, &OSISRStkPtr       /* save interrupt stack  */            
    1328:	82 41 0a 03 	mov	r1,	&0x030a	

            mov.w    &OSTCBHighRdy, r13     /* load highest ready task stack  */
    132c:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w    @r13, r1
    1330:	21 4d       	mov	@r13,	r1	

            POPALL							/* Restore all the registers.  */
    1332:	3f 41       	pop	r15		
    1334:	3e 41       	pop	r14		
    1336:	3d 41       	pop	r13		
    1338:	3c 41       	pop	r12		
    133a:	3b 41       	pop	r11		
    133c:	3a 41       	pop	r10		
    133e:	39 41       	pop	r9		
    1340:	38 41       	pop	r8		
    1342:	37 41       	pop	r7		
    1344:	36 41       	pop	r6		
    1346:	35 41       	pop	r5		
    1348:	34 41       	pop	r4		
                    
            reti                            /* emulate return from interrupt  */
    134a:	00 13       	reti			

0000134c <OSCtxSw>:
;********************************************************************************************************
*/

.global OSCtxSw
OSCtxSw:
            push      r2                    /* emulate interrupt by also saving the SR */
    134c:	02 12       	push	r2		
            
            PUSHALL							/* Save all the task registers.  */
    134e:	04 12       	push	r4		
    1350:	05 12       	push	r5		
    1352:	06 12       	push	r6		
    1354:	07 12       	push	r7		
    1356:	08 12       	push	r8		
    1358:	09 12       	push	r9		
    135a:	0a 12       	push	r10		
    135c:	0b 12       	push	r11		
    135e:	0c 12       	push	r12		
    1360:	0d 12       	push	r13		
    1362:	0e 12       	push	r14		
    1364:	0f 12       	push	r15		
            
            mov.w     &OSTCBCur, r13        /* OSTCBCur->OSTCBStkPtr = SP  */
    1366:	1d 42 88 03 	mov	&0x0388,r13	
            mov.w     r1, 0(r13)
    136a:	8d 41 00 00 	mov	r1,	0(r13)	;0x0000(r13)

            call      #OSTaskSwHook
    136e:	b0 12 5e 15 	call	#0x155e	

            mov.b     &OSPrioHighRdy, r13   /*  OSPrioCur = OSPrioHighRdy  */
    1372:	5d 42 12 03 	mov.b	&0x0312,r13	
            mov.b     r13, &OSPrioCur       /*                             */
    1376:	c2 4d 26 03 	mov.b	r13,	&0x0326	
                          
            mov.w     &OSTCBHighRdy, r13    /* OSTCBCur  = OSTCBHighRdy    */
    137a:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w     r13, &OSTCBCur        /*                             */
    137e:	82 4d 88 03 	mov	r13,	&0x0388	
                          
            mov.w     @r13, r1              /*  SP        = OSTCBHighRdy->OSTCBStkPtr  */
    1382:	21 4d       	mov	@r13,	r1	
             
            POPALL							/* Restore the new task registers.  */
    1384:	3f 41       	pop	r15		
    1386:	3e 41       	pop	r14		
    1388:	3d 41       	pop	r13		
    138a:	3c 41       	pop	r12		
    138c:	3b 41       	pop	r11		
    138e:	3a 41       	pop	r10		
    1390:	39 41       	pop	r9		
    1392:	38 41       	pop	r8		
    1394:	37 41       	pop	r7		
    1396:	36 41       	pop	r6		
    1398:	35 41       	pop	r5		
    139a:	34 41       	pop	r4		
            
            reti                            /* return from interrup  */
    139c:	00 13       	reti			

0000139e <OSIntCtxSw>:

.global OSIntCtxSw

OSIntCtxSw:
             
            call      #OSTaskSwHook
    139e:	b0 12 5e 15 	call	#0x155e	

            mov.b     &OSPrioHighRdy, r13   /* OSPrioCur = OSPrioHighRdy */
    13a2:	5d 42 12 03 	mov.b	&0x0312,r13	
            mov.b     r13, &OSPrioCur       
    13a6:	c2 4d 26 03 	mov.b	r13,	&0x0326	
                          
            mov.w     &OSTCBHighRdy, r13    /* OSTCBCur  = OSTCBHighRdy  */
    13aa:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w     r13, &OSTCBCur
    13ae:	82 4d 88 03 	mov	r13,	&0x0388	
                          
            mov.w     @r13, r1              /* SP        = OSTCBHighRdy->OSTCBStkPtr */
    13b2:	21 4d       	mov	@r13,	r1	
             
            POPALL							/* Restore the registers.  */
    13b4:	3f 41       	pop	r15		
    13b6:	3e 41       	pop	r14		
    13b8:	3d 41       	pop	r13		
    13ba:	3c 41       	pop	r12		
    13bc:	3b 41       	pop	r11		
    13be:	3a 41       	pop	r10		
    13c0:	39 41       	pop	r9		
    13c2:	38 41       	pop	r8		
    13c4:	37 41       	pop	r7		
    13c6:	36 41       	pop	r6		
    13c8:	35 41       	pop	r5		
    13ca:	34 41       	pop	r4		
             
            reti                            /* return from interrup */
    13cc:	00 13       	reti			

000013ce <vector_ffec>:
;********************************************************************************************************
*/

interrupt(TIMERA0_VECTOR)
TA0_ISR:                                    /* TIMERA0 timer ISR */
            PUSHALL
    13ce:	04 12       	push	r4		
    13d0:	05 12       	push	r5		
    13d2:	06 12       	push	r6		
    13d4:	07 12       	push	r7		
    13d6:	08 12       	push	r8		
    13d8:	09 12       	push	r9		
    13da:	0a 12       	push	r10		
    13dc:	0b 12       	push	r11		
    13de:	0c 12       	push	r12		
    13e0:	0d 12       	push	r13		
    13e2:	0e 12       	push	r14		
    13e4:	0f 12       	push	r15		
                        
            add.w	 #2304, &TACCR0			/* Reset the Timer Period*/
    13e6:	b2 50 00 09 	add	#2304,	&0x0172	;#0x0900
    13ea:	72 01 
                         
            cmp.b    #0, &OSIntNesting      /* if (OSIntNesting == 0)  */
    13ec:	c2 93 86 03 	tst.b	&0x0386	
            jne      L1
    13f0:	06 20       	jnz	$+14     	;abs 0x13fe
                               
            mov.w    &OSTCBCur, r13         /* save task stack */
    13f2:	1d 42 88 03 	mov	&0x0388,r13	
            mov.w    r1, 0(r13)
    13f6:	8d 41 00 00 	mov	r1,	0(r13)	;0x0000(r13)

            mov.w    &OSISRStkPtr, r1       /* load interrupt stack  */
    13fa:	11 42 0a 03 	mov	&0x030a,r1	

000013fe <L1>:

L1:
            inc.b    &OSIntNesting          /* increase OSIntNesting */
    13fe:	d2 53 86 03 	inc.b	&0x0386	
             
            EINT                           /* enable general interrupt to allow for interrupt nesting */
    1402:	32 d2       	eint			

            call     #OSTimeTick            /* call ticks routine       */
    1404:	b0 12 fc 17 	call	#0x17fc	

            DINT                           /* IMPORTANT: disable general interrupt BEFORE calling OSIntExit() */
    1408:	32 c2       	dint			

            call     #OSIntExit             /* call ticks routine */
    140a:	b0 12 d4 16 	call	#0x16d4	

            cmp.b    #0, &OSIntNesting      /* if (OSIntNesting == 0) */ 
    140e:	c2 93 86 03 	tst.b	&0x0386	
            jne      L2
    1412:	03 20       	jnz	$+8      	;abs 0x141a

            mov.w    &OSTCBHighRdy, r13     /* restore task stack SP */
    1414:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w    @r13, r1
    1418:	21 4d       	mov	@r13,	r1	

0000141a <L2>:
                       
L2:
			POPALL
    141a:	3f 41       	pop	r15		
    141c:	3e 41       	pop	r14		
    141e:	3d 41       	pop	r13		
    1420:	3c 41       	pop	r12		
    1422:	3b 41       	pop	r11		
    1424:	3a 41       	pop	r10		
    1426:	39 41       	pop	r9		
    1428:	38 41       	pop	r8		
    142a:	37 41       	pop	r7		
    142c:	36 41       	pop	r6		
    142e:	35 41       	pop	r5		
    1430:	34 41       	pop	r4		

            reti                            ; return from interrupt
    1432:	00 13       	reti			

00001434 <OSCPUSaveSR>:
*/

.global OSCPUSaveSR
.type OSCPUSaveSR, @function
OSCPUSaveSR:
            MOV.W    r2,r15			/* gcc returns the value of the sr in r15 */
    1434:	0f 42       	mov	r2,	r15	
            DINT
    1436:	32 c2       	dint			
            RET
    1438:	30 41       	ret			

0000143a <OSCPURestoreSR>:

.global OSCPURestoreSR
.type OSCPURestoreSR, @function
OSCPURestoreSR:
            MOV.W    r15,r2			/* gcc passes the sr in r15 */
    143a:	02 4f       	mov	r15,	r2	
            RET
    143c:	30 41       	ret			

0000143e <OSInitHookBegin>:
* Note(s)    : 1) Interrupts should be disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSInitHookBegin (void)
{
    143e:	04 12       	push	r4		
    1440:	04 41       	mov	r1,	r4	
}
    1442:	34 41       	pop	r4		
    1444:	30 41       	ret			

00001446 <OSInitHookEnd>:
* Note(s)    : 1) Interrupts should be disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSInitHookEnd (void)
{
    1446:	04 12       	push	r4		
    1448:	04 41       	mov	r1,	r4	
}
    144a:	34 41       	pop	r4		
    144c:	30 41       	ret			

0000144e <OSTaskCreateHook>:
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 
void  OSTaskCreateHook (OS_TCB *ptcb)
{
    144e:	04 12       	push	r4		
    1450:	21 83       	decd	r1		
    1452:	04 41       	mov	r1,	r4	
    1454:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
    1458:	21 53       	incd	r1		
    145a:	34 41       	pop	r4		
    145c:	30 41       	ret			

0000145e <OSTaskDelHook>:
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 
void  OSTaskDelHook (OS_TCB *ptcb)
{
    145e:	04 12       	push	r4		
    1460:	21 83       	decd	r1		
    1462:	04 41       	mov	r1,	r4	
    1464:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
    1468:	21 53       	incd	r1		
    146a:	34 41       	pop	r4		
    146c:	30 41       	ret			

0000146e <OSTaskIdleHook>:
* Note(s)    : 1) Interrupts are enabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION >= 251
void  OSTaskIdleHook (void)
{
    146e:	04 12       	push	r4		
    1470:	04 41       	mov	r1,	r4	
#if 0
    LPM0;                                         /* Enter low power mode                              */
#endif    
}
    1472:	34 41       	pop	r4		
    1474:	30 41       	ret			

00001476 <OSTaskStatHook>:
*********************************************************************************************************
*/

#if OS_CPU_HOOKS_EN > 0 
void  OSTaskStatHook (void)
{
    1476:	04 12       	push	r4		
    1478:	04 41       	mov	r1,	r4	
}
    147a:	34 41       	pop	r4		
    147c:	30 41       	ret			

0000147e <OSTaskStkInit>:
*                 }
*********************************************************************************************************
*/

OS_STK  *OSTaskStkInit (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT16U opt)
{
    147e:	04 12       	push	r4		
    1480:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    1484:	04 41       	mov	r1,	r4	
    1486:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    148a:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    148e:	84 4d 06 00 	mov	r13,	6(r4)	;0x0006(r4)
    1492:	84 4c 08 00 	mov	r12,	8(r4)	;0x0008(r4)
    INT16U  *top;


    opt    = opt;                 
    top    = (INT16U *)ptos;
    1496:	94 44 06 00 	mov	6(r4),	0(r4)	;0x0006(r4), 0x0000(r4)
    149a:	00 00 
    top--;  
    149c:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)task;
    14a0:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    14a4:	2f 44       	mov	@r4,	r15	
    14a6:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    top--;
    14aa:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)task;                          /* Interrupt return pointer                          */
    14ae:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    14b2:	2f 44       	mov	@r4,	r15	
    14b4:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    top--;
    14b8:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0008;                        /* Status register                                   */
    14bc:	2f 44       	mov	@r4,	r15	
    14be:	bf 42 00 00 	mov	#8,	0(r15)	;r2 As==11, 0x0000(r15)
    top--;
    14c2:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0404;
    14c6:	2f 44       	mov	@r4,	r15	
    14c8:	bf 40 04 04 	mov	#1028,	0(r15)	;#0x0404, 0x0000(r15)
    14cc:	00 00 
    top--;
    14ce:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0505;
    14d2:	2f 44       	mov	@r4,	r15	
    14d4:	bf 40 05 05 	mov	#1285,	0(r15)	;#0x0505, 0x0000(r15)
    14d8:	00 00 
    top--;
    14da:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0606;
    14de:	2f 44       	mov	@r4,	r15	
    14e0:	bf 40 06 06 	mov	#1542,	0(r15)	;#0x0606, 0x0000(r15)
    14e4:	00 00 
    top--;
    14e6:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0707;
    14ea:	2f 44       	mov	@r4,	r15	
    14ec:	bf 40 07 07 	mov	#1799,	0(r15)	;#0x0707, 0x0000(r15)
    14f0:	00 00 
    top--;
    14f2:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0808;
    14f6:	2f 44       	mov	@r4,	r15	
    14f8:	bf 40 08 08 	mov	#2056,	0(r15)	;#0x0808, 0x0000(r15)
    14fc:	00 00 
    top--;
    14fe:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0909;
    1502:	2f 44       	mov	@r4,	r15	
    1504:	bf 40 09 09 	mov	#2313,	0(r15)	;#0x0909, 0x0000(r15)
    1508:	00 00 
    top--;
    150a:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1010;
    150e:	2f 44       	mov	@r4,	r15	
    1510:	bf 40 10 10 	mov	#4112,	0(r15)	;#0x1010, 0x0000(r15)
    1514:	00 00 
    top--;
    1516:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1111;
    151a:	2f 44       	mov	@r4,	r15	
    151c:	bf 40 11 11 	mov	#4369,	0(r15)	;#0x1111, 0x0000(r15)
    1520:	00 00 
    top--;
    1522:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1212;           /* IAR Only */  /* Pass 'p_arg' through register R12                 */
    1526:	2f 44       	mov	@r4,	r15	
    1528:	bf 40 12 12 	mov	#4626,	0(r15)	;#0x1212, 0x0000(r15)
    152c:	00 00 
    top--;
    152e:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1313;
    1532:	2f 44       	mov	@r4,	r15	
    1534:	bf 40 13 13 	mov	#4883,	0(r15)	;#0x1313, 0x0000(r15)
    1538:	00 00 
    top--;
    153a:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1414;                         
    153e:	2f 44       	mov	@r4,	r15	
    1540:	bf 40 14 14 	mov	#5140,	0(r15)	;#0x1414, 0x0000(r15)
    1544:	00 00 
    top--;
    1546:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)p_arg;           /* GCC uses r15 */
    154a:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    154e:	2f 44       	mov	@r4,	r15	
    1550:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    return ((OS_STK *)top);    
    1554:	2f 44       	mov	@r4,	r15	
}
    1556:	31 50 0a 00 	add	#10,	r1	;#0x000a
    155a:	34 41       	pop	r4		
    155c:	30 41       	ret			

0000155e <OSTaskSwHook>:
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0
void  OSTaskSwHook (void)
{
    155e:	04 12       	push	r4		
    1560:	04 41       	mov	r1,	r4	
}
    1562:	34 41       	pop	r4		
    1564:	30 41       	ret			

00001566 <OSTCBInitHook>:
* Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSTCBInitHook (OS_TCB *ptcb)
{
    1566:	04 12       	push	r4		
    1568:	21 83       	decd	r1		
    156a:	04 41       	mov	r1,	r4	
    156c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                                           /* Prevent Compiler warning                 */
}
    1570:	21 53       	incd	r1		
    1572:	34 41       	pop	r4		
    1574:	30 41       	ret			

00001576 <OSTimeTickHook>:
* Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0
void  OSTimeTickHook (void)
{
    1576:	04 12       	push	r4		
    1578:	04 41       	mov	r1,	r4	
}
    157a:	34 41       	pop	r4		
    157c:	30 41       	ret			

0000157e <OSMapTbl>:
    157e:	01 02 04 08 10 20 40 80                             ..... @.

00001586 <OSUnMapTbl>:
    1586:	00 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1596:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15a6:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15b6:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15c6:	06 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15d6:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15e6:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15f6:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1606:	07 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1616:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1626:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1636:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1646:	06 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1656:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1666:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1676:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................

00001686 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
    1686:	04 12       	push	r4		
    1688:	04 41       	mov	r1,	r4	
#if OS_VERSION >= 204
    OSInitHookBegin();                                           /* Call port specific initialization code   */
    168a:	b0 12 3e 14 	call	#0x143e	
#endif

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
    168e:	b0 12 6a 1c 	call	#0x1c6a	

    OS_InitRdyList();                                            /* Initialize the Ready List                */
    1692:	b0 12 92 1c 	call	#0x1c92	

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
    1696:	b0 12 08 1d 	call	#0x1d08	

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
    169a:	b0 12 00 1c 	call	#0x1c00	

#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
    169e:	b0 12 5a 27 	call	#0x275a	
#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
    16a2:	b0 12 6e 32 	call	#0x326e	
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
    16a6:	b0 12 d4 1c 	call	#0x1cd4	
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
#endif

#if OS_VERSION >= 204
    OSInitHookEnd();                                             /* Call port specific init. code            */
    16aa:	b0 12 46 14 	call	#0x1446	
#endif

#if OS_VERSION >= 270 && OS_DEBUG_EN > 0
    OSDebugInit();
#endif
}
    16ae:	34 41       	pop	r4		
    16b0:	30 41       	ret			

000016b2 <OSIntEnter>:
*                 OSIntEnter() is always called with interrupts disabled.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
    16b2:	04 12       	push	r4		
    16b4:	04 41       	mov	r1,	r4	
    if (OSRunning == TRUE) {
    16b6:	5f 42 0d 03 	mov.b	&0x030d,r15	
    16ba:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    16bc:	09 20       	jnz	$+20     	;abs 0x16d0
        if (OSIntNesting < 255u) {
    16be:	5f 42 86 03 	mov.b	&0x0386,r15	
    16c2:	7f 93       	cmp.b	#-1,	r15	;r3 As==11
    16c4:	05 24       	jz	$+12     	;abs 0x16d0
            OSIntNesting++;                      /* Increment ISR nesting level                        */
    16c6:	5f 42 86 03 	mov.b	&0x0386,r15	
    16ca:	5f 53       	inc.b	r15		
    16cc:	c2 4f 86 03 	mov.b	r15,	&0x0386	
        }
    }
}
    16d0:	34 41       	pop	r4		
    16d2:	30 41       	ret			

000016d4 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
    16d4:	04 12       	push	r4		
    16d6:	21 82       	sub	#4,	r1	;r2 As==10
    16d8:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    16da:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSRunning == TRUE) {
    16de:	5f 42 0d 03 	mov.b	&0x030d,r15	
    16e2:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    16e4:	55 20       	jnz	$+172    	;abs 0x1790
        OS_ENTER_CRITICAL();
    16e6:	b0 12 34 14 	call	#0x1434	
    16ea:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
    16ee:	5f 42 86 03 	mov.b	&0x0386,r15	
    16f2:	4f 93       	tst.b	r15		
    16f4:	05 24       	jz	$+12     	;abs 0x1700
            OSIntNesting--;
    16f6:	5f 42 86 03 	mov.b	&0x0386,r15	
    16fa:	7f 53       	add.b	#-1,	r15	;r3 As==11
    16fc:	c2 4f 86 03 	mov.b	r15,	&0x0386	
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
    1700:	5f 42 86 03 	mov.b	&0x0386,r15	
    1704:	4f 93       	tst.b	r15		
    1706:	41 20       	jnz	$+132    	;abs 0x178a
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
    1708:	5f 42 0c 03 	mov.b	&0x030c,r15	
    170c:	4f 93       	tst.b	r15		
    170e:	3d 20       	jnz	$+124    	;abs 0x178a
                y             = OSUnMapTbl[OSRdyGrp];          
    1710:	5f 42 7e 03 	mov.b	&0x037e,r15	
    1714:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1716:	d4 4f 86 15 	mov.b	5510(r15),2(r4)	;0x1586(r15), 0x0002(r4)
    171a:	02 00 
                OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
    171c:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1720:	4f 5f       	rla.b	r15		
    1722:	4f 5f       	rla.b	r15		
    1724:	4f 5f       	rla.b	r15		
    1726:	4e 4f       	mov.b	r15,	r14	
    1728:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    172c:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1730:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1732:	5f 4f 86 15 	mov.b	5510(r15),r15	;0x1586(r15)
    1736:	4f 5e       	add.b	r14,	r15	
    1738:	c2 4f 12 03 	mov.b	r15,	&0x0312	
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
    173c:	5e 42 12 03 	mov.b	&0x0312,r14	
    1740:	5f 42 26 03 	mov.b	&0x0326,r15	
    1744:	4e 9f       	cmp.b	r15,	r14	
    1746:	21 24       	jz	$+68     	;abs 0x178a
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
    1748:	5f 42 12 03 	mov.b	&0x0312,r15	
    174c:	7f f3       	and.b	#-1,	r15	;r3 As==11
    174e:	0f 5f       	rla	r15		
    1750:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    1754:	2f 4f       	mov	@r15,	r15	
    1756:	82 4f 7a 03 	mov	r15,	&0x037a	
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
    175a:	1d 42 7a 03 	mov	&0x037a,r13	
    175e:	1e 4d 22 00 	mov	34(r13),r14	;0x0022(r13)
    1762:	1f 4d 24 00 	mov	36(r13),r15	;0x0024(r13)
    1766:	1e 53       	inc	r14		
    1768:	0f 63       	adc	r15		
    176a:	8d 4e 22 00 	mov	r14,	34(r13)	;0x0022(r13)
    176e:	8d 4f 24 00 	mov	r15,	36(r13)	;0x0024(r13)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
    1772:	1e 42 2c 03 	mov	&0x032c,r14	
    1776:	1f 42 2e 03 	mov	&0x032e,r15	
    177a:	1e 53       	inc	r14		
    177c:	0f 63       	adc	r15		
    177e:	82 4e 2c 03 	mov	r14,	&0x032c	
    1782:	82 4f 2e 03 	mov	r15,	&0x032e	
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
    1786:	b0 12 9e 13 	call	#0x139e	
                }
            }
        }
        OS_EXIT_CRITICAL();
    178a:	2f 44       	mov	@r4,	r15	
    178c:	b0 12 3a 14 	call	#0x143a	
    }
}
    1790:	21 52       	add	#4,	r1	;r2 As==10
    1792:	34 41       	pop	r4		
    1794:	30 41       	ret			

00001796 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
    1796:	04 12       	push	r4		
    1798:	21 83       	decd	r1		
    179a:	04 41       	mov	r1,	r4	
    INT8U y;
    INT8U x;


    if (OSRunning == FALSE) {
    179c:	5f 42 0d 03 	mov.b	&0x030d,r15	
    17a0:	4f 93       	tst.b	r15		
    17a2:	29 20       	jnz	$+84     	;abs 0x17f6
        y             = OSUnMapTbl[OSRdyGrp];        /* Find highest priority's task priority number   */
    17a4:	5f 42 7e 03 	mov.b	&0x037e,r15	
    17a8:	7f f3       	and.b	#-1,	r15	;r3 As==11
    17aa:	d4 4f 86 15 	mov.b	5510(r15),1(r4)	;0x1586(r15), 0x0001(r4)
    17ae:	01 00 
        x             = OSUnMapTbl[OSRdyTbl[y]];
    17b0:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    17b4:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    17b8:	7f f3       	and.b	#-1,	r15	;r3 As==11
    17ba:	d4 4f 86 15 	mov.b	5510(r15),0(r4)	;0x1586(r15), 0x0000(r4)
    17be:	00 00 
        OSPrioHighRdy = (INT8U)((y << 3) + x);
    17c0:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    17c4:	4f 5f       	rla.b	r15		
    17c6:	4f 5f       	rla.b	r15		
    17c8:	4f 5f       	rla.b	r15		
    17ca:	6f 54       	add.b	@r4,	r15	
    17cc:	c2 4f 12 03 	mov.b	r15,	&0x0312	
        OSPrioCur     = OSPrioHighRdy;
    17d0:	5f 42 12 03 	mov.b	&0x0312,r15	
    17d4:	c2 4f 26 03 	mov.b	r15,	&0x0326	
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
    17d8:	5f 42 12 03 	mov.b	&0x0312,r15	
    17dc:	7f f3       	and.b	#-1,	r15	;r3 As==11
    17de:	0f 5f       	rla	r15		
    17e0:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    17e4:	2f 4f       	mov	@r15,	r15	
    17e6:	82 4f 7a 03 	mov	r15,	&0x037a	
        OSTCBCur      = OSTCBHighRdy;
    17ea:	1f 42 7a 03 	mov	&0x037a,r15	
    17ee:	82 4f 88 03 	mov	r15,	&0x0388	
        OSStartHighRdy();                            /* Execute target specific code to start task     */
    17f2:	b0 12 20 13 	call	#0x1320	
    }
}
    17f6:	21 53       	incd	r1		
    17f8:	34 41       	pop	r4		
    17fa:	30 41       	ret			

000017fc <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
    17fc:	04 12       	push	r4		
    17fe:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1802:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                     */
    1804:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif
#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
    1808:	b0 12 76 15 	call	#0x1576	
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
    OSTime++;
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == TRUE) {
    180c:	5f 42 0d 03 	mov.b	&0x030d,r15	
    1810:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    1812:	89 20       	jnz	$+276    	;abs 0x1926
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
    1814:	5f 42 2a 03 	mov.b	&0x032a,r15	
    1818:	7f f3       	and.b	#-1,	r15	;r3 As==11
    181a:	1f 93       	cmp	#1,	r15	;r3 As==01
    181c:	07 24       	jz	$+16     	;abs 0x182c
    181e:	2f 93       	cmp	#2,	r15	;r3 As==10
    1820:	08 24       	jz	$+18     	;abs 0x1832
    1822:	0f 93       	tst	r15		
    1824:	0b 20       	jnz	$+24     	;abs 0x183c
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = TRUE;
    1826:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    182a:	0c 3c       	jmp	$+26     	;abs 0x1844
                 break;

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = FALSE;                             /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
    182c:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    1830:	09 3c       	jmp	$+20     	;abs 0x1844
                 break;

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = TRUE;                   /*      ... step command from uC/OS-View        */
    1832:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
                 OSTickStepState = OS_TICK_STEP_WAIT;
    1836:	d2 43 2a 03 	mov.b	#1,	&0x032a	;r3 As==01
    183a:	04 3c       	jmp	$+10     	;abs 0x1844
                 break;

            default:                                       /* Invalid case, correct situation              */
                 step            = TRUE;
    183c:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
                 OSTickStepState = OS_TICK_STEP_DIS;
    1840:	c2 43 2a 03 	mov.b	#0,	&0x032a	;r3 As==00
                 break;
        }
        if (step == FALSE) {                               /* Return if waiting for step command           */
    1844:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    1848:	6d 24       	jz	$+220    	;abs 0x1924
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
    184a:	94 42 28 03 	mov	&0x0328,4(r4)	;0x0004(r4)
    184e:	04 00 
    1850:	61 3c       	jmp	$+196    	;abs 0x1914
        while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {          /* Go through all TCBs in TCB list              */
            OS_ENTER_CRITICAL();
    1852:	b0 12 34 14 	call	#0x1434	
    1856:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
    185a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    185e:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    1862:	0f 93       	tst	r15		
    1864:	4f 24       	jz	$+160    	;abs 0x1904
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
    1866:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    186a:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    186e:	0e 4f       	mov	r15,	r14	
    1870:	3e 53       	add	#-1,	r14	;r3 As==11
    1872:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1876:	8f 4e 18 00 	mov	r14,	24(r15)	;0x0018(r15)
    187a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    187e:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    1882:	0f 93       	tst	r15		
    1884:	3f 20       	jnz	$+128    	;abs 0x1904
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
    1886:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    188a:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    188e:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1890:	3f f0 37 00 	and	#55,	r15	;#0x0037
    1894:	10 24       	jz	$+34     	;abs 0x18b6
                        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag   */
    1896:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    189a:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    189e:	4e 4f       	mov.b	r15,	r14	
    18a0:	7e f0 c8 ff 	and.b	#-56,	r14	;#0xffc8
    18a4:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18a8:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
                        ptcb->OSTCBPendTO  = TRUE;                             /* Indicate PEND timeout    */
    18ac:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18b0:	df 43 1b 00 	mov.b	#1,	27(r15)	;r3 As==01, 0x001b(r15)
    18b4:	04 3c       	jmp	$+10     	;abs 0x18be
                    } else {
                        ptcb->OSTCBPendTO  = FALSE;
    18b6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18ba:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
    18be:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18c2:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    18c6:	7f f3       	and.b	#-1,	r15	;r3 As==11
    18c8:	3f f2       	and	#8,	r15	;r2 As==11
    18ca:	1c 20       	jnz	$+58     	;abs 0x1904
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
    18cc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18d0:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    18d4:	5f 42 7e 03 	mov.b	&0x037e,r15	
    18d8:	4f de       	bis.b	r14,	r15	
    18da:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    18de:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18e2:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    18e6:	4d 4f       	mov.b	r15,	r13	
    18e8:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18ec:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    18f0:	7f f3       	and.b	#-1,	r15	;r3 As==11
    18f2:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    18f6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18fa:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    18fe:	4f de       	bis.b	r14,	r15	
    1900:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
    1904:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1908:	94 4f 0e 00 	mov	14(r15),4(r4)	;0x000e(r15), 0x0004(r4)
    190c:	04 00 
            OS_EXIT_CRITICAL();
    190e:	2f 44       	mov	@r4,	r15	
    1910:	b0 12 3a 14 	call	#0x143a	
        if (step == FALSE) {                               /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {          /* Go through all TCBs in TCB list              */
    1914:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1918:	5f 4f 1c 00 	mov.b	28(r15),r15	;0x001c(r15)
    191c:	7f 90 14 00 	cmp.b	#20,	r15	;#0x0014
    1920:	98 23       	jnz	$-206    	;abs 0x1852
    1922:	01 3c       	jmp	$+4      	;abs 0x1926
                 step            = TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == FALSE) {                               /* Return if waiting for step command           */
            return;
    1924:	03 43       	nop			
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
    1926:	31 50 06 00 	add	#6,	r1	;#0x0006
    192a:	34 41       	pop	r4		
    192c:	30 41       	ret			

0000192e <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
    192e:	04 12       	push	r4		
    1930:	04 41       	mov	r1,	r4	
    return (OS_VERSION);
    1932:	3f 40 14 01 	mov	#276,	r15	;#0x0114
}
    1936:	34 41       	pop	r4		
    1938:	30 41       	ret			

0000193a <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *msg, INT8U msk)
{
    193a:	04 12       	push	r4		
    193c:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    1940:	04 41       	mov	r1,	r4	
    1942:	84 4f 08 00 	mov	r15,	8(r4)	;0x0008(r4)
    1946:	84 4e 0a 00 	mov	r14,	10(r4)	;0x000a(r4)
    194a:	c4 4d 0c 00 	mov.b	r13,	12(r4)	;0x000c(r4)
    INT8U   bitx;
    INT8U   bity;
    INT8U   prio;


    y                      = OSUnMapTbl[pevent->OSEventGrp];   /* Find HPT waiting for message         */
    194e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1952:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    1956:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1958:	d4 4f 86 15 	mov.b	5510(r15),3(r4)	;0x1586(r15), 0x0003(r4)
    195c:	03 00 
    bity                   = OSMapTbl[y];
    195e:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    1962:	d4 4f 7e 15 	mov.b	5502(r15),1(r4)	;0x157e(r15), 0x0001(r4)
    1966:	01 00 
    x                      = OSUnMapTbl[pevent->OSEventTbl[y]];
    1968:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    196c:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1970:	0f 5e       	add	r14,	r15	
    1972:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1976:	6f 4f       	mov.b	@r15,	r15	
    1978:	7f f3       	and.b	#-1,	r15	;r3 As==11
    197a:	d4 4f 86 15 	mov.b	5510(r15),4(r4)	;0x1586(r15), 0x0004(r4)
    197e:	04 00 
    bitx                   = OSMapTbl[x];
    1980:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    1984:	d4 4f 7e 15 	mov.b	5502(r15),2(r4)	;0x157e(r15), 0x0002(r4)
    1988:	02 00 
    prio                   = (INT8U)((y << 3) + x);     /* Find priority of task getting the msg       */
    198a:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    198e:	4f 5f       	rla.b	r15		
    1990:	4f 5f       	rla.b	r15		
    1992:	4f 5f       	rla.b	r15		
    1994:	4e 4f       	mov.b	r15,	r14	
    1996:	5e 54 04 00 	add.b	4(r4),	r14	;0x0004(r4)
    199a:	c4 4e 00 00 	mov.b	r14,	0(r4)	;0x0000(r4)
    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
    199e:	5d 44 03 00 	mov.b	3(r4),	r13	;0x0003(r4)
    19a2:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    19a6:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    19aa:	0f 5e       	add	r14,	r15	
    19ac:	3f 50 06 00 	add	#6,	r15	;#0x0006
    19b0:	6f 4f       	mov.b	@r15,	r15	
    19b2:	4e 4f       	mov.b	r15,	r14	
    19b4:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    19b8:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    19ba:	4f fe       	and.b	r14,	r15	
    19bc:	4e 4f       	mov.b	r15,	r14	
    19be:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    19c2:	0f 5d       	add	r13,	r15	
    19c4:	3f 50 06 00 	add	#6,	r15	;#0x0006
    19c8:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    if (pevent->OSEventTbl[y] == 0x00) {                
    19cc:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    19d0:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    19d4:	0f 5e       	add	r14,	r15	
    19d6:	3f 50 06 00 	add	#6,	r15	;#0x0006
    19da:	6f 4f       	mov.b	@r15,	r15	
    19dc:	4f 93       	tst.b	r15		
    19de:	0e 20       	jnz	$+30     	;abs 0x19fc
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
    19e0:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    19e4:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    19e8:	4e 4f       	mov.b	r15,	r14	
    19ea:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    19ee:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    19f0:	4f fe       	and.b	r14,	r15	
    19f2:	4e 4f       	mov.b	r15,	r14	
    19f4:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    19f8:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
    }
    ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
    19fc:	6f 44       	mov.b	@r4,	r15	
    19fe:	0f 5f       	rla	r15		
    1a00:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    1a04:	a4 4f 06 00 	mov	@r15,	6(r4)	;0x0006(r4)
    ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
    1a08:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a0c:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)
    ptcb->OSTCBEventPtr  = (OS_EVENT *)0;               /* Unlink ECB from this task                   */
    1a10:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a14:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg       = msg;                         /* Send message directly to waiting task       */
    1a18:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a1c:	9f 44 0a 00 	mov	10(r4),	20(r15)	;0x000a(r4), 0x0014(r15)
    1a20:	14 00 
#else
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = FALSE;                       /* Cancel 'any' timeout because of post        */
    1a22:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a26:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
    1a2a:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a2e:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1a32:	4e 4f       	mov.b	r15,	r14	
    1a34:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    1a38:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1a3a:	4f fe       	and.b	r14,	r15	
    1a3c:	4e 4f       	mov.b	r15,	r14	
    1a3e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a42:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {               /* See if task is ready (could be susp'd)      */
    1a46:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    1a4a:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1a4e:	4f 93       	tst.b	r15		
    1a50:	10 20       	jnz	$+34     	;abs 0x1a72
        OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
    1a52:	5f 42 7e 03 	mov.b	&0x037e,r15	
    1a56:	5f d4 01 00 	bis.b	1(r4),	r15	;0x0001(r4)
    1a5a:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[y]     |=  bitx;
    1a5e:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    1a62:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    1a66:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1a6a:	5f d4 02 00 	bis.b	2(r4),	r15	;0x0002(r4)
    1a6e:	ce 4f 80 03 	mov.b	r15,	896(r14);0x0380(r14)
    }
    return (prio);
    1a72:	6f 44       	mov.b	@r4,	r15	
}
    1a74:	31 50 0e 00 	add	#14,	r1	;#0x000e
    1a78:	34 41       	pop	r4		
    1a7a:	30 41       	ret			

00001a7c <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    1a7c:	04 12       	push	r4		
    1a7e:	21 82       	sub	#4,	r1	;r2 As==10
    1a80:	04 41       	mov	r1,	r4	
    1a82:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    1a86:	1f 42 88 03 	mov	&0x0388,r15	
    1a8a:	9f 44 02 00 	mov	2(r4),	18(r15)	;0x0002(r4), 0x0012(r15)
    1a8e:	12 00 
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    1a90:	1f 42 88 03 	mov	&0x0388,r15	
    1a94:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    1a98:	00 00 
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
    1a9a:	6d 44       	mov.b	@r4,	r13	
    1a9c:	6f 44       	mov.b	@r4,	r15	
    1a9e:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1aa2:	4e 4f       	mov.b	r15,	r14	
    1aa4:	1f 42 88 03 	mov	&0x0388,r15	
    1aa8:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1aac:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1aae:	4f fe       	and.b	r14,	r15	
    1ab0:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
    if (OSRdyTbl[y] == 0x00) {                   
    1ab4:	6f 44       	mov.b	@r4,	r15	
    1ab6:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1aba:	4f 93       	tst.b	r15		
    1abc:	0b 20       	jnz	$+24     	;abs 0x1ad4
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
    1abe:	1f 42 88 03 	mov	&0x0388,r15	
    1ac2:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1ac6:	4e 4f       	mov.b	r15,	r14	
    1ac8:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    1aca:	5f 42 7e 03 	mov.b	&0x037e,r15	
    1ace:	4f fe       	and.b	r14,	r15	
    1ad0:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
    1ad4:	1f 42 88 03 	mov	&0x0388,r15	
    1ad8:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1adc:	4d 4f       	mov.b	r15,	r13	
    1ade:	1f 42 88 03 	mov	&0x0388,r15	
    1ae2:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1ae6:	4e 4f       	mov.b	r15,	r14	
    1ae8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1aec:	0f 5e       	add	r14,	r15	
    1aee:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1af2:	6e 4f       	mov.b	@r15,	r14	
    1af4:	1f 42 88 03 	mov	&0x0388,r15	
    1af8:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1afc:	4e df       	bis.b	r15,	r14	
    1afe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b02:	0f 5d       	add	r13,	r15	
    1b04:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b08:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
    1b0c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b10:	5e 4f 01 00 	mov.b	1(r15),	r14	;0x0001(r15)
    1b14:	1f 42 88 03 	mov	&0x0388,r15	
    1b18:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1b1c:	4e df       	bis.b	r15,	r14	
    1b1e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b22:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
}
    1b26:	21 52       	add	#4,	r1	;r2 As==10
    1b28:	34 41       	pop	r4		
    1b2a:	30 41       	ret			

00001b2c <OS_EventTO>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTO (OS_EVENT *pevent)
{
    1b2c:	04 12       	push	r4		
    1b2e:	21 82       	sub	#4,	r1	;r2 As==10
    1b30:	04 41       	mov	r1,	r4	
    1b32:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  y;


    y                      = OSTCBCur->OSTCBY;
    1b36:	1f 42 88 03 	mov	&0x0388,r15	
    1b3a:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    1b3e:	00 00 
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
    1b40:	6d 44       	mov.b	@r4,	r13	
    1b42:	6e 44       	mov.b	@r4,	r14	
    1b44:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b48:	0f 5e       	add	r14,	r15	
    1b4a:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b4e:	6f 4f       	mov.b	@r15,	r15	
    1b50:	4e 4f       	mov.b	r15,	r14	
    1b52:	1f 42 88 03 	mov	&0x0388,r15	
    1b56:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1b5a:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1b5c:	4f fe       	and.b	r14,	r15	
    1b5e:	4e 4f       	mov.b	r15,	r14	
    1b60:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b64:	0f 5d       	add	r13,	r15	
    1b66:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b6a:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    if (pevent->OSEventTbl[y] == 0x00) {
    1b6e:	6e 44       	mov.b	@r4,	r14	
    1b70:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b74:	0f 5e       	add	r14,	r15	
    1b76:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b7a:	6f 4f       	mov.b	@r15,	r15	
    1b7c:	4f 93       	tst.b	r15		
    1b7e:	10 20       	jnz	$+34     	;abs 0x1ba0
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
    1b80:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b84:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    1b88:	4e 4f       	mov.b	r15,	r14	
    1b8a:	1f 42 88 03 	mov	&0x0388,r15	
    1b8e:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1b92:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1b94:	4f fe       	and.b	r14,	r15	
    1b96:	4e 4f       	mov.b	r15,	r14	
    1b98:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b9c:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
    }
    OSTCBCur->OSTCBPendTO   = FALSE;                   /* Clear the Pend Timeout flag                  */
    1ba0:	1f 42 88 03 	mov	&0x0388,r15	
    1ba4:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
    1ba8:	1f 42 88 03 	mov	&0x0388,r15	
    1bac:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
    1bb0:	1f 42 88 03 	mov	&0x0388,r15	
    1bb4:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
}
    1bb8:	21 52       	add	#4,	r1	;r2 As==10
    1bba:	34 41       	pop	r4		
    1bbc:	30 41       	ret			

00001bbe <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
    1bbe:	04 12       	push	r4		
    1bc0:	21 82       	sub	#4,	r1	;r2 As==10
    1bc2:	04 41       	mov	r1,	r4	
    1bc4:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  *ptbl;


    pevent->OSEventGrp = 0x00;                   /* No task waiting on event                           */
    1bc8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bcc:	cf 43 01 00 	mov.b	#0,	1(r15)	;r3 As==00, 0x0001(r15)
    ptbl               = &pevent->OSEventTbl[0];
    1bd0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bd4:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1bd8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)

#if OS_EVENT_TBL_SIZE > 0
    *ptbl++            = 0x00;
    1bdc:	2f 44       	mov	@r4,	r15	
    1bde:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1be2:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 1
    *ptbl++            = 0x00;
    1be6:	2f 44       	mov	@r4,	r15	
    1be8:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1bec:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 2
    *ptbl++            = 0x00;
    1bf0:	2f 44       	mov	@r4,	r15	
    1bf2:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1bf6:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 7
    *ptbl              = 0x00;
#endif
}
    1bfa:	21 52       	add	#4,	r1	;r2 As==10
    1bfc:	34 41       	pop	r4		
    1bfe:	30 41       	ret			

00001c00 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
    1c00:	04 12       	push	r4		
    1c02:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1c06:	04 41       	mov	r1,	r4	
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    1c08:	3f 40 0a 04 	mov	#1034,	r15	;#0x040a
    1c0c:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    1c10:	b0 12 74 1d 	call	#0x1d74	
    pevent1 = &OSEventTbl[0];
    1c14:	b4 40 0a 04 	mov	#1034,	2(r4)	;#0x040a, 0x0002(r4)
    1c18:	02 00 
    pevent2 = &OSEventTbl[1];
    1c1a:	b4 40 14 04 	mov	#1044,	0(r4)	;#0x0414, 0x0000(r4)
    1c1e:	00 00 
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
    1c20:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    1c24:	10 3c       	jmp	$+34     	;abs 0x1c46
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
    1c26:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1c2a:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        pevent1->OSEventPtr     = pevent2;
    1c2e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1c32:	af 44 04 00 	mov	@r4,	4(r15)	;0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
    1c36:	b4 50 0a 00 	add	#10,	2(r4)	;#0x000a, 0x0002(r4)
    1c3a:	02 00 
        pevent2++;
    1c3c:	b4 50 0a 00 	add	#10,	0(r4)	;#0x000a, 0x0000(r4)
    1c40:	00 00 


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
    1c42:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    1c46:	a4 92 04 00 	cmp	#4,	4(r4)	;r2 As==10, 0x0004(r4)
    1c4a:	ed 2b       	jnc	$-36     	;abs 0x1c26
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
    1c4c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1c50:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
    1c54:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1c58:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';                  
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
#endif
    OSEventFreeList                 = &OSEventTbl[0];
    1c5c:	b2 40 0a 04 	mov	#1034,	&0x0384	;#0x040a
    1c60:	84 03 
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
    1c62:	31 50 06 00 	add	#6,	r1	;#0x0006
    1c66:	34 41       	pop	r4		
    1c68:	30 41       	ret			

00001c6a <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
    1c6a:	04 12       	push	r4		
    1c6c:	04 41       	mov	r1,	r4	
#if OS_TIME_GET_SET_EN > 0   
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
    1c6e:	c2 43 86 03 	mov.b	#0,	&0x0386	;r3 As==00
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
    1c72:	c2 43 0c 03 	mov.b	#0,	&0x030c	;r3 As==00

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
    1c76:	c2 43 32 03 	mov.b	#0,	&0x0332	;r3 As==00

    OSRunning     = FALSE;                                 /* Indicate that multitasking not started   */
    1c7a:	c2 43 0d 03 	mov.b	#0,	&0x030d	;r3 As==00
    
    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
    1c7e:	82 43 2c 03 	mov	#0,	&0x032c	;r3 As==00
    1c82:	82 43 2e 03 	mov	#0,	&0x032e	;r3 As==00
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
    1c86:	82 43 0e 03 	mov	#0,	&0x030e	;r3 As==00
    1c8a:	82 43 10 03 	mov	#0,	&0x0310	;r3 As==00
#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
    OSIdleCtrMax  = 0L;
    OSStatRdy     = FALSE;                                 /* Statistic task is not ready              */
#endif
}
    1c8e:	34 41       	pop	r4		
    1c90:	30 41       	ret			

00001c92 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
    1c92:	04 12       	push	r4		
    1c94:	21 82       	sub	#4,	r1	;r2 As==10
    1c96:	04 41       	mov	r1,	r4	
    INT8U    i;
    INT8U   *prdytbl;


    OSRdyGrp      = 0x00;                                  /* Clear the ready list                     */
    1c98:	c2 43 7e 03 	mov.b	#0,	&0x037e	;r3 As==00
    prdytbl       = &OSRdyTbl[0];
    1c9c:	b4 40 80 03 	mov	#896,	0(r4)	;#0x0380, 0x0000(r4)
    1ca0:	00 00 
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
    1ca2:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    1ca6:	07 3c       	jmp	$+16     	;abs 0x1cb6
        *prdytbl++ = 0x00;
    1ca8:	2f 44       	mov	@r4,	r15	
    1caa:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1cae:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    INT8U   *prdytbl;


    OSRdyGrp      = 0x00;                                  /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
    1cb2:	d4 53 02 00 	inc.b	2(r4)		;0x0002(r4)
    1cb6:	f4 90 03 00 	cmp.b	#3,	2(r4)	;#0x0003, 0x0002(r4)
    1cba:	02 00 
    1cbc:	f5 2b       	jnc	$-20     	;abs 0x1ca8
        *prdytbl++ = 0x00;
    }

    OSPrioCur     = 0;
    1cbe:	c2 43 26 03 	mov.b	#0,	&0x0326	;r3 As==00
    OSPrioHighRdy = 0;
    1cc2:	c2 43 12 03 	mov.b	#0,	&0x0312	;r3 As==00

    OSTCBHighRdy  = (OS_TCB *)0;                                 
    1cc6:	82 43 7a 03 	mov	#0,	&0x037a	;r3 As==00
    OSTCBCur      = (OS_TCB *)0;
    1cca:	82 43 88 03 	mov	#0,	&0x0388	;r3 As==00
}
    1cce:	21 52       	add	#4,	r1	;r2 As==10
    1cd0:	34 41       	pop	r4		
    1cd2:	30 41       	ret			

00001cd4 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
    1cd4:	04 12       	push	r4		
    1cd6:	04 41       	mov	r1,	r4	
#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
    1cd8:	7e 40 14 00 	mov.b	#20,	r14	;#0x0014
    1cdc:	3f 40 08 04 	mov	#1032,	r15	;#0x0408
    1ce0:	30 12 03 00 	push	#3		;#0x0003
    1ce4:	03 12       	push	#0		;r3 As==00
    1ce6:	03 12       	push	#0		;r3 As==00
    1ce8:	30 12 40 00 	push	#64		;#0x0040
    1cec:	30 12 8a 03 	push	#906		;#0x038a
    1cf0:	33 12       	push	#-1		;r3 As==11
    1cf2:	4c 4e       	mov.b	r14,	r12	
    1cf4:	0d 4f       	mov	r15,	r13	
    1cf6:	0e 43       	clr	r14		
    1cf8:	3f 40 82 1e 	mov	#7810,	r15	;#0x1e82
    1cfc:	b0 12 3c 38 	call	#0x383c	
    1d00:	31 50 0c 00 	add	#12,	r1	;#0x000c
                       (void *)0,
                       &OSTaskIdleStk[0],
                       OS_IDLE_PRIO);
    #endif
#endif
}
    1d04:	34 41       	pop	r4		
    1d06:	30 41       	ret			

00001d08 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
    1d08:	04 12       	push	r4		
    1d0a:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1d0e:	04 41       	mov	r1,	r4	
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    1d10:	3f 40 3c 04 	mov	#1084,	r15	;#0x043c
    1d14:	3e 40 38 01 	mov	#312,	r14	;#0x0138
    1d18:	b0 12 74 1d 	call	#0x1d74	
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    1d1c:	3f 40 76 05 	mov	#1398,	r15	;#0x0576
    1d20:	3e 40 2a 00 	mov	#42,	r14	;#0x002a
    1d24:	b0 12 74 1d 	call	#0x1d74	
    ptcb1 = &OSTCBTbl[0];
    1d28:	b4 40 3c 04 	mov	#1084,	2(r4)	;#0x043c, 0x0002(r4)
    1d2c:	02 00 
    ptcb2 = &OSTCBTbl[1];
    1d2e:	b4 40 70 04 	mov	#1136,	0(r4)	;#0x0470, 0x0000(r4)
    1d32:	00 00 
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
    1d34:	c4 43 04 00 	mov.b	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    1d38:	0c 3c       	jmp	$+26     	;abs 0x1d52
        ptcb1->OSTCBNext = ptcb2;
    1d3a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1d3e:	af 44 0e 00 	mov	@r4,	14(r15)	;0x000e(r15)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
    1d42:	b4 50 34 00 	add	#52,	2(r4)	;#0x0034, 0x0002(r4)
    1d46:	02 00 
        ptcb2++;
    1d48:	b4 50 34 00 	add	#52,	0(r4)	;#0x0034, 0x0000(r4)
    1d4c:	00 00 

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
    1d4e:	d4 53 04 00 	inc.b	4(r4)		;0x0004(r4)
    1d52:	f4 90 05 00 	cmp.b	#5,	4(r4)	;#0x0005, 0x0004(r4)
    1d56:	04 00 
    1d58:	f0 2b       	jnc	$-30     	;abs 0x1d3a
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
    1d5a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1d5e:	8f 43 0e 00 	mov	#0,	14(r15)	;r3 As==00, 0x000e(r15)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
    1d62:	82 43 28 03 	mov	#0,	&0x0328	;r3 As==00
    OSTCBFreeList           = &OSTCBTbl[0];
    1d66:	b2 40 3c 04 	mov	#1084,	&0x0330	;#0x043c
    1d6a:	30 03 
}
    1d6c:	31 50 06 00 	add	#6,	r1	;#0x0006
    1d70:	34 41       	pop	r4		
    1d72:	30 41       	ret			

00001d74 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    1d74:	04 12       	push	r4		
    1d76:	21 82       	sub	#4,	r1	;r2 As==10
    1d78:	04 41       	mov	r1,	r4	
    1d7a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    1d7e:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    1d82:	07 3c       	jmp	$+16     	;abs 0x1d92
    while (size > 0) {
        *pdest++ = (INT8U)0;
    1d84:	2f 44       	mov	@r4,	r15	
    1d86:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1d8a:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
        size--;
    1d8e:	b4 53 02 00 	add	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
    1d92:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    1d96:	f6 23       	jnz	$-18     	;abs 0x1d84
        *pdest++ = (INT8U)0;
        size--;
    }
}
    1d98:	21 52       	add	#4,	r1	;r2 As==10
    1d9a:	34 41       	pop	r4		
    1d9c:	30 41       	ret			

00001d9e <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    1d9e:	04 12       	push	r4		
    1da0:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1da4:	04 41       	mov	r1,	r4	
    1da6:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    1daa:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    1dae:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
    1db2:	0c 3c       	jmp	$+26     	;abs 0x1dcc
    while (size > 0) {
        *pdest++ = *psrc++;
    1db4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1db8:	6e 4f       	mov.b	@r15,	r14	
    1dba:	2f 44       	mov	@r4,	r15	
    1dbc:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    1dc0:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    1dc4:	94 53 02 00 	inc	2(r4)		;0x0002(r4)
        size--;
    1dc8:	b4 53 04 00 	add	#-1,	4(r4)	;r3 As==11, 0x0004(r4)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
    1dcc:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    1dd0:	f1 23       	jnz	$-28     	;abs 0x1db4
        *pdest++ = *psrc++;
        size--;
    }
}
    1dd2:	31 50 06 00 	add	#6,	r1	;#0x0006
    1dd6:	34 41       	pop	r4		
    1dd8:	30 41       	ret			

00001dda <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
    1dda:	04 12       	push	r4		
    1ddc:	21 82       	sub	#4,	r1	;r2 As==10
    1dde:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    1de0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    1de4:	b0 12 34 14 	call	#0x1434	
    1de8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
    1dec:	5f 42 86 03 	mov.b	&0x0386,r15	
    1df0:	4f 93       	tst.b	r15		
    1df2:	41 20       	jnz	$+132    	;abs 0x1e76
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
    1df4:	5f 42 0c 03 	mov.b	&0x030c,r15	
    1df8:	4f 93       	tst.b	r15		
    1dfa:	3d 20       	jnz	$+124    	;abs 0x1e76
            y             = OSUnMapTbl[OSRdyGrp];      /* Get pointer to HPT ready to run              */
    1dfc:	5f 42 7e 03 	mov.b	&0x037e,r15	
    1e00:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1e02:	d4 4f 86 15 	mov.b	5510(r15),2(r4)	;0x1586(r15), 0x0002(r4)
    1e06:	02 00 
            OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
    1e08:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1e0c:	4f 5f       	rla.b	r15		
    1e0e:	4f 5f       	rla.b	r15		
    1e10:	4f 5f       	rla.b	r15		
    1e12:	4e 4f       	mov.b	r15,	r14	
    1e14:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1e18:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1e1c:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1e1e:	5f 4f 86 15 	mov.b	5510(r15),r15	;0x1586(r15)
    1e22:	4f 5e       	add.b	r14,	r15	
    1e24:	c2 4f 12 03 	mov.b	r15,	&0x0312	
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
    1e28:	5e 42 12 03 	mov.b	&0x0312,r14	
    1e2c:	5f 42 26 03 	mov.b	&0x0326,r15	
    1e30:	4e 9f       	cmp.b	r15,	r14	
    1e32:	21 24       	jz	$+68     	;abs 0x1e76
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
    1e34:	5f 42 12 03 	mov.b	&0x0312,r15	
    1e38:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1e3a:	0f 5f       	rla	r15		
    1e3c:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    1e40:	2f 4f       	mov	@r15,	r15	
    1e42:	82 4f 7a 03 	mov	r15,	&0x037a	
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
    1e46:	1d 42 7a 03 	mov	&0x037a,r13	
    1e4a:	1e 4d 22 00 	mov	34(r13),r14	;0x0022(r13)
    1e4e:	1f 4d 24 00 	mov	36(r13),r15	;0x0024(r13)
    1e52:	1e 53       	inc	r14		
    1e54:	0f 63       	adc	r15		
    1e56:	8d 4e 22 00 	mov	r14,	34(r13)	;0x0022(r13)
    1e5a:	8d 4f 24 00 	mov	r15,	36(r13)	;0x0024(r13)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
    1e5e:	1e 42 2c 03 	mov	&0x032c,r14	
    1e62:	1f 42 2e 03 	mov	&0x032e,r15	
    1e66:	1e 53       	inc	r14		
    1e68:	0f 63       	adc	r15		
    1e6a:	82 4e 2c 03 	mov	r14,	&0x032c	
    1e6e:	82 4f 2e 03 	mov	r15,	&0x032e	
                OS_TASK_SW();                          /* Perform a context switch                     */
    1e72:	b0 12 4c 13 	call	#0x134c	
            }
        }
    }
    OS_EXIT_CRITICAL();
    1e76:	2f 44       	mov	@r4,	r15	
    1e78:	b0 12 3a 14 	call	#0x143a	
}
    1e7c:	21 52       	add	#4,	r1	;r2 As==10
    1e7e:	34 41       	pop	r4		
    1e80:	30 41       	ret			

00001e82 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *parg)
{
    1e82:	04 12       	push	r4		
    1e84:	21 82       	sub	#4,	r1	;r2 As==10
    1e86:	04 41       	mov	r1,	r4	
    1e88:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    1e8c:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    parg   = parg;                               /* Prevent compiler warning for not using 'parg'      */
    for (;;) {
        OS_ENTER_CRITICAL();
    1e90:	b0 12 34 14 	call	#0x1434	
    1e94:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        OSIdleCtr++;
    1e98:	1e 42 0e 03 	mov	&0x030e,r14	
    1e9c:	1f 42 10 03 	mov	&0x0310,r15	
    1ea0:	1e 53       	inc	r14		
    1ea2:	0f 63       	adc	r15		
    1ea4:	82 4e 0e 03 	mov	r14,	&0x030e	
    1ea8:	82 4f 10 03 	mov	r15,	&0x0310	
        OS_EXIT_CRITICAL();
    1eac:	2f 44       	mov	@r4,	r15	
    1eae:	b0 12 3a 14 	call	#0x143a	
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
    1eb2:	b0 12 6e 14 	call	#0x146e	
    1eb6:	ec 3f       	jmp	$-38     	;abs 0x1e90

00001eb8 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
    1eb8:	04 12       	push	r4		
    1eba:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    1ebe:	04 41       	mov	r1,	r4	
    1ec0:	c4 4f 04 00 	mov.b	r15,	4(r4)	;0x0004(r4)
    1ec4:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    1ec8:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
    1ecc:	84 4c 0a 00 	mov	r12,	10(r4)	;0x000a(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    1ed0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    1ed4:	b0 12 34 14 	call	#0x1434	
    1ed8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    1edc:	94 42 30 03 	mov	&0x0330,2(r4)	;0x0002(r4)
    1ee0:	02 00 
    if (ptcb != (OS_TCB *)0) {
    1ee2:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    1ee6:	d7 24       	jz	$+432    	;abs 0x2096
        OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
    1ee8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1eec:	1f 4f 0e 00 	mov	14(r15),r15	;0x000e(r15)
    1ef0:	82 4f 30 03 	mov	r15,	&0x0330	
        OS_EXIT_CRITICAL();
    1ef4:	2f 44       	mov	@r4,	r15	
    1ef6:	b0 12 3a 14 	call	#0x143a	
        ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
    1efa:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1efe:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    1f02:	00 00 
        ptcb->OSTCBPrio      = prio;                       /* Load task priority into TCB              */
    1f04:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f08:	df 44 04 00 	mov.b	4(r4),	28(r15)	;0x0004(r4), 0x001c(r15)
    1f0c:	1c 00 
        ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
    1f0e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f12:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
        ptcb->OSTCBPendTO    = FALSE;                      /* Clear the Pend timeout flag              */
    1f16:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f1a:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
        ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */
    1f1e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f22:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
    1f26:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f2a:	9f 44 14 00 	mov	20(r4),	2(r15)	;0x0014(r4), 0x0002(r15)
    1f2e:	02 00 
        ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
    1f30:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f34:	9f 44 10 00 	mov	16(r4),	6(r15)	;0x0010(r4), 0x0006(r15)
    1f38:	06 00 
    1f3a:	9f 44 12 00 	mov	18(r4),	8(r15)	;0x0012(r4), 0x0008(r15)
    1f3e:	08 00 
        ptcb->OSTCBStkBottom = pbos;                       /* Store pointer to bottom of stack         */
    1f40:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f44:	9f 44 08 00 	mov	8(r4),	4(r15)	;0x0008(r4), 0x0004(r15)
    1f48:	04 00 
        ptcb->OSTCBOpt       = opt;                        /* Store task options                       */
    1f4a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f4e:	9f 44 16 00 	mov	22(r4),	10(r15)	;0x0016(r4), 0x000a(r15)
    1f52:	0a 00 
        ptcb->OSTCBId        = id;                         /* Store task ID                            */
    1f54:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f58:	9f 44 0a 00 	mov	10(r4),	12(r15)	;0x000a(r4), 0x000c(r15)
    1f5c:	0c 00 

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq    = OS_NO_ERR;
#endif

        ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
    1f5e:	5e 44 04 00 	mov.b	4(r4),	r14	;0x0004(r4)
    1f62:	12 c3       	clrc			
    1f64:	4e 10       	rrc.b	r14		
    1f66:	4e 11       	rra.b	r14		
    1f68:	4e 11       	rra.b	r14		
    1f6a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f6e:	cf 4e 1e 00 	mov.b	r14,	30(r15)	;0x001e(r15)
        ptcb->OSTCBBitY      = OSMapTbl[ptcb->OSTCBY];
    1f72:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f76:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1f7a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1f7c:	5e 4f 7e 15 	mov.b	5502(r15),r14	;0x157e(r15)
    1f80:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f84:	cf 4e 20 00 	mov.b	r14,	32(r15)	;0x0020(r15)
        ptcb->OSTCBX         = (INT8U)(prio & 0x07);
    1f88:	5e 44 04 00 	mov.b	4(r4),	r14	;0x0004(r4)
    1f8c:	7e f0 07 00 	and.b	#7,	r14	;#0x0007
    1f90:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f94:	cf 4e 1d 00 	mov.b	r14,	29(r15)	;0x001d(r15)
        ptcb->OSTCBBitX      = OSMapTbl[ptcb->OSTCBX];
    1f98:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f9c:	5f 4f 1d 00 	mov.b	29(r15),r15	;0x001d(r15)
    1fa0:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1fa2:	5e 4f 7e 15 	mov.b	5502(r15),r14	;0x157e(r15)
    1fa6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1faa:	cf 4e 1f 00 	mov.b	r14,	31(r15)	;0x001f(r15)

#if OS_EVENT_EN
        ptcb->OSTCBEventPtr  = (OS_EVENT *)0;              /* Task is not pending on an event          */
    1fae:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fb2:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
    1fb6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fba:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
    1fbe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fc2:	8f 43 22 00 	mov	#0,	34(r15)	;r3 As==00, 0x0022(r15)
    1fc6:	8f 43 24 00 	mov	#0,	36(r15)	;r3 As==00, 0x0024(r15)
        ptcb->OSTCBCyclesStart = 0L;
    1fca:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fce:	8f 43 2a 00 	mov	#0,	42(r15)	;r3 As==00, 0x002a(r15)
    1fd2:	8f 43 2c 00 	mov	#0,	44(r15)	;r3 As==00, 0x002c(r15)
        ptcb->OSTCBCyclesTot   = 0L;
    1fd6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fda:	8f 43 26 00 	mov	#0,	38(r15)	;r3 As==00, 0x0026(r15)
    1fde:	8f 43 28 00 	mov	#0,	40(r15)	;r3 As==00, 0x0028(r15)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
    1fe2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fe6:	8f 43 2e 00 	mov	#0,	46(r15)	;r3 As==00, 0x002e(r15)
        ptcb->OSTCBStkUsed     = 0L;
    1fea:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fee:	8f 43 30 00 	mov	#0,	48(r15)	;r3 As==00, 0x0030(r15)
    1ff2:	8f 43 32 00 	mov	#0,	50(r15)	;r3 As==00, 0x0032(r15)
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif

#if OS_VERSION >= 204
        OSTCBInitHook(ptcb);
    1ff6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ffa:	b0 12 66 15 	call	#0x1566	
#endif

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
    1ffe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2002:	b0 12 4e 14 	call	#0x144e	
        
        OS_ENTER_CRITICAL();
    2006:	b0 12 34 14 	call	#0x1434	
    200a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        OSTCBPrioTbl[prio] = ptcb;
    200e:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    2012:	0f 5f       	rla	r15		
    2014:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    2018:	9f 44 02 00 	mov	2(r4),	0(r15)	;0x0002(r4), 0x0000(r15)
    201c:	00 00 
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
    201e:	1e 42 28 03 	mov	&0x0328,r14	
    2022:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2026:	8f 4e 0e 00 	mov	r14,	14(r15)	;0x000e(r15)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
    202a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    202e:	8f 43 10 00 	mov	#0,	16(r15)	;r3 As==00, 0x0010(r15)
        if (OSTCBList != (OS_TCB *)0) {
    2032:	1f 42 28 03 	mov	&0x0328,r15	
    2036:	0f 93       	tst	r15		
    2038:	05 24       	jz	$+12     	;abs 0x2044
            OSTCBList->OSTCBPrev = ptcb;
    203a:	1f 42 28 03 	mov	&0x0328,r15	
    203e:	9f 44 02 00 	mov	2(r4),	16(r15)	;0x0002(r4), 0x0010(r15)
    2042:	10 00 
        }
        OSTCBList               = ptcb;
    2044:	92 44 02 00 	mov	2(r4),	&0x0328	;0x0002(r4)
    2048:	28 03 
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
    204a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    204e:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    2052:	5f 42 7e 03 	mov.b	&0x037e,r15	
    2056:	4f de       	bis.b	r14,	r15	
    2058:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    205c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2060:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    2064:	4d 4f       	mov.b	r15,	r13	
    2066:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    206a:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    206e:	7f f3       	and.b	#-1,	r15	;r3 As==11
    2070:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    2074:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2078:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    207c:	4f de       	bis.b	r14,	r15	
    207e:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
    2082:	5f 42 32 03 	mov.b	&0x0332,r15	
    2086:	5f 53       	inc.b	r15		
    2088:	c2 4f 32 03 	mov.b	r15,	&0x0332	
        OS_EXIT_CRITICAL();
    208c:	2f 44       	mov	@r4,	r15	
    208e:	b0 12 3a 14 	call	#0x143a	
        return (OS_NO_ERR);
    2092:	4f 43       	clr.b	r15		
    2094:	05 3c       	jmp	$+12     	;abs 0x20a0
    }
    OS_EXIT_CRITICAL();
    2096:	2f 44       	mov	@r4,	r15	
    2098:	b0 12 3a 14 	call	#0x143a	
    return (OS_NO_MORE_TCB);
    209c:	7f 40 46 00 	mov.b	#70,	r15	;#0x0046
}
    20a0:	31 50 0c 00 	add	#12,	r1	;#0x000c
    20a4:	34 41       	pop	r4		
    20a6:	30 41       	ret			

000020a8 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *err)
{
    20a8:	04 12       	push	r4		
    20aa:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    20ae:	04 41       	mov	r1,	r4	
    20b0:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    20b4:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    20b8:	c4 4d 0a 00 	mov.b	r13,	10(r4)	;0x000a(r4)
    20bc:	84 4c 0c 00 	mov	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    20c0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
    20c4:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    20c8:	6f 4f       	mov.b	@r15,	r15	
    20ca:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    20ce:	06 24       	jz	$+14     	;abs 0x20dc
        *err = OS_ERR_EVENT_TYPE;
    20d0:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    20d4:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    20d8:	0f 43       	clr	r15		
    20da:	77 3c       	jmp	$+240    	;abs 0x21ca
    }
    if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
    20dc:	5f 44 0a 00 	mov.b	10(r4),	r15	;0x000a(r4)
    20e0:	4f 93       	tst.b	r15		
    20e2:	06 34       	jge	$+14     	;abs 0x20f0
        wait_type &= ~OS_FLAG_CONSUME;
    20e4:	f4 f0 7f 00 	and.b	#127,	10(r4)	;#0x007f, 0x000a(r4)
    20e8:	0a 00 
        consume    = TRUE;
    20ea:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    20ee:	02 3c       	jmp	$+6      	;abs 0x20f4
    } else {
        consume    = FALSE;
    20f0:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    }
/*$PAGE*/
    *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwise.  */
    20f4:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    20f8:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OS_ENTER_CRITICAL();
    20fc:	b0 12 34 14 	call	#0x1434	
    2100:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (wait_type) {
    2104:	5f 44 0a 00 	mov.b	10(r4),	r15	;0x000a(r4)
    2108:	2f 93       	cmp	#2,	r15	;r3 As==10
    210a:	04 24       	jz	$+10     	;abs 0x2114
    210c:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    2110:	29 24       	jz	$+84     	;abs 0x2164
    2112:	4f 3c       	jmp	$+160    	;abs 0x21b2
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    2114:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2118:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    211c:	0e 4f       	mov	r15,	r14	
    211e:	1e f4 08 00 	and	8(r4),	r14	;0x0008(r4)
    2122:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    2126:	94 94 08 00 	cmp	8(r4),	4(r4)	;0x0008(r4), 0x0004(r4)
    212a:	04 00 
    212c:	10 20       	jnz	$+34     	;abs 0x214e
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    212e:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2132:	13 20       	jnz	$+40     	;abs 0x215a
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    2134:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2138:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    213c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2140:	3f e3       	inv	r15		
    2142:	0e ff       	and	r15,	r14	
    2144:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2148:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    214c:	07 3c       	jmp	$+16     	;abs 0x215c
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
    214e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2152:	ff 40 98 ff 	mov.b	#-104,	0(r15)	;#0xff98, 0x0000(r15)
    2156:	00 00 
    2158:	01 3c       	jmp	$+4      	;abs 0x215c
    switch (wait_type) {
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    215a:	03 43       	nop			
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
    215c:	2f 44       	mov	@r4,	r15	
    215e:	b0 12 3a 14 	call	#0x143a	
    2162:	31 3c       	jmp	$+100    	;abs 0x21c6
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    2164:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2168:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    216c:	0e 4f       	mov	r15,	r14	
    216e:	1e f4 08 00 	and	8(r4),	r14	;0x0008(r4)
    2172:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    2176:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    217a:	10 24       	jz	$+34     	;abs 0x219c
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    217c:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2180:	13 20       	jnz	$+40     	;abs 0x21a8
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    2182:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2186:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    218a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    218e:	3f e3       	inv	r15		
    2190:	0e ff       	and	r15,	r14	
    2192:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2196:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    219a:	07 3c       	jmp	$+16     	;abs 0x21aa
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
    219c:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    21a0:	ff 40 98 ff 	mov.b	#-104,	0(r15)	;#0xff98, 0x0000(r15)
    21a4:	00 00 
    21a6:	01 3c       	jmp	$+4      	;abs 0x21aa

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    21a8:	03 43       	nop			
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
    21aa:	2f 44       	mov	@r4,	r15	
    21ac:	b0 12 3a 14 	call	#0x143a	
    21b0:	0a 3c       	jmp	$+22     	;abs 0x21c6
             OS_EXIT_CRITICAL();
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
    21b2:	2f 44       	mov	@r4,	r15	
    21b4:	b0 12 3a 14 	call	#0x143a	
             flags_rdy = (OS_FLAGS)0;
    21b8:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
             *err      = OS_FLAG_ERR_WAIT_TYPE;
    21bc:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    21c0:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    21c4:	00 00 
             break;
    }
    return (flags_rdy);
    21c6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    21ca:	31 50 0e 00 	add	#14,	r1	;#0x000e
    21ce:	34 41       	pop	r4		
    21d0:	30 41       	ret			

000021d2 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *err)
{
    21d2:	04 12       	push	r4		
    21d4:	31 82       	sub	#8,	r1	;r2 As==11
    21d6:	04 41       	mov	r1,	r4	
    21d8:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    21dc:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr;



    cpu_sr = 0;                                     /* Prevent compiler warning                        */
    21e0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
    21e4:	5f 42 86 03 	mov.b	&0x0386,r15	
    21e8:	4f 93       	tst.b	r15		
    21ea:	07 24       	jz	$+16     	;abs 0x21fa
        *err = OS_ERR_CREATE_ISR;                   /* ... can't CREATE from an ISR                    */
    21ec:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    21f0:	ff 40 8d ff 	mov.b	#-115,	0(r15)	;#0xff8d, 0x0000(r15)
    21f4:	00 00 
        return ((OS_FLAG_GRP *)0);
    21f6:	0f 43       	clr	r15		
    21f8:	30 3c       	jmp	$+98     	;abs 0x225a
    }
    OS_ENTER_CRITICAL();
    21fa:	b0 12 34 14 	call	#0x1434	
    21fe:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
    2202:	94 42 74 05 	mov	&0x0574,2(r4)	;0x0002(r4)
    2206:	02 00 
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
    2208:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    220c:	1c 24       	jz	$+58     	;abs 0x2246
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
    220e:	1f 42 74 05 	mov	&0x0574,r15	
    2212:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    2216:	82 4f 74 05 	mov	r15,	&0x0574	
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
    221a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    221e:	ff 40 05 00 	mov.b	#5,	0(r15)	;#0x0005, 0x0000(r15)
    2222:	00 00 
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
    2224:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2228:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    222c:	04 00 
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
    222e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2232:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        OS_EXIT_CRITICAL();
    2236:	2f 44       	mov	@r4,	r15	
    2238:	b0 12 3a 14 	call	#0x143a	
        *err                 = OS_NO_ERR;
    223c:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2240:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    2244:	08 3c       	jmp	$+18     	;abs 0x2256
    } else {
        OS_EXIT_CRITICAL();
    2246:	2f 44       	mov	@r4,	r15	
    2248:	b0 12 3a 14 	call	#0x143a	
        *err                 = OS_FLAG_GRP_DEPLETED;
    224c:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2250:	ff 40 9a ff 	mov.b	#-102,	0(r15)	;#0xff9a, 0x0000(r15)
    2254:	00 00 
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
    2256:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    225a:	31 52       	add	#8,	r1	;r2 As==11
    225c:	34 41       	pop	r4		
    225e:	30 41       	ret			

00002260 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *err)
{
    2260:	04 12       	push	r4		
    2262:	31 50 e6 ff 	add	#-26,	r1	;#0xffe6
    2266:	04 41       	mov	r1,	r4	
    2268:	84 4f 12 00 	mov	r15,	18(r4)	;0x0012(r4)
    226c:	84 4e 14 00 	mov	r14,	20(r4)	;0x0014(r4)
    2270:	c4 4d 16 00 	mov.b	r13,	22(r4)	;0x0016(r4)
    2274:	84 4c 18 00 	mov	r12,	24(r4)	;0x0018(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    2278:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
    227c:	5f 42 86 03 	mov.b	&0x0386,r15	
    2280:	4f 93       	tst.b	r15		
    2282:	06 24       	jz	$+14     	;abs 0x2290
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
    2284:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2288:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((OS_FLAGS)0);
    228c:	0f 43       	clr	r15		
    228e:	fd 3c       	jmp	$+508    	;abs 0x248a
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
    2290:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2294:	6f 4f       	mov.b	@r15,	r15	
    2296:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    229a:	06 24       	jz	$+14     	;abs 0x22a8
        *err = OS_ERR_EVENT_TYPE;
    229c:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    22a0:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    22a4:	0f 43       	clr	r15		
    22a6:	f1 3c       	jmp	$+484    	;abs 0x248a
    }
    if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
    22a8:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    22ac:	4f 93       	tst.b	r15		
    22ae:	06 34       	jge	$+14     	;abs 0x22bc
        wait_type &= ~OS_FLAG_CONSUME;
    22b0:	f4 f0 7f 00 	and.b	#127,	22(r4)	;#0x007f, 0x0016(r4)
    22b4:	16 00 
        consume    = TRUE;
    22b6:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    22ba:	02 3c       	jmp	$+6      	;abs 0x22c0
    } else {
        consume    = FALSE;
    22bc:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    22c0:	b0 12 34 14 	call	#0x1434	
    22c4:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (wait_type) {
    22c8:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    22cc:	2f 93       	cmp	#2,	r15	;r3 As==10
    22ce:	04 24       	jz	$+10     	;abs 0x22d8
    22d0:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    22d4:	3e 24       	jz	$+126    	;abs 0x2352
    22d6:	79 3c       	jmp	$+244    	;abs 0x23ca
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    22d8:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22dc:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    22e0:	0e 4f       	mov	r15,	r14	
    22e2:	1e f4 14 00 	and	20(r4),	r14	;0x0014(r4)
    22e6:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    22ea:	94 94 14 00 	cmp	20(r4),	4(r4)	;0x0014(r4), 0x0004(r4)
    22ee:	04 00 
    22f0:	1e 20       	jnz	$+62     	;abs 0x232e
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    22f2:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    22f6:	0c 20       	jnz	$+26     	;abs 0x2310
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    22f8:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22fc:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2300:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2304:	3f e3       	inv	r15		
    2306:	0e ff       	and	r15,	r14	
    2308:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    230c:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    2310:	1f 42 88 03 	mov	&0x0388,r15	
    2314:	9f 44 04 00 	mov	4(r4),	22(r15)	;0x0004(r4), 0x0016(r15)
    2318:	16 00 
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    231a:	2f 44       	mov	@r4,	r15	
    231c:	b0 12 3a 14 	call	#0x143a	
                 *err                    = OS_NO_ERR;
    2320:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2324:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
                 return (flags_rdy);
    2328:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    232c:	ae 3c       	jmp	$+350    	;abs 0x248a
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    232e:	5c 44 16 00 	mov.b	22(r4),	r12	;0x0016(r4)
    2332:	1d 44 14 00 	mov	20(r4),	r13	;0x0014(r4)
    2336:	0e 44       	mov	r4,	r14	
    2338:	3e 50 06 00 	add	#6,	r14	;#0x0006
    233c:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2340:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    2344:	b0 12 60 26 	call	#0x2660	
    2348:	21 53       	incd	r1		
                 OS_EXIT_CRITICAL();
    234a:	2f 44       	mov	@r4,	r15	
    234c:	b0 12 3a 14 	call	#0x143a	
    2350:	49 3c       	jmp	$+148    	;abs 0x23e4
             }
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    2352:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2356:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    235a:	0e 4f       	mov	r15,	r14	
    235c:	1e f4 14 00 	and	20(r4),	r14	;0x0014(r4)
    2360:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    2364:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    2368:	1e 24       	jz	$+62     	;abs 0x23a6
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    236a:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    236e:	0c 20       	jnz	$+26     	;abs 0x2388
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    2370:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2374:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2378:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    237c:	3f e3       	inv	r15		
    237e:	0e ff       	and	r15,	r14	
    2380:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2384:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    2388:	1f 42 88 03 	mov	&0x0388,r15	
    238c:	9f 44 04 00 	mov	4(r4),	22(r15)	;0x0004(r4), 0x0016(r15)
    2390:	16 00 
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    2392:	2f 44       	mov	@r4,	r15	
    2394:	b0 12 3a 14 	call	#0x143a	
                 *err                    = OS_NO_ERR;
    2398:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    239c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
                 return (flags_rdy);
    23a0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    23a4:	72 3c       	jmp	$+230    	;abs 0x248a
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    23a6:	5c 44 16 00 	mov.b	22(r4),	r12	;0x0016(r4)
    23aa:	1d 44 14 00 	mov	20(r4),	r13	;0x0014(r4)
    23ae:	0e 44       	mov	r4,	r14	
    23b0:	3e 50 06 00 	add	#6,	r14	;#0x0006
    23b4:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    23b8:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    23bc:	b0 12 60 26 	call	#0x2660	
    23c0:	21 53       	incd	r1		
                 OS_EXIT_CRITICAL();
    23c2:	2f 44       	mov	@r4,	r15	
    23c4:	b0 12 3a 14 	call	#0x143a	
    23c8:	0d 3c       	jmp	$+28     	;abs 0x23e4
             }
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
    23ca:	2f 44       	mov	@r4,	r15	
    23cc:	b0 12 3a 14 	call	#0x143a	
             flags_rdy = (OS_FLAGS)0;
    23d0:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
             *err      = OS_FLAG_ERR_WAIT_TYPE;
    23d4:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    23d8:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    23dc:	00 00 
             return (flags_rdy);
    23de:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    23e2:	53 3c       	jmp	$+168    	;abs 0x248a
    }
    OS_Sched();                                            /* Find next HPT ready to run               */
    23e4:	b0 12 da 1d 	call	#0x1dda	
    OS_ENTER_CRITICAL();
    23e8:	b0 12 34 14 	call	#0x1434	
    23ec:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {                   /* Have we timed-out?                       */
    23f0:	1f 42 88 03 	mov	&0x0388,r15	
    23f4:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    23f8:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    23fa:	1a 20       	jnz	$+54     	;abs 0x2430
        OSTCBCur->OSTCBPendTO = FALSE;
    23fc:	1f 42 88 03 	mov	&0x0388,r15	
    2400:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
        OS_FlagUnlink(&node);
    2404:	0f 44       	mov	r4,	r15	
    2406:	3f 50 06 00 	add	#6,	r15	;#0x0006
    240a:	b0 12 6c 28 	call	#0x286c	
        OSTCBCur->OSTCBStat   = OS_STAT_RDY;               /* Yes, make task ready-to-run              */
    240e:	1f 42 88 03 	mov	&0x0388,r15	
    2412:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
        OS_EXIT_CRITICAL();
    2416:	2f 44       	mov	@r4,	r15	
    2418:	b0 12 3a 14 	call	#0x143a	
        flags_rdy             = (OS_FLAGS)0;
    241c:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
        *err                  = OS_TIMEOUT;                /* Indicate that we timed-out waiting       */
    2420:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2424:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    2428:	00 00 
        return (flags_rdy);
    242a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    242e:	2d 3c       	jmp	$+92     	;abs 0x248a
    } 
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
    2430:	1f 42 88 03 	mov	&0x0388,r15	
    2434:	94 4f 16 00 	mov	22(r15),4(r4)	;0x0016(r15), 0x0004(r4)
    2438:	04 00 
    if (consume == TRUE) {                                 /* See if we need to consume the flags      */
    243a:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    243e:	1c 20       	jnz	$+58     	;abs 0x2478
        switch (wait_type) {
    2440:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    2444:	2f 83       	decd	r15		
    2446:	2f 93       	cmp	#2,	r15	;r3 As==10
    2448:	0d 2c       	jc	$+28     	;abs 0x2464
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
    244a:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    244e:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2452:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2456:	3f e3       	inv	r15		
    2458:	0e ff       	and	r15,	r14	
    245a:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    245e:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    2462:	0a 3c       	jmp	$+22     	;abs 0x2478
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
    2464:	2f 44       	mov	@r4,	r15	
    2466:	b0 12 3a 14 	call	#0x143a	
                 *err = OS_FLAG_ERR_WAIT_TYPE;
    246a:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    246e:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    2472:	00 00 
                 return ((OS_FLAGS)0);
    2474:	0f 43       	clr	r15		
    2476:	09 3c       	jmp	$+20     	;abs 0x248a
        }
    }
    OS_EXIT_CRITICAL();
    2478:	2f 44       	mov	@r4,	r15	
    247a:	b0 12 3a 14 	call	#0x143a	
    *err = OS_NO_ERR;                                      /* Event(s) must have occurred              */
    247e:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2482:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (flags_rdy);
    2486:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    248a:	31 50 1a 00 	add	#26,	r1	;#0x001a
    248e:	34 41       	pop	r4		
    2490:	30 41       	ret			

00002492 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
    2492:	04 12       	push	r4		
    2494:	21 82       	sub	#4,	r1	;r2 As==10
    2496:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    2498:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    249c:	b0 12 34 14 	call	#0x1434	
    24a0:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    flags = OSTCBCur->OSTCBFlagsRdy;
    24a4:	1f 42 88 03 	mov	&0x0388,r15	
    24a8:	94 4f 16 00 	mov	22(r15),2(r4)	;0x0016(r15), 0x0002(r4)
    24ac:	02 00 
    OS_EXIT_CRITICAL();
    24ae:	2f 44       	mov	@r4,	r15	
    24b0:	b0 12 3a 14 	call	#0x143a	
    return (flags);
    24b4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    24b8:	21 52       	add	#4,	r1	;r2 As==10
    24ba:	34 41       	pop	r4		
    24bc:	30 41       	ret			

000024be <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *err)
{
    24be:	04 12       	push	r4		
    24c0:	31 50 ec ff 	add	#-20,	r1	;#0xffec
    24c4:	04 41       	mov	r1,	r4	
    24c6:	84 4f 0c 00 	mov	r15,	12(r4)	;0x000c(r4)
    24ca:	84 4e 0e 00 	mov	r14,	14(r4)	;0x000e(r4)
    24ce:	c4 4d 10 00 	mov.b	r13,	16(r4)	;0x0010(r4)
    24d2:	84 4c 12 00 	mov	r12,	18(r4)	;0x0012(r4)
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                      /* Prevent compiler warning                       */
    24d6:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
    24da:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24de:	6f 4f       	mov.b	@r15,	r15	
    24e0:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    24e4:	06 24       	jz	$+14     	;abs 0x24f2
        *err = OS_ERR_EVENT_TYPE;
    24e6:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    24ea:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    24ee:	0f 43       	clr	r15		
    24f0:	b3 3c       	jmp	$+360    	;abs 0x2658
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    24f2:	b0 12 34 14 	call	#0x1434	
    24f6:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (opt) {
    24fa:	5f 44 10 00 	mov.b	16(r4),	r15	;0x0010(r4)
    24fe:	0f 93       	tst	r15		
    2500:	03 24       	jz	$+8      	;abs 0x2508
    2502:	1f 93       	cmp	#1,	r15	;r3 As==01
    2504:	0e 24       	jz	$+30     	;abs 0x2522
    2506:	19 3c       	jmp	$+52     	;abs 0x253a
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
    2508:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    250c:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2510:	1f 44 0e 00 	mov	14(r4),	r15	;0x000e(r4)
    2514:	3f e3       	inv	r15		
    2516:	0e ff       	and	r15,	r14	
    2518:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    251c:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    2520:	16 3c       	jmp	$+46     	;abs 0x254e
             break;

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
    2522:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2526:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    252a:	0e 4f       	mov	r15,	r14	
    252c:	1e d4 0e 00 	bis	14(r4),	r14	;0x000e(r4)
    2530:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2534:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    2538:	0a 3c       	jmp	$+22     	;abs 0x254e
             break;

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
    253a:	2f 44       	mov	@r4,	r15	
    253c:	b0 12 3a 14 	call	#0x143a	
             *err = OS_FLAG_INVALID_OPT;
    2540:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2544:	ff 40 99 ff 	mov.b	#-103,	0(r15)	;#0xff99, 0x0000(r15)
    2548:	00 00 
             return ((OS_FLAGS)0);
    254a:	0f 43       	clr	r15		
    254c:	85 3c       	jmp	$+268    	;abs 0x2658
    }
    sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
    254e:	c4 43 08 00 	mov.b	#0,	8(r4)	;r3 As==00, 0x0008(r4)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    2552:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2556:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    255a:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)
    255e:	5f 3c       	jmp	$+192    	;abs 0x261e
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
        switch (pnode->OSFlagNodeWaitType) {
    2560:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2564:	5f 4f 0a 00 	mov.b	10(r15),r15	;0x000a(r15)
    2568:	7f f3       	and.b	#-1,	r15	;r3 As==11
    256a:	2f 93       	cmp	#2,	r15	;r3 As==10
    256c:	04 24       	jz	$+10     	;abs 0x2576
    256e:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    2572:	22 24       	jz	$+70     	;abs 0x25b8
    2574:	3e 3c       	jmp	$+126    	;abs 0x25f2
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
    2576:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    257a:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    257e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2582:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2586:	0d 4e       	mov	r14,	r13	
    2588:	0d ff       	and	r15,	r13	
    258a:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
    258e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2592:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2596:	1f 94 04 00 	cmp	4(r4),	r15	;0x0004(r4)
    259a:	35 20       	jnz	$+108    	;abs 0x2606
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    259c:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    25a0:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    25a4:	b0 12 c4 27 	call	#0x27c4	
    25a8:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
                     if (rdy == TRUE) {                     
    25ac:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    25b0:	2c 20       	jnz	$+90     	;abs 0x260a
                         sched = TRUE;                        /* When done we will reschedule          */
    25b2:	d4 43 08 00 	mov.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    25b6:	2e 3c       	jmp	$+94     	;abs 0x2614
                     }
                 }
                 break;

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
    25b8:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    25bc:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    25c0:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    25c4:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    25c8:	0d 4e       	mov	r14,	r13	
    25ca:	0d ff       	and	r15,	r13	
    25cc:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
                 if (flags_rdy != (OS_FLAGS)0) {
    25d0:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    25d4:	1c 24       	jz	$+58     	;abs 0x260e
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    25d6:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    25da:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    25de:	b0 12 c4 27 	call	#0x27c4	
    25e2:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
                     if (rdy == TRUE) {                      
    25e6:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    25ea:	13 20       	jnz	$+40     	;abs 0x2612
                         sched = TRUE;                        /* When done we will reschedule          */
    25ec:	d4 43 08 00 	mov.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    25f0:	11 3c       	jmp	$+36     	;abs 0x2614
                     }
                 }
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
    25f2:	2f 44       	mov	@r4,	r15	
    25f4:	b0 12 3a 14 	call	#0x143a	
                 *err = OS_FLAG_ERR_WAIT_TYPE;
    25f8:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    25fc:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    2600:	00 00 
                 return ((OS_FLAGS)0);
    2602:	0f 43       	clr	r15		
    2604:	29 3c       	jmp	$+84     	;abs 0x2658
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                     
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
    2606:	03 43       	nop			
    2608:	05 3c       	jmp	$+12     	;abs 0x2614
    260a:	03 43       	nop			
    260c:	03 3c       	jmp	$+8      	;abs 0x2614
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                      
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
    260e:	03 43       	nop			
    2610:	01 3c       	jmp	$+4      	;abs 0x2614
    2612:	03 43       	nop			
            default:
                 OS_EXIT_CRITICAL();
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    2614:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2618:	2f 4f       	mov	@r15,	r15	
    261a:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)
             *err = OS_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
    261e:	84 93 0a 00 	tst	10(r4)		;0x000a(r4)
    2622:	9e 23       	jnz	$-194    	;abs 0x2560
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    2624:	2f 44       	mov	@r4,	r15	
    2626:	b0 12 3a 14 	call	#0x143a	
    if (sched == TRUE) {
    262a:	d4 93 08 00 	cmp.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    262e:	02 20       	jnz	$+6      	;abs 0x2634
        OS_Sched();
    2630:	b0 12 da 1d 	call	#0x1dda	
    }
    OS_ENTER_CRITICAL();
    2634:	b0 12 34 14 	call	#0x1434	
    2638:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    flags_cur = pgrp->OSFlagFlags;
    263c:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2640:	94 4f 04 00 	mov	4(r15),	6(r4)	;0x0004(r15), 0x0006(r4)
    2644:	06 00 
    OS_EXIT_CRITICAL();
    2646:	2f 44       	mov	@r4,	r15	
    2648:	b0 12 3a 14 	call	#0x143a	
    *err      = OS_NO_ERR;
    264c:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2650:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (flags_cur);
    2654:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
}
    2658:	31 50 14 00 	add	#20,	r1	;#0x0014
    265c:	34 41       	pop	r4		
    265e:	30 41       	ret			

00002660 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
    2660:	04 12       	push	r4		
    2662:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    2666:	04 41       	mov	r1,	r4	
    2668:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    266c:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    2670:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
    2674:	c4 4c 0a 00 	mov.b	r12,	10(r4)	;0x000a(r4)
    OS_FLAG_NODE  *pnode_next;
	INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
    2678:	1f 42 88 03 	mov	&0x0388,r15	
    267c:	1e 42 88 03 	mov	&0x0388,r14	
    2680:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    2684:	7e d0 20 00 	bis.b	#32,	r14	;#0x0020
    2688:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO     = FALSE;
    268c:	1f 42 88 03 	mov	&0x0388,r15	
    2690:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
    2694:	1f 42 88 03 	mov	&0x0388,r15	
    2698:	9f 44 10 00 	mov	16(r4),	24(r15)	;0x0010(r4), 0x0018(r15)
    269c:	18 00 
    OSTCBCur->OSTCBEventPtr   = (OS_EVENT *)0;
    269e:	1f 42 88 03 	mov	&0x0388,r15	
    26a2:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
    26a6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    26aa:	9f 44 08 00 	mov	8(r4),	8(r15)	;0x0008(r4), 0x0008(r15)
    26ae:	08 00 
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
    26b0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    26b4:	df 44 0a 00 	mov.b	10(r4),	10(r15)	;0x000a(r4), 0x000a(r15)
    26b8:	0a 00 
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
    26ba:	1e 42 88 03 	mov	&0x0388,r14	
    26be:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    26c2:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
    26c6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    26ca:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    26ce:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    26d2:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    pnode->OSFlagNodePrev     = (void *)0;
    26d6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    26da:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
    26de:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    26e2:	9f 44 04 00 	mov	4(r4),	6(r15)	;0x0004(r4), 0x0006(r15)
    26e6:	06 00 
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    26e8:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    26ec:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    26f0:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
    26f4:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    26f8:	05 24       	jz	$+12     	;abs 0x2704
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
    26fa:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    26fe:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    2702:	02 00 
    }
    pgrp->OSFlagWaitList = (void *)pnode;
    2704:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2708:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    270c:	02 00 
                                                      
    y            =  OSTCBCur->OSTCBY;		 	      /* Suspend current task until flag(s) received   */
    270e:	1f 42 88 03 	mov	&0x0388,r15	
    2712:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    2716:	00 00 
	OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
    2718:	6d 44       	mov.b	@r4,	r13	
    271a:	6f 44       	mov.b	@r4,	r15	
    271c:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    2720:	4e 4f       	mov.b	r15,	r14	
    2722:	1f 42 88 03 	mov	&0x0388,r15	
    2726:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    272a:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    272c:	4f fe       	and.b	r14,	r15	
    272e:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
    if (OSRdyTbl[y] == 0x00) {
    2732:	6f 44       	mov.b	@r4,	r15	
    2734:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    2738:	4f 93       	tst.b	r15		
    273a:	0b 20       	jnz	$+24     	;abs 0x2752
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
    273c:	1f 42 88 03 	mov	&0x0388,r15	
    2740:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    2744:	4e 4f       	mov.b	r15,	r14	
    2746:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    2748:	5f 42 7e 03 	mov.b	&0x037e,r15	
    274c:	4f fe       	and.b	r14,	r15	
    274e:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
    }
}
    2752:	31 50 0c 00 	add	#12,	r1	;#0x000c
    2756:	34 41       	pop	r4		
    2758:	30 41       	ret			

0000275a <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
    275a:	04 12       	push	r4		
    275c:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2760:	04 41       	mov	r1,	r4	
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    2762:	3f 40 14 03 	mov	#788,	r15	;#0x0314
    2766:	3e 40 12 00 	mov	#18,	r14	;#0x0012
    276a:	b0 12 74 1d 	call	#0x1d74	
    pgrp1 = &OSFlagTbl[0];
    276e:	b4 40 14 03 	mov	#788,	2(r4)	;#0x0314, 0x0002(r4)
    2772:	02 00 
    pgrp2 = &OSFlagTbl[1];
    2774:	b4 40 1a 03 	mov	#794,	0(r4)	;#0x031a, 0x0000(r4)
    2778:	00 00 
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
    277a:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    277e:	10 3c       	jmp	$+34     	;abs 0x27a0
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    2780:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2784:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
    2788:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    278c:	af 44 02 00 	mov	@r4,	2(r15)	;0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
    2790:	b4 50 06 00 	add	#6,	2(r4)	;#0x0006, 0x0002(r4)
    2794:	02 00 
        pgrp2++;
    2796:	b4 50 06 00 	add	#6,	0(r4)	;#0x0006, 0x0000(r4)
    279a:	00 00 


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
    279c:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    27a0:	a4 93 04 00 	cmp	#2,	4(r4)	;r3 As==10, 0x0004(r4)
    27a4:	ed 2b       	jnc	$-36     	;abs 0x2780
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    27a6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27aa:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    pgrp1->OSFlagWaitList = (void *)0;
    27ae:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27b2:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
    OSFlagFreeList        = (OS_FLAG_GRP *)&OSFlagTbl[0];
    27b6:	b2 40 14 03 	mov	#788,	&0x0574	;#0x0314
    27ba:	74 05 
#endif
}
    27bc:	31 50 06 00 	add	#6,	r1	;#0x0006
    27c0:	34 41       	pop	r4		
    27c2:	30 41       	ret			

000027c4 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
    27c4:	04 12       	push	r4		
    27c6:	31 82       	sub	#8,	r1	;r2 As==11
    27c8:	04 41       	mov	r1,	r4	
    27ca:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    27ce:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
    27d2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    27d6:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    27da:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    ptcb->OSTCBDly      = 0;
    27de:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27e2:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)
    ptcb->OSTCBFlagsRdy = flags_rdy;
    27e6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27ea:	9f 44 06 00 	mov	6(r4),	22(r15)	;0x0006(r4), 0x0016(r15)
    27ee:	16 00 
    ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
    27f0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27f4:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    27f8:	4e 4f       	mov.b	r15,	r14	
    27fa:	7e f0 df ff 	and.b	#-33,	r14	;#0xffdf
    27fe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2802:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    ptcb->OSTCBPendTO   = FALSE;
    2806:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    280a:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
    280e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2812:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    2816:	4f 93       	tst.b	r15		
    2818:	1f 20       	jnz	$+64     	;abs 0x2858
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
    281a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    281e:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    2822:	5f 42 7e 03 	mov.b	&0x037e,r15	
    2826:	4f de       	bis.b	r14,	r15	
    2828:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    282c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2830:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    2834:	4d 4f       	mov.b	r15,	r13	
    2836:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    283a:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    283e:	7f f3       	and.b	#-1,	r15	;r3 As==11
    2840:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    2844:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2848:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    284c:	4f de       	bis.b	r14,	r15	
    284e:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        sched                   = TRUE;
    2852:	d4 43 00 00 	mov.b	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    2856:	02 3c       	jmp	$+6      	;abs 0x285c
    } else {
        sched                   = FALSE;
    2858:	c4 43 00 00 	mov.b	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    OS_FlagUnlink(pnode);
    285c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2860:	b0 12 6c 28 	call	#0x286c	
    return (sched);
    2864:	6f 44       	mov.b	@r4,	r15	
}
    2866:	31 52       	add	#8,	r1	;r2 As==11
    2868:	34 41       	pop	r4		
    286a:	30 41       	ret			

0000286c <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
    286c:	04 12       	push	r4		
    286e:	31 82       	sub	#8,	r1	;r2 As==11
    2870:	04 41       	mov	r1,	r4	
    2872:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    2876:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    287a:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    287e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    2882:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2886:	2f 4f       	mov	@r15,	r15	
    2888:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
    288c:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2890:	11 20       	jnz	$+36     	;abs 0x28b4
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
    2892:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2896:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    289a:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
    289e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    28a2:	af 44 02 00 	mov	@r4,	2(r15)	;0x0002(r15)
        if (pnode_next != (OS_FLAG_NODE *)0) {
    28a6:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    28aa:	10 24       	jz	$+34     	;abs 0x28cc
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
    28ac:	2f 44       	mov	@r4,	r15	
    28ae:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    28b2:	0d 3c       	jmp	$+28     	;abs 0x28ce
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
    28b4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    28b8:	af 44 00 00 	mov	@r4,	0(r15)	;0x0000(r15)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
    28bc:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    28c0:	06 24       	jz	$+14     	;abs 0x28ce
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
    28c2:	2f 44       	mov	@r4,	r15	
    28c4:	9f 44 02 00 	mov	2(r4),	2(r15)	;0x0002(r4), 0x0002(r15)
    28c8:	02 00 
    28ca:	01 3c       	jmp	$+4      	;abs 0x28ce
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
    28cc:	03 43       	nop			
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
#endif
}
    28ce:	31 52       	add	#8,	r1	;r2 As==11
    28d0:	34 41       	pop	r4		
    28d2:	30 41       	ret			

000028d4 <OSMboxAccept>:
*********************************************************************************************************
*/

#if OS_MBOX_ACCEPT_EN > 0
void  *OSMboxAccept (OS_EVENT *pevent)
{
    28d4:	04 12       	push	r4		
    28d6:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    28da:	04 41       	mov	r1,	r4	
    28dc:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                               /* Allocate storage for CPU status register  */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                           /* Prevent compiler warning                  */
    28e0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
    28e4:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    28e8:	6f 4f       	mov.b	@r15,	r15	
    28ea:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    28ec:	02 24       	jz	$+6      	;abs 0x28f2
        return ((void *)0);
    28ee:	0f 43       	clr	r15		
    28f0:	12 3c       	jmp	$+38     	;abs 0x2916
    }
    OS_ENTER_CRITICAL();
    28f2:	b0 12 34 14 	call	#0x1434	
    28f6:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    msg                = pevent->OSEventPtr;
    28fa:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    28fe:	94 4f 04 00 	mov	4(r15),	2(r4)	;0x0004(r15), 0x0002(r4)
    2902:	02 00 
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
    2904:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2908:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
    OS_EXIT_CRITICAL();
    290c:	2f 44       	mov	@r4,	r15	
    290e:	b0 12 3a 14 	call	#0x143a	
    return (msg);                                         /* Return the message received (or NULL)     */
    2912:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    2916:	31 50 06 00 	add	#6,	r1	;#0x0006
    291a:	34 41       	pop	r4		
    291c:	30 41       	ret			

0000291e <OSMboxCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSMboxCreate (void *msg)
{
    291e:	04 12       	push	r4		
    2920:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2924:	04 41       	mov	r1,	r4	
    2926:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    292a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    292e:	5f 42 86 03 	mov.b	&0x0386,r15	
    2932:	4f 93       	tst.b	r15		
    2934:	02 24       	jz	$+6      	;abs 0x293a
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    2936:	0f 43       	clr	r15		
    2938:	2a 3c       	jmp	$+86     	;abs 0x298e
    }
    OS_ENTER_CRITICAL();
    293a:	b0 12 34 14 	call	#0x1434	
    293e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
    2942:	94 42 84 03 	mov	&0x0384,2(r4)	;0x0002(r4)
    2946:	02 00 
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
    2948:	1f 42 84 03 	mov	&0x0384,r15	
    294c:	0f 93       	tst	r15		
    294e:	06 24       	jz	$+14     	;abs 0x295c
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    2950:	1f 42 84 03 	mov	&0x0384,r15	
    2954:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2958:	82 4f 84 03 	mov	r15,	&0x0384	
    }
    OS_EXIT_CRITICAL();
    295c:	2f 44       	mov	@r4,	r15	
    295e:	b0 12 3a 14 	call	#0x143a	
    if (pevent != (OS_EVENT *)0) {
    2962:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2966:	11 24       	jz	$+36     	;abs 0x298a
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
    2968:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    296c:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        pevent->OSEventCnt     = 0;
    2970:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2974:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
        pevent->OSEventPtr     = msg;            /* Deposit message in event control block             */
    2978:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    297c:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2980:	04 00 
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);
    2982:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2986:	b0 12 be 1b 	call	#0x1bbe	
    }
    return (pevent);                             /* Return pointer to event control block              */
    298a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    298e:	31 50 06 00 	add	#6,	r1	;#0x0006
    2992:	34 41       	pop	r4		
    2994:	30 41       	ret			

00002996 <OSMboxPend>:
*                            if you didn't pass the proper pointer to the event control block.
*********************************************************************************************************
*/

void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    2996:	04 12       	push	r4		
    2998:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    299c:	04 41       	mov	r1,	r4	
    299e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    29a2:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    29a6:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    29aa:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
    29ae:	5f 42 86 03 	mov.b	&0x0386,r15	
    29b2:	4f 93       	tst.b	r15		
    29b4:	06 24       	jz	$+14     	;abs 0x29c2
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
    29b6:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    29ba:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((void *)0);
    29be:	0f 43       	clr	r15		
    29c0:	72 3c       	jmp	$+230    	;abs 0x2aa6
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    29c2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    29c6:	6f 4f       	mov.b	@r15,	r15	
    29c8:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    29ca:	06 24       	jz	$+14     	;abs 0x29d8
        *err = OS_ERR_EVENT_TYPE;
    29cc:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    29d0:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((void *)0);
    29d4:	0f 43       	clr	r15		
    29d6:	67 3c       	jmp	$+208    	;abs 0x2aa6
    }
    OS_ENTER_CRITICAL();
    29d8:	b0 12 34 14 	call	#0x1434	
    29dc:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    msg = pevent->OSEventPtr;
    29e0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    29e4:	94 4f 04 00 	mov	4(r15),	2(r4)	;0x0004(r15), 0x0002(r4)
    29e8:	02 00 
    if (msg != (void *)0) {                           /* See if there is already a message             */
    29ea:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    29ee:	0e 24       	jz	$+30     	;abs 0x2a0c
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
    29f0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    29f4:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
        OS_EXIT_CRITICAL();
    29f8:	2f 44       	mov	@r4,	r15	
    29fa:	b0 12 3a 14 	call	#0x143a	
        *err = OS_NO_ERR;
    29fe:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2a02:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        return (msg);                                 /* Return the message received (or NULL)         */
    2a06:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2a0a:	4d 3c       	jmp	$+156    	;abs 0x2aa6
    }
    OSTCBCur->OSTCBStat  |= OS_STAT_MBOX;             /* Message not available, task will pend         */
    2a0c:	1f 42 88 03 	mov	&0x0388,r15	
    2a10:	1e 42 88 03 	mov	&0x0388,r14	
    2a14:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    2a18:	6e d3       	bis.b	#2,	r14	;r3 As==10
    2a1a:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO = FALSE;
    2a1e:	1f 42 88 03 	mov	&0x0388,r15	
    2a22:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly    = timeout;                  /* Load timeout in TCB                           */
    2a26:	1f 42 88 03 	mov	&0x0388,r15	
    2a2a:	9f 44 06 00 	mov	6(r4),	24(r15)	;0x0006(r4), 0x0018(r15)
    2a2e:	18 00 
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    2a30:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2a34:	b0 12 7c 1a 	call	#0x1a7c	
    OS_EXIT_CRITICAL();
    2a38:	2f 44       	mov	@r4,	r15	
    2a3a:	b0 12 3a 14 	call	#0x143a	
    OS_Sched();                                       /* Find next highest priority task ready to run  */
    2a3e:	b0 12 da 1d 	call	#0x1dda	
    OS_ENTER_CRITICAL();
    2a42:	b0 12 34 14 	call	#0x1434	
    2a46:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we were given the message              */
    2a4a:	1f 42 88 03 	mov	&0x0388,r15	
    2a4e:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    2a52:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2a54:	0e 20       	jnz	$+30     	;abs 0x2a72
        OS_EventTO(pevent);                           /* Timed out, Make task ready                    */
    2a56:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2a5a:	b0 12 2c 1b 	call	#0x1b2c	
        OS_EXIT_CRITICAL();
    2a5e:	2f 44       	mov	@r4,	r15	
    2a60:	b0 12 3a 14 	call	#0x143a	
        *err = OS_TIMEOUT;                            /* Indicate that a timeout occured               */
    2a64:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2a68:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    2a6c:	00 00 
        return ((void *)0);                           /* Return a NULL message                         */
    2a6e:	0f 43       	clr	r15		
    2a70:	1a 3c       	jmp	$+54     	;abs 0x2aa6
    }
    msg                     = OSTCBCur->OSTCBMsg;
    2a72:	1f 42 88 03 	mov	&0x0388,r15	
    2a76:	94 4f 14 00 	mov	20(r15),2(r4)	;0x0014(r15), 0x0002(r4)
    2a7a:	02 00 
    OSTCBCur->OSTCBMsg      = (void *)0;              /* Yes, clear message received                   */
    2a7c:	1f 42 88 03 	mov	&0x0388,r15	
    2a80:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    2a84:	1f 42 88 03 	mov	&0x0388,r15	
    2a88:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;          /* No longer waiting for event                   */
    2a8c:	1f 42 88 03 	mov	&0x0388,r15	
    2a90:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    2a94:	2f 44       	mov	@r4,	r15	
    2a96:	b0 12 3a 14 	call	#0x143a	
    *err                    = OS_NO_ERR;
    2a9a:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2a9e:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (msg);                                     /* Return the message received                   */
    2aa2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    2aa6:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2aaa:	34 41       	pop	r4		
    2aac:	30 41       	ret			

00002aae <OSMboxPost>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_EN > 0
INT8U  OSMboxPost (OS_EVENT *pevent, void *msg)
{
    2aae:	04 12       	push	r4		
    2ab0:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2ab4:	04 41       	mov	r1,	r4	
    2ab6:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    2aba:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
    

    
    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2abe:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    2ac2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ac6:	6f 4f       	mov.b	@r15,	r15	
    2ac8:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2aca:	02 24       	jz	$+6      	;abs 0x2ad0
        return (OS_ERR_EVENT_TYPE);
    2acc:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2ace:	2d 3c       	jmp	$+92     	;abs 0x2b2a
    }
    OS_ENTER_CRITICAL();
    2ad0:	b0 12 34 14 	call	#0x1434	
    2ad4:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                     /* See if any task pending on mailbox        */
    2ad8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2adc:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2ae0:	4f 93       	tst.b	r15		
    2ae2:	0e 24       	jz	$+30     	;abs 0x2b00
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX); /* Ready HPT waiting on event                */
    2ae4:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2ae8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2aec:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2aee:	b0 12 3a 19 	call	#0x193a	
        OS_EXIT_CRITICAL();
    2af2:	2f 44       	mov	@r4,	r15	
    2af4:	b0 12 3a 14 	call	#0x143a	
        OS_Sched();                                   /* Find highest priority task ready to run       */
    2af8:	b0 12 da 1d 	call	#0x1dda	
        return (OS_NO_ERR);
    2afc:	4f 43       	clr.b	r15		
    2afe:	15 3c       	jmp	$+44     	;abs 0x2b2a
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
    2b00:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b04:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2b08:	0f 93       	tst	r15		
    2b0a:	06 24       	jz	$+14     	;abs 0x2b18
        OS_EXIT_CRITICAL();
    2b0c:	2f 44       	mov	@r4,	r15	
    2b0e:	b0 12 3a 14 	call	#0x143a	
        return (OS_MBOX_FULL);
    2b12:	7f 40 14 00 	mov.b	#20,	r15	;#0x0014
    2b16:	09 3c       	jmp	$+20     	;abs 0x2b2a
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
    2b18:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b1c:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2b20:	04 00 
    OS_EXIT_CRITICAL();
    2b22:	2f 44       	mov	@r4,	r15	
    2b24:	b0 12 3a 14 	call	#0x143a	
    return (OS_NO_ERR);
    2b28:	4f 43       	clr.b	r15		
}
    2b2a:	31 50 06 00 	add	#6,	r1	;#0x0006
    2b2e:	34 41       	pop	r4		
    2b30:	30 41       	ret			

00002b32 <OSMboxPostOpt>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_OPT_EN > 0
INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
    2b32:	04 12       	push	r4		
    2b34:	31 82       	sub	#8,	r1	;r2 As==11
    2b36:	04 41       	mov	r1,	r4	
    2b38:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    2b3c:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    2b40:	c4 4d 06 00 	mov.b	r13,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2b44:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    2b48:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b4c:	6f 4f       	mov.b	@r15,	r15	
    2b4e:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2b50:	02 24       	jz	$+6      	;abs 0x2b56
        return (OS_ERR_EVENT_TYPE);
    2b52:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2b54:	41 3c       	jmp	$+132    	;abs 0x2bd8
    }
    OS_ENTER_CRITICAL();
    2b56:	b0 12 34 14 	call	#0x1434	
    2b5a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on mailbox            */
    2b5e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b62:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2b66:	4f 93       	tst.b	r15		
    2b68:	22 24       	jz	$+70     	;abs 0x2bae
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
    2b6a:	5f 44 06 00 	mov.b	6(r4),	r15	;0x0006(r4)
    2b6e:	1f f3       	and	#1,	r15	;r3 As==01
    2b70:	4f 93       	tst.b	r15		
    2b72:	0f 24       	jz	$+32     	;abs 0x2b92
    2b74:	07 3c       	jmp	$+16     	;abs 0x2b84
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on mailbox     */           
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);    
    2b76:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2b7a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b7e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2b80:	b0 12 3a 19 	call	#0x193a	
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on mailbox            */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on mailbox     */           
    2b84:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b88:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2b8c:	4f 93       	tst.b	r15		
    2b8e:	f3 23       	jnz	$-24     	;abs 0x2b76
    2b90:	07 3c       	jmp	$+16     	;abs 0x2ba0
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);    
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);  /* No,  Post to HPT waiting on mbox     */
    2b92:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2b96:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b9a:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2b9c:	b0 12 3a 19 	call	#0x193a	
        }
        OS_EXIT_CRITICAL();
    2ba0:	2f 44       	mov	@r4,	r15	
    2ba2:	b0 12 3a 14 	call	#0x143a	
        OS_Sched();                                            /* Find HPT ready to run                */
    2ba6:	b0 12 da 1d 	call	#0x1dda	
        return (OS_NO_ERR);
    2baa:	4f 43       	clr.b	r15		
    2bac:	15 3c       	jmp	$+44     	;abs 0x2bd8
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
    2bae:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bb2:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2bb6:	0f 93       	tst	r15		
    2bb8:	06 24       	jz	$+14     	;abs 0x2bc6
        OS_EXIT_CRITICAL();
    2bba:	2f 44       	mov	@r4,	r15	
    2bbc:	b0 12 3a 14 	call	#0x143a	
        return (OS_MBOX_FULL);
    2bc0:	7f 40 14 00 	mov.b	#20,	r15	;#0x0014
    2bc4:	09 3c       	jmp	$+20     	;abs 0x2bd8
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
    2bc6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bca:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2bce:	04 00 
    OS_EXIT_CRITICAL();
    2bd0:	2f 44       	mov	@r4,	r15	
    2bd2:	b0 12 3a 14 	call	#0x143a	
    return (OS_NO_ERR);
    2bd6:	4f 43       	clr.b	r15		
}
    2bd8:	31 52       	add	#8,	r1	;r2 As==11
    2bda:	34 41       	pop	r4		
    2bdc:	30 41       	ret			

00002bde <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *err)
{
    2bde:	04 12       	push	r4		
    2be0:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    2be4:	04 41       	mov	r1,	r4	
    2be6:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2bea:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2bee:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
    2bf2:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2bf6:	6f 4f       	mov.b	@r15,	r15	
    2bf8:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    2bfa:	06 24       	jz	$+14     	;abs 0x2c08
        *err = OS_ERR_EVENT_TYPE;
    2bfc:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2c00:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((void *)0);
    2c04:	0f 43       	clr	r15		
    2c06:	49 3c       	jmp	$+148    	;abs 0x2c9a
    }
    OS_ENTER_CRITICAL();
    2c08:	b0 12 34 14 	call	#0x1434	
    2c0c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    2c10:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2c14:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2c18:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
    2c1c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c20:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2c24:	0f 93       	tst	r15		
    2c26:	2d 24       	jz	$+92     	;abs 0x2c82
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
    2c28:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c2c:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2c30:	a4 4f 04 00 	mov	@r15,	4(r4)	;0x0004(r4)
    2c34:	0e 4f       	mov	r15,	r14	
    2c36:	2e 53       	incd	r14		
    2c38:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c3c:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
    2c40:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c44:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2c48:	0e 4f       	mov	r15,	r14	
    2c4a:	3e 53       	add	#-1,	r14	;r3 As==11
    2c4c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c50:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
    2c54:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c58:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    2c5c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c60:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2c64:	0e 9f       	cmp	r15,	r14	
    2c66:	08 20       	jnz	$+18     	;abs 0x2c78
            pq->OSQOut = pq->OSQStart;
    2c68:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c6c:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2c70:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c74:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        *err = OS_NO_ERR;
    2c78:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2c7c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    2c80:	07 3c       	jmp	$+16     	;abs 0x2c90
    } else {
        *err = OS_Q_EMPTY;
    2c82:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2c86:	ff 40 1f 00 	mov.b	#31,	0(r15)	;#0x001f, 0x0000(r15)
    2c8a:	00 00 
        msg  = (void *)0;                        /* Queue is empty                                     */
    2c8c:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    }
    OS_EXIT_CRITICAL();
    2c90:	2f 44       	mov	@r4,	r15	
    2c92:	b0 12 3a 14 	call	#0x143a	
    return (msg);                                /* Return message received (or NULL)                  */
    2c96:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2c9a:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2c9e:	34 41       	pop	r4		
    2ca0:	30 41       	ret			

00002ca2 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
    2ca2:	04 12       	push	r4		
    2ca4:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    2ca8:	04 41       	mov	r1,	r4	
    2caa:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2cae:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2cb2:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    2cb6:	5f 42 86 03 	mov.b	&0x0386,r15	
    2cba:	4f 93       	tst.b	r15		
    2cbc:	02 24       	jz	$+6      	;abs 0x2cc2
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    2cbe:	0f 43       	clr	r15		
    2cc0:	6d 3c       	jmp	$+220    	;abs 0x2d9c
    }
    OS_ENTER_CRITICAL();
    2cc2:	b0 12 34 14 	call	#0x1434	
    2cc6:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
    2cca:	94 42 84 03 	mov	&0x0384,4(r4)	;0x0004(r4)
    2cce:	04 00 
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
    2cd0:	1f 42 84 03 	mov	&0x0384,r15	
    2cd4:	0f 93       	tst	r15		
    2cd6:	06 24       	jz	$+14     	;abs 0x2ce4
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    2cd8:	1f 42 84 03 	mov	&0x0384,r15	
    2cdc:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2ce0:	82 4f 84 03 	mov	r15,	&0x0384	
    }
    OS_EXIT_CRITICAL();
    2ce4:	2f 44       	mov	@r4,	r15	
    2ce6:	b0 12 3a 14 	call	#0x143a	
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
    2cea:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    2cee:	54 24       	jz	$+170    	;abs 0x2d98
        OS_ENTER_CRITICAL();
    2cf0:	b0 12 34 14 	call	#0x1434	
    2cf4:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
    2cf8:	94 42 7c 03 	mov	&0x037c,2(r4)	;0x0002(r4)
    2cfc:	02 00 
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
    2cfe:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2d02:	3c 24       	jz	$+122    	;abs 0x2d7c
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
    2d04:	1f 42 7c 03 	mov	&0x037c,r15	
    2d08:	2f 4f       	mov	@r15,	r15	
    2d0a:	82 4f 7c 03 	mov	r15,	&0x037c	
            OS_EXIT_CRITICAL();
    2d0e:	2f 44       	mov	@r4,	r15	
    2d10:	b0 12 3a 14 	call	#0x143a	
            pq->OSQStart           = start;               /*      Initialize the queue                 */
    2d14:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d18:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    2d1c:	02 00 
            pq->OSQEnd             = &start[size];
    2d1e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2d22:	0f 5f       	rla	r15		
    2d24:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    2d28:	0e 5f       	add	r15,	r14	
    2d2a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d2e:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
            pq->OSQIn              = start;
    2d32:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d36:	9f 44 06 00 	mov	6(r4),	6(r15)	;0x0006(r4), 0x0006(r15)
    2d3a:	06 00 
            pq->OSQOut             = start;
    2d3c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d40:	9f 44 06 00 	mov	6(r4),	8(r15)	;0x0006(r4), 0x0008(r15)
    2d44:	08 00 
            pq->OSQSize            = size;
    2d46:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d4a:	9f 44 08 00 	mov	8(r4),	10(r15)	;0x0008(r4), 0x000a(r15)
    2d4e:	0a 00 
            pq->OSQEntries         = 0;
    2d50:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d54:	8f 43 0c 00 	mov	#0,	12(r15)	;r3 As==00, 0x000c(r15)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
    2d58:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d5c:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
            pevent->OSEventCnt     = 0;
    2d60:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d64:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
            pevent->OSEventPtr     = pq;
    2d68:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d6c:	9f 44 02 00 	mov	2(r4),	4(r15)	;0x0002(r4), 0x0004(r15)
    2d70:	04 00 
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
            pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
    2d72:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d76:	b0 12 be 1b 	call	#0x1bbe	
    2d7a:	0e 3c       	jmp	$+30     	;abs 0x2d98
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
    2d7c:	1e 42 84 03 	mov	&0x0384,r14	
    2d80:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d84:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
            OSEventFreeList    = pevent;
    2d88:	92 44 04 00 	mov	4(r4),	&0x0384	;0x0004(r4)
    2d8c:	84 03 
            OS_EXIT_CRITICAL();
    2d8e:	2f 44       	mov	@r4,	r15	
    2d90:	b0 12 3a 14 	call	#0x143a	
            pevent = (OS_EVENT *)0;
    2d94:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
        }
    }
    return (pevent);
    2d98:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2d9c:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2da0:	34 41       	pop	r4		
    2da2:	30 41       	ret			

00002da4 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
    2da4:	04 12       	push	r4		
    2da6:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2daa:	04 41       	mov	r1,	r4	
    2dac:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2db0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
    2db4:	b0 12 34 14 	call	#0x1434	
    2db8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
    2dbc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2dc0:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2dc4:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    pq->OSQIn      = pq->OSQStart;
    2dc8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2dcc:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2dd0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2dd4:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    pq->OSQOut     = pq->OSQStart;
    2dd8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ddc:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2de0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2de4:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    pq->OSQEntries = 0;
    2de8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2dec:	8f 43 0c 00 	mov	#0,	12(r15)	;r3 As==00, 0x000c(r15)
    OS_EXIT_CRITICAL();
    2df0:	2f 44       	mov	@r4,	r15	
    2df2:	b0 12 3a 14 	call	#0x143a	
    return (OS_NO_ERR);
    2df6:	4f 43       	clr.b	r15		
}
    2df8:	31 50 06 00 	add	#6,	r1	;#0x0006
    2dfc:	34 41       	pop	r4		
    2dfe:	30 41       	ret			

00002e00 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    2e00:	04 12       	push	r4		
    2e02:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    2e06:	04 41       	mov	r1,	r4	
    2e08:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2e0c:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    2e10:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2e14:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    2e18:	5f 42 86 03 	mov.b	&0x0386,r15	
    2e1c:	4f 93       	tst.b	r15		
    2e1e:	06 24       	jz	$+14     	;abs 0x2e2c
        *err = OS_ERR_PEND_ISR;                  /* ... can't PEND from an ISR                         */
    2e20:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2e24:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((void *)0);
    2e28:	0f 43       	clr	r15		
    2e2a:	8f 3c       	jmp	$+288    	;abs 0x2f4a
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
        *err = OS_ERR_EVENT_TYPE;
        return ((void *)0);
    }
#endif
    OS_ENTER_CRITICAL();
    2e2c:	b0 12 34 14 	call	#0x1434	
    2e30:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    2e34:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2e38:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2e3c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
    2e40:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e44:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2e48:	0f 93       	tst	r15		
    2e4a:	32 24       	jz	$+102    	;abs 0x2eb0
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
    2e4c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e50:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2e54:	a4 4f 04 00 	mov	@r15,	4(r4)	;0x0004(r4)
    2e58:	0e 4f       	mov	r15,	r14	
    2e5a:	2e 53       	incd	r14		
    2e5c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e60:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
    2e64:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e68:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2e6c:	0e 4f       	mov	r15,	r14	
    2e6e:	3e 53       	add	#-1,	r14	;r3 As==11
    2e70:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e74:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
    2e78:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e7c:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    2e80:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e84:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2e88:	0e 9f       	cmp	r15,	r14	
    2e8a:	08 20       	jnz	$+18     	;abs 0x2e9c
            pq->OSQOut = pq->OSQStart;
    2e8c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e90:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2e94:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e98:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        OS_EXIT_CRITICAL();
    2e9c:	2f 44       	mov	@r4,	r15	
    2e9e:	b0 12 3a 14 	call	#0x143a	
        *err = OS_NO_ERR;
    2ea2:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2ea6:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        return (msg);                            /* Return message received                            */
    2eaa:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2eae:	4d 3c       	jmp	$+156    	;abs 0x2f4a
    }
    OSTCBCur->OSTCBStat   |= OS_STAT_Q;          /* Task will have to pend for a message to be posted  */
    2eb0:	1f 42 88 03 	mov	&0x0388,r15	
    2eb4:	1e 42 88 03 	mov	&0x0388,r14	
    2eb8:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    2ebc:	6e d2       	bis.b	#4,	r14	;r2 As==10
    2ebe:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO  = FALSE;
    2ec2:	1f 42 88 03 	mov	&0x0388,r15	
    2ec6:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly     = timeout;            /* Load timeout into TCB                              */
    2eca:	1f 42 88 03 	mov	&0x0388,r15	
    2ece:	9f 44 08 00 	mov	8(r4),	24(r15)	;0x0008(r4), 0x0018(r15)
    2ed2:	18 00 
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
    2ed4:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2ed8:	b0 12 7c 1a 	call	#0x1a7c	
    OS_EXIT_CRITICAL();
    2edc:	2f 44       	mov	@r4,	r15	
    2ede:	b0 12 3a 14 	call	#0x143a	
    OS_Sched();                                  /* Find next highest priority task ready to run       */
    2ee2:	b0 12 da 1d 	call	#0x1dda	
    OS_ENTER_CRITICAL();
    2ee6:	b0 12 34 14 	call	#0x1434	
    2eea:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {         /* Was task readied because of a timeout?             */
    2eee:	1f 42 88 03 	mov	&0x0388,r15	
    2ef2:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    2ef6:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2ef8:	0e 20       	jnz	$+30     	;abs 0x2f16
        OS_EventTO(pevent);                      /* Yes                                                */
    2efa:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2efe:	b0 12 2c 1b 	call	#0x1b2c	
        OS_EXIT_CRITICAL();
    2f02:	2f 44       	mov	@r4,	r15	
    2f04:	b0 12 3a 14 	call	#0x143a	
        *err = OS_TIMEOUT;                       /*     Indicate a timeout occured                     */
    2f08:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2f0c:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    2f10:	00 00 
        return ((void *)0);                      /*     No message received                            */
    2f12:	0f 43       	clr	r15		
    2f14:	1a 3c       	jmp	$+54     	;abs 0x2f4a
    }
    msg                     = OSTCBCur->OSTCBMsg;/* No, Extract message from TCB (Put there by QPost)  */
    2f16:	1f 42 88 03 	mov	&0x0388,r15	
    2f1a:	94 4f 14 00 	mov	20(r15),4(r4)	;0x0014(r15), 0x0004(r4)
    2f1e:	04 00 
    OSTCBCur->OSTCBMsg      = (void *)0;
    2f20:	1f 42 88 03 	mov	&0x0388,r15	
    2f24:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    2f28:	1f 42 88 03 	mov	&0x0388,r15	
    2f2c:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;     /*     No longer waiting for event                    */
    2f30:	1f 42 88 03 	mov	&0x0388,r15	
    2f34:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    2f38:	2f 44       	mov	@r4,	r15	
    2f3a:	b0 12 3a 14 	call	#0x143a	
    *err                    = OS_NO_ERR;
    2f3e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2f42:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (msg);                                /*     Return message received                        */
    2f46:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2f4a:	31 50 0c 00 	add	#12,	r1	;#0x000c
    2f4e:	34 41       	pop	r4		
    2f50:	30 41       	ret			

00002f52 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *msg)
{
    2f52:	04 12       	push	r4		
    2f54:	31 82       	sub	#8,	r1	;r2 As==11
    2f56:	04 41       	mov	r1,	r4	
    2f58:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2f5c:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    2f60:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
    2f64:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f68:	6f 4f       	mov.b	@r15,	r15	
    2f6a:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    2f6c:	02 24       	jz	$+6      	;abs 0x2f72
        return (OS_ERR_EVENT_TYPE);
    2f6e:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2f70:	5b 3c       	jmp	$+184    	;abs 0x3028
    }
    OS_ENTER_CRITICAL();
    2f72:	b0 12 34 14 	call	#0x1434	
    2f76:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                  /* See if any task pending on queue             */
    2f7a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f7e:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2f82:	4f 93       	tst.b	r15		
    2f84:	0e 24       	jz	$+30     	;abs 0x2fa2
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q); /* Ready highest priority task waiting on event */
    2f86:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    2f8a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f8e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    2f90:	b0 12 3a 19 	call	#0x193a	
        OS_EXIT_CRITICAL();
    2f94:	2f 44       	mov	@r4,	r15	
    2f96:	b0 12 3a 14 	call	#0x143a	
        OS_Sched();                                    /* Find highest priority task ready to run      */
    2f9a:	b0 12 da 1d 	call	#0x1dda	
        return (OS_NO_ERR);
    2f9e:	4f 43       	clr.b	r15		
    2fa0:	43 3c       	jmp	$+136    	;abs 0x3028
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
    2fa2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2fa6:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2faa:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
    2fae:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fb2:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    2fb6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fba:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    2fbe:	0e 9f       	cmp	r15,	r14	
    2fc0:	06 28       	jnc	$+14     	;abs 0x2fce
        OS_EXIT_CRITICAL();
    2fc2:	2f 44       	mov	@r4,	r15	
    2fc4:	b0 12 3a 14 	call	#0x143a	
        return (OS_Q_FULL);
    2fc8:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    2fcc:	2d 3c       	jmp	$+92     	;abs 0x3028
    }
    *pq->OSQIn++ = msg;                                /* Insert message into queue                    */
    2fce:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fd2:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    2fd6:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    2fda:	00 00 
    2fdc:	0e 4f       	mov	r15,	r14	
    2fde:	2e 53       	incd	r14		
    2fe0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fe4:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
    2fe8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fec:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2ff0:	0e 4f       	mov	r15,	r14	
    2ff2:	1e 53       	inc	r14		
    2ff4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ff8:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
    2ffc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3000:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    3004:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3008:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    300c:	0e 9f       	cmp	r15,	r14	
    300e:	08 20       	jnz	$+18     	;abs 0x3020
        pq->OSQIn = pq->OSQStart;
    3010:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3014:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    3018:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    301c:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    }
    OS_EXIT_CRITICAL();
    3020:	2f 44       	mov	@r4,	r15	
    3022:	b0 12 3a 14 	call	#0x143a	
    return (OS_NO_ERR);
    3026:	4f 43       	clr.b	r15		
}
    3028:	31 52       	add	#8,	r1	;r2 As==11
    302a:	34 41       	pop	r4		
    302c:	30 41       	ret			

0000302e <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *msg)
{
    302e:	04 12       	push	r4		
    3030:	31 82       	sub	#8,	r1	;r2 As==11
    3032:	04 41       	mov	r1,	r4	
    3034:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    3038:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    303c:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
    3040:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3044:	6f 4f       	mov.b	@r15,	r15	
    3046:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    3048:	02 24       	jz	$+6      	;abs 0x304e
        return (OS_ERR_EVENT_TYPE);
    304a:	5f 43       	mov.b	#1,	r15	;r3 As==01
    304c:	5f 3c       	jmp	$+192    	;abs 0x310c
    }
    OS_ENTER_CRITICAL();
    304e:	b0 12 34 14 	call	#0x1434	
    3052:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
    3056:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    305a:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    305e:	4f 93       	tst.b	r15		
    3060:	0e 24       	jz	$+30     	;abs 0x307e
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);/* Ready highest priority task waiting on event  */
    3062:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    3066:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    306a:	6d 42       	mov.b	#4,	r13	;r2 As==10
    306c:	b0 12 3a 19 	call	#0x193a	
        OS_EXIT_CRITICAL();
    3070:	2f 44       	mov	@r4,	r15	
    3072:	b0 12 3a 14 	call	#0x143a	
        OS_Sched();                                   /* Find highest priority task ready to run       */
    3076:	b0 12 da 1d 	call	#0x1dda	
        return (OS_NO_ERR);
    307a:	4f 43       	clr.b	r15		
    307c:	47 3c       	jmp	$+144    	;abs 0x310c
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    307e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3082:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    3086:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
    308a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    308e:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    3092:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3096:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    309a:	0e 9f       	cmp	r15,	r14	
    309c:	06 28       	jnc	$+14     	;abs 0x30aa
        OS_EXIT_CRITICAL();
    309e:	2f 44       	mov	@r4,	r15	
    30a0:	b0 12 3a 14 	call	#0x143a	
        return (OS_Q_FULL);
    30a4:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    30a8:	31 3c       	jmp	$+100    	;abs 0x310c
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
    30aa:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30ae:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    30b2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30b6:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    30ba:	0e 9f       	cmp	r15,	r14	
    30bc:	08 20       	jnz	$+18     	;abs 0x30ce
        pq->OSQOut = pq->OSQEnd;
    30be:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30c2:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    30c6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30ca:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    }
    pq->OSQOut--;
    30ce:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30d2:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    30d6:	0e 4f       	mov	r15,	r14	
    30d8:	2e 83       	decd	r14		
    30da:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30de:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    *pq->OSQOut = msg;                                /* Insert message into queue                     */
    30e2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30e6:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    30ea:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    30ee:	00 00 
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    30f0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30f4:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    30f8:	0e 4f       	mov	r15,	r14	
    30fa:	1e 53       	inc	r14		
    30fc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3100:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    OS_EXIT_CRITICAL();
    3104:	2f 44       	mov	@r4,	r15	
    3106:	b0 12 3a 14 	call	#0x143a	
    return (OS_NO_ERR);
    310a:	4f 43       	clr.b	r15		
}
    310c:	31 52       	add	#8,	r1	;r2 As==11
    310e:	34 41       	pop	r4		
    3110:	30 41       	ret			

00003112 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
    3112:	04 12       	push	r4		
    3114:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    3118:	04 41       	mov	r1,	r4	
    311a:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    311e:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    3122:	c4 4d 08 00 	mov.b	r13,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
                     


    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    3126:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
    312a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    312e:	6f 4f       	mov.b	@r15,	r15	
    3130:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    3132:	02 24       	jz	$+6      	;abs 0x3138
        return (OS_ERR_EVENT_TYPE);
    3134:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3136:	97 3c       	jmp	$+304    	;abs 0x3266
    }
    OS_ENTER_CRITICAL();
    3138:	b0 12 34 14 	call	#0x1434	
    313c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
    3140:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3144:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3148:	4f 93       	tst.b	r15		
    314a:	22 24       	jz	$+70     	;abs 0x3190
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
    314c:	5f 44 08 00 	mov.b	8(r4),	r15	;0x0008(r4)
    3150:	1f f3       	and	#1,	r15	;r3 As==01
    3152:	4f 93       	tst.b	r15		
    3154:	0f 24       	jz	$+32     	;abs 0x3174
    3156:	07 3c       	jmp	$+16     	;abs 0x3166
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
    3158:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    315c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3160:	6d 42       	mov.b	#4,	r13	;r2 As==10
    3162:	b0 12 3a 19 	call	#0x193a	
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
    3166:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    316a:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    316e:	4f 93       	tst.b	r15		
    3170:	f3 23       	jnz	$-24     	;abs 0x3158
    3172:	07 3c       	jmp	$+16     	;abs 0x3182
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);  /* No,  Post to HPT waiting on queue       */
    3174:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    3178:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    317c:	6d 42       	mov.b	#4,	r13	;r2 As==10
    317e:	b0 12 3a 19 	call	#0x193a	
        }
        OS_EXIT_CRITICAL();
    3182:	2f 44       	mov	@r4,	r15	
    3184:	b0 12 3a 14 	call	#0x143a	
        OS_Sched();                                         /* Find highest priority task ready to run */
    3188:	b0 12 da 1d 	call	#0x1dda	
        return (OS_NO_ERR);
    318c:	4f 43       	clr.b	r15		
    318e:	6b 3c       	jmp	$+216    	;abs 0x3266
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    3190:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3194:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    3198:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
    319c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31a0:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    31a4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31a8:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    31ac:	0e 9f       	cmp	r15,	r14	
    31ae:	06 28       	jnc	$+14     	;abs 0x31bc
        OS_EXIT_CRITICAL();
    31b0:	2f 44       	mov	@r4,	r15	
    31b2:	b0 12 3a 14 	call	#0x143a	
        return (OS_Q_FULL);
    31b6:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    31ba:	55 3c       	jmp	$+172    	;abs 0x3266
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
    31bc:	5f 44 08 00 	mov.b	8(r4),	r15	;0x0008(r4)
    31c0:	2f f3       	and	#2,	r15	;r3 As==10
    31c2:	24 24       	jz	$+74     	;abs 0x320c
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
    31c4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31c8:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    31cc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31d0:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    31d4:	0e 9f       	cmp	r15,	r14	
    31d6:	08 20       	jnz	$+18     	;abs 0x31e8
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
    31d8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31dc:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    31e0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31e4:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        pq->OSQOut--;
    31e8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31ec:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    31f0:	0e 4f       	mov	r15,	r14	
    31f2:	2e 83       	decd	r14		
    31f4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31f8:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        *pq->OSQOut = msg;                            /*      Insert message into queue                */
    31fc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3200:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    3204:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    3208:	00 00 
    320a:	1f 3c       	jmp	$+64     	;abs 0x324a
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = msg;                           /*      Insert message into queue                */
    320c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3210:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    3214:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    3218:	00 00 
    321a:	0e 4f       	mov	r15,	r14	
    321c:	2e 53       	incd	r14		
    321e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3222:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
    3226:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    322a:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    322e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3232:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    3236:	0e 9f       	cmp	r15,	r14	
    3238:	08 20       	jnz	$+18     	;abs 0x324a
            pq->OSQIn = pq->OSQStart;
    323a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    323e:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    3242:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3246:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    324a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    324e:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    3252:	0e 4f       	mov	r15,	r14	
    3254:	1e 53       	inc	r14		
    3256:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    325a:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    OS_EXIT_CRITICAL();
    325e:	2f 44       	mov	@r4,	r15	
    3260:	b0 12 3a 14 	call	#0x143a	
    return (OS_NO_ERR);
    3264:	4f 43       	clr.b	r15		
}
    3266:	31 50 0a 00 	add	#10,	r1	;#0x000a
    326a:	34 41       	pop	r4		
    326c:	30 41       	ret			

0000326e <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
    326e:	04 12       	push	r4		
    3270:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3274:	04 41       	mov	r1,	r4	
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    3276:	3f 40 34 03 	mov	#820,	r15	;#0x0334
    327a:	3e 40 46 00 	mov	#70,	r14	;#0x0046
    327e:	b0 12 74 1d 	call	#0x1d74	
    pq1 = &OSQTbl[0];
    3282:	b4 40 34 03 	mov	#820,	2(r4)	;#0x0334, 0x0002(r4)
    3286:	02 00 
    pq2 = &OSQTbl[1];
    3288:	b4 40 42 03 	mov	#834,	0(r4)	;#0x0342, 0x0000(r4)
    328c:	00 00 
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
    328e:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    3292:	0c 3c       	jmp	$+26     	;abs 0x32ac
        pq1->OSQPtr = pq2;
    3294:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3298:	af 44 00 00 	mov	@r4,	0(r15)	;0x0000(r15)
        pq1++;
    329c:	b4 50 0e 00 	add	#14,	2(r4)	;#0x000e, 0x0002(r4)
    32a0:	02 00 
        pq2++;
    32a2:	b4 50 0e 00 	add	#14,	0(r4)	;#0x000e, 0x0000(r4)
    32a6:	00 00 


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
    32a8:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    32ac:	a4 92 04 00 	cmp	#4,	4(r4)	;r2 As==10, 0x0004(r4)
    32b0:	f1 2b       	jnc	$-28     	;abs 0x3294
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
    32b2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    32b6:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OSQFreeList = &OSQTbl[0];
    32ba:	b2 40 34 03 	mov	#820,	&0x037c	;#0x0334
    32be:	7c 03 
#endif
}
    32c0:	31 50 06 00 	add	#6,	r1	;#0x0006
    32c4:	34 41       	pop	r4		
    32c6:	30 41       	ret			

000032c8 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
    32c8:	04 12       	push	r4		
    32ca:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    32ce:	04 41       	mov	r1,	r4	
    32d0:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    32d4:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
    32d8:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    32dc:	6f 4f       	mov.b	@r15,	r15	
    32de:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    32e2:	02 24       	jz	$+6      	;abs 0x32e8
        return (0);
    32e4:	0f 43       	clr	r15		
    32e6:	1b 3c       	jmp	$+56     	;abs 0x331e
    }
    OS_ENTER_CRITICAL();
    32e8:	b0 12 34 14 	call	#0x1434	
    32ec:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    cnt = pevent->OSEventCnt;
    32f0:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    32f4:	94 4f 02 00 	mov	2(r15),	2(r4)	;0x0002(r15), 0x0002(r4)
    32f8:	02 00 
    if (cnt > 0) {                                    /* See if resource is available                  */
    32fa:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    32fe:	0a 24       	jz	$+22     	;abs 0x3314
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
    3300:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3304:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    3308:	0e 4f       	mov	r15,	r14	
    330a:	3e 53       	add	#-1,	r14	;r3 As==11
    330c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3310:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
    }
    OS_EXIT_CRITICAL();
    3314:	2f 44       	mov	@r4,	r15	
    3316:	b0 12 3a 14 	call	#0x143a	
    return (cnt);                                     /* Return semaphore count                        */
    331a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    331e:	31 50 06 00 	add	#6,	r1	;#0x0006
    3322:	34 41       	pop	r4		
    3324:	30 41       	ret			

00003326 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
    3326:	04 12       	push	r4		
    3328:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    332c:	04 41       	mov	r1,	r4	
    332e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    3332:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
    3336:	5f 42 86 03 	mov.b	&0x0386,r15	
    333a:	4f 93       	tst.b	r15		
    333c:	02 24       	jz	$+6      	;abs 0x3342
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
    333e:	0f 43       	clr	r15		
    3340:	2b 3c       	jmp	$+88     	;abs 0x3398
    }
    OS_ENTER_CRITICAL();
    3342:	b0 12 34 14 	call	#0x1434	
    3346:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
    334a:	94 42 84 03 	mov	&0x0384,2(r4)	;0x0002(r4)
    334e:	02 00 
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
    3350:	1f 42 84 03 	mov	&0x0384,r15	
    3354:	0f 93       	tst	r15		
    3356:	06 24       	jz	$+14     	;abs 0x3364
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    3358:	1f 42 84 03 	mov	&0x0384,r15	
    335c:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    3360:	82 4f 84 03 	mov	r15,	&0x0384	
    }
    OS_EXIT_CRITICAL();
    3364:	2f 44       	mov	@r4,	r15	
    3366:	b0 12 3a 14 	call	#0x143a	
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
    336a:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    336e:	12 24       	jz	$+38     	;abs 0x3394
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
    3370:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3374:	ff 40 03 00 	mov.b	#3,	0(r15)	;#0x0003, 0x0000(r15)
    3378:	00 00 
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
    337a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    337e:	9f 44 04 00 	mov	4(r4),	2(r15)	;0x0004(r4), 0x0002(r15)
    3382:	02 00 
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
    3384:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3388:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
    338c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3390:	b0 12 be 1b 	call	#0x1bbe	
    }
    return (pevent);
    3394:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    3398:	31 50 06 00 	add	#6,	r1	;#0x0006
    339c:	34 41       	pop	r4		
    339e:	30 41       	ret			

000033a0 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/

void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    33a0:	04 12       	push	r4		
    33a2:	31 82       	sub	#8,	r1	;r2 As==11
    33a4:	04 41       	mov	r1,	r4	
    33a6:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    33aa:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    33ae:	84 4d 06 00 	mov	r13,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    33b2:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
    33b6:	5f 42 86 03 	mov.b	&0x0386,r15	
    33ba:	4f 93       	tst.b	r15		
    33bc:	05 24       	jz	$+12     	;abs 0x33c8
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
    33be:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    33c2:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
    33c6:	64 3c       	jmp	$+202    	;abs 0x3490
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
    33c8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33cc:	6f 4f       	mov.b	@r15,	r15	
    33ce:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    33d2:	05 24       	jz	$+12     	;abs 0x33de
        *err = OS_ERR_EVENT_TYPE;
    33d4:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    33d8:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
    33dc:	59 3c       	jmp	$+180    	;abs 0x3490
        return;
    }
    OS_ENTER_CRITICAL();
    33de:	b0 12 34 14 	call	#0x1434	
    33e2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
    33e6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33ea:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    33ee:	0f 93       	tst	r15		
    33f0:	12 24       	jz	$+38     	;abs 0x3416
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
    33f2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33f6:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    33fa:	0e 4f       	mov	r15,	r14	
    33fc:	3e 53       	add	#-1,	r14	;r3 As==11
    33fe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3402:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
        OS_EXIT_CRITICAL();
    3406:	2f 44       	mov	@r4,	r15	
    3408:	b0 12 3a 14 	call	#0x143a	
        *err = OS_NO_ERR;
    340c:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3410:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    3414:	3d 3c       	jmp	$+124    	;abs 0x3490
        return;
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat   |= OS_STAT_SEM;             /* Resource not available, pend on semaphore     */
    3416:	1f 42 88 03 	mov	&0x0388,r15	
    341a:	1e 42 88 03 	mov	&0x0388,r14	
    341e:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    3422:	5e d3       	bis.b	#1,	r14	;r3 As==01
    3424:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO  = FALSE;
    3428:	1f 42 88 03 	mov	&0x0388,r15	
    342c:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly     = timeout;                 /* Store pend timeout in TCB                     */
    3430:	1f 42 88 03 	mov	&0x0388,r15	
    3434:	9f 44 04 00 	mov	4(r4),	24(r15)	;0x0004(r4), 0x0018(r15)
    3438:	18 00 
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    343a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    343e:	b0 12 7c 1a 	call	#0x1a7c	
    OS_EXIT_CRITICAL();
    3442:	2f 44       	mov	@r4,	r15	
    3444:	b0 12 3a 14 	call	#0x143a	
    OS_Sched();                                       /* Find next highest priority task ready         */
    3448:	b0 12 da 1d 	call	#0x1dda	
    OS_ENTER_CRITICAL();
    344c:	b0 12 34 14 	call	#0x1434	
    3450:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we timedout                            */
    3454:	1f 42 88 03 	mov	&0x0388,r15	
    3458:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    345c:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    345e:	0d 20       	jnz	$+28     	;abs 0x347a
        OS_EventTO(pevent);
    3460:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3464:	b0 12 2c 1b 	call	#0x1b2c	
        OS_EXIT_CRITICAL();
    3468:	2f 44       	mov	@r4,	r15	
    346a:	b0 12 3a 14 	call	#0x143a	
        *err = OS_TIMEOUT;                            /* Indicate that didn't get event within TO      */
    346e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3472:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    3476:	00 00 
    3478:	0b 3c       	jmp	$+24     	;abs 0x3490
        return;
    }
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
    347a:	1f 42 88 03 	mov	&0x0388,r15	
    347e:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    3482:	2f 44       	mov	@r4,	r15	
    3484:	b0 12 3a 14 	call	#0x143a	
    *err = OS_NO_ERR;
    3488:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    348c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
}
    3490:	31 52       	add	#8,	r1	;r2 As==11
    3492:	34 41       	pop	r4		
    3494:	30 41       	ret			

00003496 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
    3496:	04 12       	push	r4		
    3498:	21 82       	sub	#4,	r1	;r2 As==10
    349a:	04 41       	mov	r1,	r4	
    349c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;                               



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    34a0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
    34a4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34a8:	6f 4f       	mov.b	@r15,	r15	
    34aa:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    34ae:	02 24       	jz	$+6      	;abs 0x34b4
        return (OS_ERR_EVENT_TYPE);
    34b0:	5f 43       	mov.b	#1,	r15	;r3 As==01
    34b2:	32 3c       	jmp	$+102    	;abs 0x3518
    }
    OS_ENTER_CRITICAL();
    34b4:	b0 12 34 14 	call	#0x1434	
    34b8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                          /* See if any task waiting for semaphore*/
    34bc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34c0:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    34c4:	4f 93       	tst.b	r15		
    34c6:	0e 24       	jz	$+30     	;abs 0x34e4
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM); /* Ready HPT waiting on event           */
    34c8:	5e 43       	mov.b	#1,	r14	;r3 As==01
    34ca:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34ce:	4d 4e       	mov.b	r14,	r13	
    34d0:	0e 43       	clr	r14		
    34d2:	b0 12 3a 19 	call	#0x193a	
        OS_EXIT_CRITICAL();
    34d6:	2f 44       	mov	@r4,	r15	
    34d8:	b0 12 3a 14 	call	#0x143a	
        OS_Sched();                                            /* Find HPT ready to run                */
    34dc:	b0 12 da 1d 	call	#0x1dda	
        return (OS_NO_ERR);
    34e0:	4f 43       	clr.b	r15		
    34e2:	1a 3c       	jmp	$+54     	;abs 0x3518
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
    34e4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34e8:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    34ec:	3f 93       	cmp	#-1,	r15	;r3 As==11
    34ee:	0f 24       	jz	$+32     	;abs 0x350e
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
    34f0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34f4:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    34f8:	0e 4f       	mov	r15,	r14	
    34fa:	1e 53       	inc	r14		
    34fc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3500:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
        OS_EXIT_CRITICAL();
    3504:	2f 44       	mov	@r4,	r15	
    3506:	b0 12 3a 14 	call	#0x143a	
        return (OS_NO_ERR);
    350a:	4f 43       	clr.b	r15		
    350c:	05 3c       	jmp	$+12     	;abs 0x3518
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    350e:	2f 44       	mov	@r4,	r15	
    3510:	b0 12 3a 14 	call	#0x143a	
    return (OS_SEM_OVF);
    3514:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
}
    3518:	21 52       	add	#4,	r1	;r2 As==10
    351a:	34 41       	pop	r4		
    351c:	30 41       	ret			

0000351e <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
    351e:	04 12       	push	r4		
    3520:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3524:	04 41       	mov	r1,	r4	
    3526:	c4 4f 0c 00 	mov.b	r15,	12(r4)	;0x000c(r4)
    352a:	c4 4e 0d 00 	mov.b	r14,	13(r4)	;0x000d(r4)
#if OS_CRITICAL_METHOD == 3                                     
    OS_CPU_SR    cpu_sr;                                        /* Storage for CPU status register     */



    cpu_sr = 0;                                                 /* Prevent compiler warning            */
    352e:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
	}
    if (newprio >= OS_LOWEST_PRIO) {
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    3532:	b0 12 34 14 	call	#0x1434	
    3536:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already exist */
    353a:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    353e:	0f 5f       	rla	r15		
    3540:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3544:	2f 4f       	mov	@r15,	r15	
    3546:	0f 93       	tst	r15		
    3548:	06 24       	jz	$+14     	;abs 0x3556
        OS_EXIT_CRITICAL();
    354a:	2f 44       	mov	@r4,	r15	
    354c:	b0 12 3a 14 	call	#0x143a	
        return (OS_PRIO_EXIST);
    3550:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
    3554:	01 3d       	jmp	$+516    	;abs 0x3758
    } 
    if (oldprio == OS_PRIO_SELF) {                              /* See if changing self                */
    3556:	f4 93 0c 00 	cmp.b	#-1,	12(r4)	;r3 As==11, 0x000c(r4)
    355a:	05 20       	jnz	$+12     	;abs 0x3566
        oldprio = OSTCBCur->OSTCBPrio;                          /* Yes, get priority                   */
    355c:	1f 42 88 03 	mov	&0x0388,r15	
    3560:	d4 4f 1c 00 	mov.b	28(r15),12(r4)	;0x001c(r15), 0x000c(r4)
    3564:	0c 00 
    }
    ptcb = OSTCBPrioTbl[oldprio];
    3566:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    356a:	0f 5f       	rla	r15		
    356c:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3570:	a4 4f 08 00 	mov	@r15,	8(r4)	;0x0008(r4)
    if (ptcb == (OS_TCB *)0) {                                  /* Does task to change exist?          */
    3574:	84 93 08 00 	tst	8(r4)		;0x0008(r4)
    3578:	06 20       	jnz	$+14     	;abs 0x3586
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
    357a:	2f 44       	mov	@r4,	r15	
    357c:	b0 12 3a 14 	call	#0x143a	
        return (OS_PRIO_ERR);
    3580:	7f 40 29 00 	mov.b	#41,	r15	;#0x0029
    3584:	e9 3c       	jmp	$+468    	;abs 0x3758
    }                                       
    if (ptcb == (OS_TCB *)1) {                                  /* Is task assigned to Mutex           */
    3586:	94 93 08 00 	cmp	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    358a:	06 20       	jnz	$+14     	;abs 0x3598
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
    358c:	2f 44       	mov	@r4,	r15	
    358e:	b0 12 3a 14 	call	#0x143a	
        return (OS_TASK_NOT_EXIST);
    3592:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    3596:	e0 3c       	jmp	$+450    	;abs 0x3758
    }                                       
    y                     = newprio >> 3;                       /* Yes, compute new TCB fields         */
    3598:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    359c:	12 c3       	clrc			
    359e:	4f 10       	rrc.b	r15		
    35a0:	4f 11       	rra.b	r15		
    35a2:	4f 11       	rra.b	r15		
    35a4:	c4 4f 05 00 	mov.b	r15,	5(r4)	;0x0005(r4)
    bity                  = OSMapTbl[y];
    35a8:	5f 44 05 00 	mov.b	5(r4),	r15	;0x0005(r4)
    35ac:	d4 4f 7e 15 	mov.b	5502(r15),3(r4)	;0x157e(r15), 0x0003(r4)
    35b0:	03 00 
    x                     = newprio & 0x07;
    35b2:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    35b6:	7f f0 07 00 	and.b	#7,	r15	;#0x0007
    35ba:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
    bitx                  = OSMapTbl[x];
    35be:	5f 44 06 00 	mov.b	6(r4),	r15	;0x0006(r4)
    35c2:	d4 4f 7e 15 	mov.b	5502(r15),4(r4)	;0x157e(r15), 0x0004(r4)
    35c6:	04 00 
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
    35c8:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    35cc:	0f 5f       	rla	r15		
    35ce:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    35d2:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
    35d6:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    35da:	0f 5f       	rla	r15		
    35dc:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    35e0:	9f 44 08 00 	mov	8(r4),	0(r15)	;0x0008(r4), 0x0000(r15)
    35e4:	00 00 
    y_old                 = ptcb->OSTCBY;
    35e6:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    35ea:	d4 4f 1e 00 	mov.b	30(r15),2(r4)	;0x001e(r15), 0x0002(r4)
    35ee:	02 00 
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0x00) {          /* If task is ready make it not        */
    35f0:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    35f4:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    35f8:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    35fc:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    3600:	4f fe       	and.b	r14,	r15	
    3602:	31 24       	jz	$+100    	;abs 0x3666
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
    3604:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    3608:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    360c:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    3610:	4e 4f       	mov.b	r15,	r14	
    3612:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3616:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    361a:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    361c:	4f fe       	and.b	r14,	r15	
    361e:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        if (OSRdyTbl[y_old] == 0x00) {
    3622:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3626:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    362a:	4f 93       	tst.b	r15		
    362c:	0b 20       	jnz	$+24     	;abs 0x3644
            OSRdyGrp &= ~ptcb->OSTCBBitY;
    362e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3632:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    3636:	4e 4f       	mov.b	r15,	r14	
    3638:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    363a:	5f 42 7e 03 	mov.b	&0x037e,r15	
    363e:	4f fe       	and.b	r14,	r15	
    3640:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        }
        OSRdyGrp    |= bity;                                    /* Make new priority ready to run      */
    3644:	5f 42 7e 03 	mov.b	&0x037e,r15	
    3648:	5f d4 03 00 	bis.b	3(r4),	r15	;0x0003(r4)
    364c:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[y] |= bitx;
    3650:	5e 44 05 00 	mov.b	5(r4),	r14	;0x0005(r4)
    3654:	5f 44 05 00 	mov.b	5(r4),	r15	;0x0005(r4)
    3658:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    365c:	5f d4 04 00 	bis.b	4(r4),	r15	;0x0004(r4)
    3660:	ce 4f 80 03 	mov.b	r15,	896(r14);0x0380(r14)
    3664:	5a 3c       	jmp	$+182    	;abs 0x371a
#if OS_EVENT_EN
    } else {                                                    /* Task was not ready ...              */
        pevent = ptcb->OSTCBEventPtr;
    3666:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    366a:	94 4f 12 00 	mov	18(r15),10(r4)	;0x0012(r15), 0x000a(r4)
    366e:	0a 00 
        if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list     */
    3670:	84 93 0a 00 	tst	10(r4)		;0x000a(r4)
    3674:	52 24       	jz	$+166    	;abs 0x371a
            pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
    3676:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    367a:	5e 44 02 00 	mov.b	2(r4),	r14	;0x0002(r4)
    367e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3682:	0f 5e       	add	r14,	r15	
    3684:	3f 50 06 00 	add	#6,	r15	;#0x0006
    3688:	6f 4f       	mov.b	@r15,	r15	
    368a:	4e 4f       	mov.b	r15,	r14	
    368c:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3690:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    3694:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    3696:	4f fe       	and.b	r14,	r15	
    3698:	4e 4f       	mov.b	r15,	r14	
    369a:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    369e:	0f 5d       	add	r13,	r15	
    36a0:	3f 50 06 00 	add	#6,	r15	;#0x0006
    36a4:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
            if (pevent->OSEventTbl[y_old] == 0) {
    36a8:	5e 44 02 00 	mov.b	2(r4),	r14	;0x0002(r4)
    36ac:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36b0:	0f 5e       	add	r14,	r15	
    36b2:	3f 50 06 00 	add	#6,	r15	;#0x0006
    36b6:	6f 4f       	mov.b	@r15,	r15	
    36b8:	4f 93       	tst.b	r15		
    36ba:	10 20       	jnz	$+34     	;abs 0x36dc
                pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
    36bc:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36c0:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    36c4:	4e 4f       	mov.b	r15,	r14	
    36c6:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36ca:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    36ce:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    36d0:	4f fe       	and.b	r14,	r15	
    36d2:	4e 4f       	mov.b	r15,	r14	
    36d4:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36d8:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
            }
            pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list       */
    36dc:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36e0:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    36e4:	4e 4f       	mov.b	r15,	r14	
    36e6:	5e d4 03 00 	bis.b	3(r4),	r14	;0x0003(r4)
    36ea:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36ee:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
            pevent->OSEventTbl[y] |= bitx;
    36f2:	5d 44 05 00 	mov.b	5(r4),	r13	;0x0005(r4)
    36f6:	5e 44 05 00 	mov.b	5(r4),	r14	;0x0005(r4)
    36fa:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36fe:	0f 5e       	add	r14,	r15	
    3700:	3f 50 06 00 	add	#6,	r15	;#0x0006
    3704:	6f 4f       	mov.b	@r15,	r15	
    3706:	4e 4f       	mov.b	r15,	r14	
    3708:	5e d4 04 00 	bis.b	4(r4),	r14	;0x0004(r4)
    370c:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3710:	0f 5d       	add	r13,	r15	
    3712:	3f 50 06 00 	add	#6,	r15	;#0x0006
    3716:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
        }
#endif
    }
    ptcb->OSTCBPrio = newprio;                                  /* Set new task priority               */
    371a:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    371e:	df 44 0d 00 	mov.b	13(r4),	28(r15)	;0x000d(r4), 0x001c(r15)
    3722:	1c 00 
    ptcb->OSTCBY    = y;
    3724:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3728:	df 44 05 00 	mov.b	5(r4),	30(r15)	;0x0005(r4), 0x001e(r15)
    372c:	1e 00 
    ptcb->OSTCBX    = x;
    372e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3732:	df 44 06 00 	mov.b	6(r4),	29(r15)	;0x0006(r4), 0x001d(r15)
    3736:	1d 00 
    ptcb->OSTCBBitY = bity;
    3738:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    373c:	df 44 03 00 	mov.b	3(r4),	32(r15)	;0x0003(r4), 0x0020(r15)
    3740:	20 00 
    ptcb->OSTCBBitX = bitx;
    3742:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3746:	df 44 04 00 	mov.b	4(r4),	31(r15)	;0x0004(r4), 0x001f(r15)
    374a:	1f 00 
    OS_EXIT_CRITICAL();
    374c:	2f 44       	mov	@r4,	r15	
    374e:	b0 12 3a 14 	call	#0x143a	
    OS_Sched();                                                 /* Run highest priority task ready     */
    3752:	b0 12 da 1d 	call	#0x1dda	
    return (OS_NO_ERR);
    3756:	4f 43       	clr.b	r15		
}
    3758:	31 50 0e 00 	add	#14,	r1	;#0x000e
    375c:	34 41       	pop	r4		
    375e:	30 41       	ret			

00003760 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT8U prio)
{
    3760:	04 12       	push	r4		
    3762:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3766:	04 41       	mov	r1,	r4	
    3768:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    376c:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    3770:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
    3774:	c4 4c 0c 00 	mov.b	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                              /* Prevent compiler warning                               */
    3778:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    377c:	b0 12 34 14 	call	#0x1434	
    3780:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
    3784:	5f 42 86 03 	mov.b	&0x0386,r15	
    3788:	4f 93       	tst.b	r15		
    378a:	06 24       	jz	$+14     	;abs 0x3798
        OS_EXIT_CRITICAL();
    378c:	2f 44       	mov	@r4,	r15	
    378e:	b0 12 3a 14 	call	#0x143a	
        return (OS_ERR_TASK_CREATE_ISR);
    3792:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    3796:	4e 3c       	jmp	$+158    	;abs 0x3834
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
    3798:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    379c:	0f 5f       	rla	r15		
    379e:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    37a2:	2f 4f       	mov	@r15,	r15	
    37a4:	0f 93       	tst	r15		
    37a6:	41 20       	jnz	$+132    	;abs 0x382a
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
    37a8:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    37ac:	0f 5f       	rla	r15		
    37ae:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    37b2:	9f 43 00 00 	mov	#1,	0(r15)	;r3 As==01, 0x0000(r15)
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
    37b6:	2f 44       	mov	@r4,	r15	
    37b8:	b0 12 3a 14 	call	#0x143a	
        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, 0);    /* Initialize the task's stack         */
    37bc:	1d 44 0a 00 	mov	10(r4),	r13	;0x000a(r4)
    37c0:	1e 44 08 00 	mov	8(r4),	r14	;0x0008(r4)
    37c4:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    37c8:	0c 43       	clr	r12		
    37ca:	b0 12 7e 14 	call	#0x147e	
    37ce:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
    37d2:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    37d6:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    37da:	03 12       	push	#0		;r3 As==00
    37dc:	03 12       	push	#0		;r3 As==00
    37de:	03 12       	push	#0		;r3 As==00
    37e0:	03 12       	push	#0		;r3 As==00
    37e2:	0c 43       	clr	r12		
    37e4:	0d 43       	clr	r13		
    37e6:	b0 12 b8 1e 	call	#0x1eb8	
    37ea:	31 52       	add	#8,	r1	;r2 As==11
    37ec:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
        if (err == OS_NO_ERR) {
    37f0:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    37f4:	07 20       	jnz	$+16     	;abs 0x3804
            if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has started */
    37f6:	5f 42 0d 03 	mov.b	&0x030d,r15	
    37fa:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    37fc:	12 20       	jnz	$+38     	;abs 0x3822
                OS_Sched();
    37fe:	b0 12 da 1d 	call	#0x1dda	
    3802:	10 3c       	jmp	$+34     	;abs 0x3824
            }
        } else {
            OS_ENTER_CRITICAL();
    3804:	b0 12 34 14 	call	#0x1434	
    3808:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
    380c:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    3810:	0f 5f       	rla	r15		
    3812:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3816:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
            OS_EXIT_CRITICAL();
    381a:	2f 44       	mov	@r4,	r15	
    381c:	b0 12 3a 14 	call	#0x143a	
    3820:	01 3c       	jmp	$+4      	;abs 0x3824
        OS_EXIT_CRITICAL();
        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, 0);    /* Initialize the task's stack         */
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
        if (err == OS_NO_ERR) {
            if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has started */
                OS_Sched();
    3822:	03 43       	nop			
        } else {
            OS_ENTER_CRITICAL();
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
            OS_EXIT_CRITICAL();
        }
        return (err);
    3824:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3828:	05 3c       	jmp	$+12     	;abs 0x3834
    }
    OS_EXIT_CRITICAL();
    382a:	2f 44       	mov	@r4,	r15	
    382c:	b0 12 3a 14 	call	#0x143a	
    return (OS_PRIO_EXIST);
    3830:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
}
    3834:	31 50 0e 00 	add	#14,	r1	;#0x000e
    3838:	34 41       	pop	r4		
    383a:	30 41       	ret			

0000383c <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
    383c:	0b 12       	push	r11		
    383e:	04 12       	push	r4		
    3840:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3844:	04 41       	mov	r1,	r4	
    3846:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    384a:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    384e:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
    3852:	c4 4c 0c 00 	mov.b	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                              /* Prevent compiler warning                               */
    3856:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    385a:	b0 12 34 14 	call	#0x1434	
    385e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
    3862:	5f 42 86 03 	mov.b	&0x0386,r15	
    3866:	4f 93       	tst.b	r15		
    3868:	06 24       	jz	$+14     	;abs 0x3876
        OS_EXIT_CRITICAL();
    386a:	2f 44       	mov	@r4,	r15	
    386c:	b0 12 3a 14 	call	#0x143a	
        return (OS_ERR_TASK_CREATE_ISR);
    3870:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    3874:	63 3c       	jmp	$+200    	;abs 0x393c
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
    3876:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    387a:	0f 5f       	rla	r15		
    387c:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3880:	2f 4f       	mov	@r15,	r15	
    3882:	0f 93       	tst	r15		
    3884:	56 20       	jnz	$+174    	;abs 0x3932
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
    3886:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    388a:	0f 5f       	rla	r15		
    388c:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3890:	9f 43 00 00 	mov	#1,	0(r15)	;r3 As==01, 0x0000(r15)
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
    3894:	2f 44       	mov	@r4,	r15	
    3896:	b0 12 3a 14 	call	#0x143a	

        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
    389a:	1d 44 1e 00 	mov	30(r4),	r13	;0x001e(r4)
    389e:	1e 44 18 00 	mov	24(r4),	r14	;0x0018(r4)
    38a2:	1f 44 1a 00 	mov	26(r4),	r15	;0x001a(r4)
    38a6:	1b 44 16 00 	mov	22(r4),	r11	;0x0016(r4)
    38aa:	0c 4d       	mov	r13,	r12	
    38ac:	0d 4e       	mov	r14,	r13	
    38ae:	0e 4f       	mov	r15,	r14	
    38b0:	0f 4b       	mov	r11,	r15	
    38b2:	b0 12 5e 3a 	call	#0x3a5e	

        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, opt); /* Initialize the task's stack          */
    38b6:	1c 44 1e 00 	mov	30(r4),	r12	;0x001e(r4)
    38ba:	1d 44 0a 00 	mov	10(r4),	r13	;0x000a(r4)
    38be:	1e 44 08 00 	mov	8(r4),	r14	;0x0008(r4)
    38c2:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    38c6:	b0 12 7e 14 	call	#0x147e	
    38ca:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
    38ce:	1d 44 16 00 	mov	22(r4),	r13	;0x0016(r4)
    38d2:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    38d6:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    38da:	14 12 1e 00 	push	30(r4)		;0x001e(r4)
    38de:	14 12 1c 00 	push	28(r4)		;0x001c(r4)
    38e2:	14 12 1a 00 	push	26(r4)		;0x001a(r4)
    38e6:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    38ea:	1c 44 14 00 	mov	20(r4),	r12	;0x0014(r4)
    38ee:	b0 12 b8 1e 	call	#0x1eb8	
    38f2:	31 52       	add	#8,	r1	;r2 As==11
    38f4:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
        if (err == OS_NO_ERR) {
    38f8:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    38fc:	07 20       	jnz	$+16     	;abs 0x390c
            if (OSRunning == TRUE) {                           /* Find HPT if multitasking has started */
    38fe:	5f 42 0d 03 	mov.b	&0x030d,r15	
    3902:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    3904:	12 20       	jnz	$+38     	;abs 0x392a
                OS_Sched();
    3906:	b0 12 da 1d 	call	#0x1dda	
    390a:	10 3c       	jmp	$+34     	;abs 0x392c
            }
        } else {
            OS_ENTER_CRITICAL();
    390c:	b0 12 34 14 	call	#0x1434	
    3910:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
    3914:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    3918:	0f 5f       	rla	r15		
    391a:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    391e:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
            OS_EXIT_CRITICAL();
    3922:	2f 44       	mov	@r4,	r15	
    3924:	b0 12 3a 14 	call	#0x143a	
    3928:	01 3c       	jmp	$+4      	;abs 0x392c

        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, opt); /* Initialize the task's stack          */
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
        if (err == OS_NO_ERR) {
            if (OSRunning == TRUE) {                           /* Find HPT if multitasking has started */
                OS_Sched();
    392a:	03 43       	nop			
        } else {
            OS_ENTER_CRITICAL();
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
            OS_EXIT_CRITICAL();
        }
        return (err);
    392c:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3930:	05 3c       	jmp	$+12     	;abs 0x393c
    }
    OS_EXIT_CRITICAL();
    3932:	2f 44       	mov	@r4,	r15	
    3934:	b0 12 3a 14 	call	#0x143a	
    return (OS_PRIO_EXIST);
    3938:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
}
    393c:	31 50 0e 00 	add	#14,	r1	;#0x000e
    3940:	34 41       	pop	r4		
    3942:	3b 41       	pop	r11		
    3944:	30 41       	ret			

00003946 <OSTaskStkChk>:
*              OS_TASK_OPT_ERR     if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
    3946:	04 12       	push	r4		
    3948:	31 50 ee ff 	add	#-18,	r1	;#0xffee
    394c:	04 41       	mov	r1,	r4	
    394e:	c4 4f 0e 00 	mov.b	r15,	14(r4)	;0x000e(r4)
    3952:	84 4e 10 00 	mov	r14,	16(r4)	;0x0010(r4)
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    3956:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
        if (prio != OS_PRIO_SELF) {        
            return (OS_PRIO_INVALID);
        }
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
    395a:	1f 44 10 00 	mov	16(r4),	r15	;0x0010(r4)
    395e:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    3962:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    p_stk_data->OSUsed = 0;
    3966:	1f 44 10 00 	mov	16(r4),	r15	;0x0010(r4)
    396a:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
    396e:	8f 43 06 00 	mov	#0,	6(r15)	;r3 As==00, 0x0006(r15)
    OS_ENTER_CRITICAL();
    3972:	b0 12 34 14 	call	#0x1434	
    3976:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
    397a:	f4 93 0e 00 	cmp.b	#-1,	14(r4)	;r3 As==11, 0x000e(r4)
    397e:	05 20       	jnz	$+12     	;abs 0x398a
        prio = OSTCBCur->OSTCBPrio;
    3980:	1f 42 88 03 	mov	&0x0388,r15	
    3984:	d4 4f 1c 00 	mov.b	28(r15),14(r4)	;0x001c(r15), 0x000e(r4)
    3988:	0e 00 
    }
    ptcb = OSTCBPrioTbl[prio];
    398a:	5f 44 0e 00 	mov.b	14(r4),	r15	;0x000e(r4)
    398e:	0f 5f       	rla	r15		
    3990:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3994:	a4 4f 0c 00 	mov	@r15,	12(r4)	;0x000c(r4)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
    3998:	84 93 0c 00 	tst	12(r4)		;0x000c(r4)
    399c:	06 20       	jnz	$+14     	;abs 0x39aa
        OS_EXIT_CRITICAL();
    399e:	2f 44       	mov	@r4,	r15	
    39a0:	b0 12 3a 14 	call	#0x143a	
        return (OS_TASK_NOT_EXIST);
    39a4:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    39a8:	56 3c       	jmp	$+174    	;abs 0x3a56
    }
    if (ptcb == (OS_TCB *)1) {
    39aa:	94 93 0c 00 	cmp	#1,	12(r4)	;r3 As==01, 0x000c(r4)
    39ae:	06 20       	jnz	$+14     	;abs 0x39bc
        OS_EXIT_CRITICAL();
    39b0:	2f 44       	mov	@r4,	r15	
    39b2:	b0 12 3a 14 	call	#0x143a	
        return (OS_TASK_NOT_EXIST);
    39b6:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    39ba:	4d 3c       	jmp	$+156    	;abs 0x3a56
    }  
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
    39bc:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    39c0:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    39c4:	1f f3       	and	#1,	r15	;r3 As==01
    39c6:	06 20       	jnz	$+14     	;abs 0x39d4
        OS_EXIT_CRITICAL();
    39c8:	2f 44       	mov	@r4,	r15	
    39ca:	b0 12 3a 14 	call	#0x143a	
        return (OS_TASK_OPT_ERR);
    39ce:	7f 40 82 ff 	mov.b	#-126,	r15	;#0xff82
    39d2:	41 3c       	jmp	$+132    	;abs 0x3a56
    }
    free = 0;
    39d4:	84 43 06 00 	mov	#0,	6(r4)	;r3 As==00, 0x0006(r4)
    39d8:	84 43 08 00 	mov	#0,	8(r4)	;r3 As==00, 0x0008(r4)
    size = ptcb->OSTCBStkSize;
    39dc:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    39e0:	94 4f 06 00 	mov	6(r15),	2(r4)	;0x0006(r15), 0x0002(r4)
    39e4:	02 00 
    39e6:	94 4f 08 00 	mov	8(r15),	4(r4)	;0x0008(r15), 0x0004(r4)
    39ea:	04 00 
    pchk = ptcb->OSTCBStkBottom;
    39ec:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    39f0:	94 4f 04 00 	mov	4(r15),	10(r4)	;0x0004(r15), 0x000a(r4)
    39f4:	0a 00 
    OS_EXIT_CRITICAL();
    39f6:	2f 44       	mov	@r4,	r15	
    39f8:	b0 12 3a 14 	call	#0x143a	
    39fc:	04 3c       	jmp	$+10     	;abs 0x3a06
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
        free++;
    39fe:	94 53 06 00 	inc	6(r4)		;0x0006(r4)
    3a02:	84 63 08 00 	adc	8(r4)		;0x0008(r4)
    free = 0;
    size = ptcb->OSTCBStkSize;
    pchk = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
    3a06:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3a0a:	2e 4f       	mov	@r15,	r14	
    3a0c:	4f 43       	clr.b	r15		
    3a0e:	0e 93       	tst	r14		
    3a10:	01 20       	jnz	$+4      	;abs 0x3a14
    3a12:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3a14:	a4 53 0a 00 	incd	10(r4)		;0x000a(r4)
    3a18:	4f 93       	tst.b	r15		
    3a1a:	f1 23       	jnz	$-28     	;abs 0x39fe
#else
    while (*pchk-- == (OS_STK)0) {
        free++;
    }
#endif
    p_stk_data->OSFree = free * sizeof(OS_STK);           /* Compute number of free bytes on the stack */
    3a1c:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    3a20:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3a24:	0e 5e       	rla	r14		
    3a26:	0f 6f       	rlc	r15		
    3a28:	1d 44 10 00 	mov	16(r4),	r13	;0x0010(r4)
    3a2c:	8d 4e 00 00 	mov	r14,	0(r13)	;0x0000(r13)
    3a30:	8d 4f 02 00 	mov	r15,	2(r13)	;0x0002(r13)
    p_stk_data->OSUsed = (size - free) * sizeof(OS_STK);  /* Compute number of bytes used on the stack */
    3a34:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    3a38:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3a3c:	1e 84 06 00 	sub	6(r4),	r14	;0x0006(r4)
    3a40:	1f 74 08 00 	subc	8(r4),	r15	;0x0008(r4)
    3a44:	0e 5e       	rla	r14		
    3a46:	0f 6f       	rlc	r15		
    3a48:	1d 44 10 00 	mov	16(r4),	r13	;0x0010(r4)
    3a4c:	8d 4e 04 00 	mov	r14,	4(r13)	;0x0004(r13)
    3a50:	8d 4f 06 00 	mov	r15,	6(r13)	;0x0006(r13)
    return (OS_NO_ERR);
    3a54:	4f 43       	clr.b	r15		
}
    3a56:	31 50 12 00 	add	#18,	r1	;#0x0012
    3a5a:	34 41       	pop	r4		
    3a5c:	30 41       	ret			

00003a5e <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    3a5e:	04 12       	push	r4		
    3a60:	31 82       	sub	#8,	r1	;r2 As==11
    3a62:	04 41       	mov	r1,	r4	
    3a64:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    3a68:	84 4d 02 00 	mov	r13,	2(r4)	;0x0002(r4)
    3a6c:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    3a70:	84 4c 06 00 	mov	r12,	6(r4)	;0x0006(r4)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
    3a74:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3a78:	1f f3       	and	#1,	r15	;r3 As==01
    3a7a:	4f 93       	tst.b	r15		
    3a7c:	14 24       	jz	$+42     	;abs 0x3aa6
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
    3a7e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3a82:	2f f3       	and	#2,	r15	;r3 As==10
    3a84:	10 24       	jz	$+34     	;abs 0x3aa6
    3a86:	09 3c       	jmp	$+20     	;abs 0x3a9a
#if OS_STK_GROWTH == 1                     
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
                size--;
    3a88:	b4 53 02 00 	add	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
    3a8c:	b4 63 04 00 	addc	#-1,	4(r4)	;r3 As==11, 0x0004(r4)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
    3a90:	2f 44       	mov	@r4,	r15	
    3a92:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    3a96:	a4 53 00 00 	incd	0(r4)		;0x0000(r4)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1                     
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
    3a9a:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3a9e:	f4 23       	jnz	$-22     	;abs 0x3a88
    3aa0:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    3aa4:	f1 23       	jnz	$-28     	;abs 0x3a88
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
    3aa6:	31 52       	add	#8,	r1	;r2 As==11
    3aa8:	34 41       	pop	r4		
    3aaa:	30 41       	ret			

00003aac <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
    3aac:	04 12       	push	r4		
    3aae:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3ab2:	04 41       	mov	r1,	r4	
    3ab4:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    3ab8:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (ticks > 0) {                             /* 0 means no delay!                                  */
    3abc:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    3ac0:	33 24       	jz	$+104    	;abs 0x3b28
        OS_ENTER_CRITICAL();
    3ac2:	b0 12 34 14 	call	#0x1434	
    3ac6:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
    3aca:	1f 42 88 03 	mov	&0x0388,r15	
    3ace:	d4 4f 1e 00 	mov.b	30(r15),2(r4)	;0x001e(r15), 0x0002(r4)
    3ad2:	02 00 
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
    3ad4:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    3ad8:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3adc:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    3ae0:	4e 4f       	mov.b	r15,	r14	
    3ae2:	1f 42 88 03 	mov	&0x0388,r15	
    3ae6:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    3aea:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    3aec:	4f fe       	and.b	r14,	r15	
    3aee:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        if (OSRdyTbl[y] == 0) {  
    3af2:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3af6:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    3afa:	4f 93       	tst.b	r15		
    3afc:	0b 20       	jnz	$+24     	;abs 0x3b14
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
    3afe:	1f 42 88 03 	mov	&0x0388,r15	
    3b02:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    3b06:	4e 4f       	mov.b	r15,	r14	
    3b08:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    3b0a:	5f 42 7e 03 	mov.b	&0x037e,r15	
    3b0e:	4f fe       	and.b	r14,	r15	
    3b10:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
    3b14:	1f 42 88 03 	mov	&0x0388,r15	
    3b18:	9f 44 04 00 	mov	4(r4),	24(r15)	;0x0004(r4), 0x0018(r15)
    3b1c:	18 00 
        OS_EXIT_CRITICAL();
    3b1e:	2f 44       	mov	@r4,	r15	
    3b20:	b0 12 3a 14 	call	#0x143a	
        OS_Sched();                              /* Find next task to run!                             */
    3b24:	b0 12 da 1d 	call	#0x1dda	
    }
}
    3b28:	31 50 06 00 	add	#6,	r1	;#0x0006
    3b2c:	34 41       	pop	r4		
    3b2e:	30 41       	ret			

00003b30 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U milli)
{
    3b30:	0b 12       	push	r11		
    3b32:	0a 12       	push	r10		
    3b34:	09 12       	push	r9		
    3b36:	08 12       	push	r8		
    3b38:	07 12       	push	r7		
    3b3a:	06 12       	push	r6		
    3b3c:	04 12       	push	r4		
    3b3e:	31 50 f0 ff 	add	#-16,	r1	;#0xfff0
    3b42:	04 41       	mov	r1,	r4	
    3b44:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
    3b48:	c4 4e 07 00 	mov.b	r14,	7(r4)	;0x0007(r4)
    3b4c:	c4 4d 08 00 	mov.b	r13,	8(r4)	;0x0008(r4)
    3b50:	84 4c 0a 00 	mov	r12,	10(r4)	;0x000a(r4)
        return (OS_TIME_INVALID_MILLI);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
    3b54:	5c 44 06 00 	mov.b	6(r4),	r12	;0x0006(r4)
    3b58:	0d 43       	clr	r13		
    3b5a:	0e 4c       	mov	r12,	r14	
    3b5c:	0f 4d       	mov	r13,	r15	
    3b5e:	0e 5e       	rla	r14		
    3b60:	0f 6f       	rlc	r15		
    3b62:	0e 5e       	rla	r14		
    3b64:	0f 6f       	rlc	r15		
    3b66:	0e 5e       	rla	r14		
    3b68:	0f 6f       	rlc	r15		
    3b6a:	0e 8c       	sub	r12,	r14	
    3b6c:	0f 7d       	subc	r13,	r15	
    3b6e:	0a 4e       	mov	r14,	r10	
    3b70:	0b 4f       	mov	r15,	r11	
    3b72:	4b ea       	xor.b	r10,	r11	
    3b74:	0b ea       	xor	r10,	r11	
    3b76:	8b 10       	swpb	r11		
    3b78:	7a f3       	and.b	#-1,	r10	;r3 As==11
    3b7a:	8a 10       	swpb	r10		
    3b7c:	0e 5a       	add	r10,	r14	
    3b7e:	0f 6b       	addc	r11,	r15	
    3b80:	0e 5e       	rla	r14		
    3b82:	0f 6f       	rlc	r15		
    3b84:	0e 5c       	add	r12,	r14	
    3b86:	0f 6d       	addc	r13,	r15	
    3b88:	0a 4e       	mov	r14,	r10	
    3b8a:	0b 4f       	mov	r15,	r11	
    3b8c:	0a 5c       	add	r12,	r10	
    3b8e:	0b 6d       	addc	r13,	r11	
    3b90:	5c 44 07 00 	mov.b	7(r4),	r12	;0x0007(r4)
    3b94:	0d 43       	clr	r13		
    3b96:	0e 4c       	mov	r12,	r14	
    3b98:	0f 4d       	mov	r13,	r15	
    3b9a:	0e 5e       	rla	r14		
    3b9c:	0f 6f       	rlc	r15		
    3b9e:	0e 5e       	rla	r14		
    3ba0:	0f 6f       	rlc	r15		
    3ba2:	0e 5e       	rla	r14		
    3ba4:	0f 6f       	rlc	r15		
    3ba6:	0e 5e       	rla	r14		
    3ba8:	0f 6f       	rlc	r15		
    3baa:	0e 8c       	sub	r12,	r14	
    3bac:	0f 7d       	subc	r13,	r15	
    3bae:	0e 5e       	rla	r14		
    3bb0:	0f 6f       	rlc	r15		
    3bb2:	0e 5e       	rla	r14		
    3bb4:	0f 6f       	rlc	r15		
    3bb6:	0c 4a       	mov	r10,	r12	
    3bb8:	0d 4b       	mov	r11,	r13	
    3bba:	0c 5e       	add	r14,	r12	
    3bbc:	0d 6f       	addc	r15,	r13	
    3bbe:	5e 44 08 00 	mov.b	8(r4),	r14	;0x0008(r4)
    3bc2:	0f 43       	clr	r15		
    3bc4:	0a 4c       	mov	r12,	r10	
    3bc6:	0b 4d       	mov	r13,	r11	
    3bc8:	0a 5e       	add	r14,	r10	
    3bca:	0b 6f       	addc	r15,	r11	
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    3bcc:	0c 4a       	mov	r10,	r12	
    3bce:	0d 4b       	mov	r11,	r13	
    3bd0:	0e 4c       	mov	r12,	r14	
    3bd2:	0f 4d       	mov	r13,	r15	
    3bd4:	0e 5e       	rla	r14		
    3bd6:	0f 6f       	rlc	r15		
    3bd8:	0c 4e       	mov	r14,	r12	
    3bda:	0d 4f       	mov	r15,	r13	
    3bdc:	0c 5a       	add	r10,	r12	
    3bde:	0d 6b       	addc	r11,	r13	
    3be0:	0e 4c       	mov	r12,	r14	
    3be2:	0f 4d       	mov	r13,	r15	
    3be4:	0e 5e       	rla	r14		
    3be6:	0f 6f       	rlc	r15		
    3be8:	0e 5e       	rla	r14		
    3bea:	0f 6f       	rlc	r15		
    3bec:	0e 5e       	rla	r14		
    3bee:	0f 6f       	rlc	r15		
    3bf0:	0e 5e       	rla	r14		
    3bf2:	0f 6f       	rlc	r15		
    3bf4:	0e 5e       	rla	r14		
    3bf6:	0f 6f       	rlc	r15		
    3bf8:	0c 5e       	add	r14,	r12	
    3bfa:	0d 6f       	addc	r15,	r13	
    3bfc:	0e 4c       	mov	r12,	r14	
    3bfe:	0f 4d       	mov	r13,	r15	
    3c00:	0e 5a       	add	r10,	r14	
    3c02:	0f 6b       	addc	r11,	r15	
    3c04:	84 4e 0c 00 	mov	r14,	12(r4)	;0x000c(r4)
    3c08:	84 4f 0e 00 	mov	r15,	14(r4)	;0x000e(r4)
    3c0c:	1a 44 0a 00 	mov	10(r4),	r10	;0x000a(r4)
    3c10:	0b 43       	clr	r11		
    3c12:	0c 4a       	mov	r10,	r12	
    3c14:	0d 4b       	mov	r11,	r13	
    3c16:	0e 4c       	mov	r12,	r14	
    3c18:	0f 4d       	mov	r13,	r15	
    3c1a:	0e 5e       	rla	r14		
    3c1c:	0f 6f       	rlc	r15		
    3c1e:	0c 4e       	mov	r14,	r12	
    3c20:	0d 4f       	mov	r15,	r13	
    3c22:	0c 5a       	add	r10,	r12	
    3c24:	0d 6b       	addc	r11,	r13	
    3c26:	0e 4c       	mov	r12,	r14	
    3c28:	0f 4d       	mov	r13,	r15	
    3c2a:	0e 5e       	rla	r14		
    3c2c:	0f 6f       	rlc	r15		
    3c2e:	0e 5e       	rla	r14		
    3c30:	0f 6f       	rlc	r15		
    3c32:	0e 5e       	rla	r14		
    3c34:	0f 6f       	rlc	r15		
    3c36:	0e 5e       	rla	r14		
    3c38:	0f 6f       	rlc	r15		
    3c3a:	0e 5e       	rla	r14		
    3c3c:	0f 6f       	rlc	r15		
    3c3e:	0c 5e       	add	r14,	r12	
    3c40:	0d 6f       	addc	r15,	r13	
    3c42:	0e 4c       	mov	r12,	r14	
    3c44:	0f 4d       	mov	r13,	r15	
    3c46:	0e 5a       	add	r10,	r14	
    3c48:	0f 6b       	addc	r11,	r15	
    3c4a:	0c 4e       	mov	r14,	r12	
    3c4c:	0d 4f       	mov	r15,	r13	
    3c4e:	3c 50 f4 01 	add	#500,	r12	;#0x01f4
    3c52:	0d 63       	adc	r13		
    3c54:	3e 40 e8 03 	mov	#1000,	r14	;#0x03e8
    3c58:	0f 43       	clr	r15		
    3c5a:	0a 4e       	mov	r14,	r10	
    3c5c:	0b 4f       	mov	r15,	r11	
    3c5e:	b0 12 16 46 	call	#0x4616	
    3c62:	0e 4c       	mov	r12,	r14	
    3c64:	0f 4d       	mov	r13,	r15	
        return (OS_TIME_INVALID_MILLI);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
    3c66:	1c 44 0c 00 	mov	12(r4),	r12	;0x000c(r4)
    3c6a:	1d 44 0e 00 	mov	14(r4),	r13	;0x000e(r4)
    3c6e:	0c 5e       	add	r14,	r12	
    3c70:	0d 6f       	addc	r15,	r13	
    3c72:	84 4c 02 00 	mov	r12,	2(r4)	;0x0002(r4)
    3c76:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    3c7a:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    3c7e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3c82:	07 43       	clr	r7		
    3c84:	06 4f       	mov	r15,	r6	
    3c86:	07 43       	clr	r7		
    3c88:	84 46 00 00 	mov	r6,	0(r4)	;0x0000(r4)
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    3c8c:	84 f3 04 00 	and	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    OSTimeDly((INT16U)ticks);
    3c90:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3c94:	b0 12 ac 3a 	call	#0x3aac	
    3c98:	0a 3c       	jmp	$+22     	;abs 0x3cae
    while (loops > 0) {
        OSTimeDly((INT16U)32768u);
    3c9a:	3f 40 00 80 	mov	#-32768,r15	;#0x8000
    3c9e:	b0 12 ac 3a 	call	#0x3aac	
        OSTimeDly((INT16U)32768u);
    3ca2:	3f 40 00 80 	mov	#-32768,r15	;#0x8000
    3ca6:	b0 12 ac 3a 	call	#0x3aac	
        loops--;
    3caa:	b4 53 00 00 	add	#-1,	0(r4)	;r3 As==11, 0x0000(r4)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
    3cae:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    3cb2:	f3 23       	jnz	$-24     	;abs 0x3c9a
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_NO_ERR);
    3cb4:	4f 43       	clr.b	r15		
}
    3cb6:	31 50 10 00 	add	#16,	r1	;#0x0010
    3cba:	34 41       	pop	r4		
    3cbc:	36 41       	pop	r6		
    3cbe:	37 41       	pop	r7		
    3cc0:	38 41       	pop	r8		
    3cc2:	39 41       	pop	r9		
    3cc4:	3a 41       	pop	r10		
    3cc6:	3b 41       	pop	r11		
    3cc8:	30 41       	ret			

00003cca <initDisplay>:



#include "Display.h"

void initDisplay() {
    3cca:	04 12       	push	r4		
    3ccc:	04 41       	mov	r1,	r4	
	InitOsc();
    3cce:	b0 12 d6 3f 	call	#0x3fd6	
	InitPorts();
    3cd2:	b0 12 5a 40 	call	#0x405a	
	InitLCD();
    3cd6:	b0 12 80 42 	call	#0x4280	
	clearDisplay();
    3cda:	b0 12 f8 3c 	call	#0x3cf8	
}
    3cde:	34 41       	pop	r4		
    3ce0:	30 41       	ret			

00003ce2 <putch>:
void putch(char c) {
    3ce2:	04 12       	push	r4		
    3ce4:	21 83       	decd	r1		
    3ce6:	04 41       	mov	r1,	r4	
    3ce8:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
	SEND_CHAR(c);
    3cec:	6f 44       	mov.b	@r4,	r15	
    3cee:	b0 12 58 41 	call	#0x4158	
}
    3cf2:	21 53       	incd	r1		
    3cf4:	34 41       	pop	r4		
    3cf6:	30 41       	ret			

00003cf8 <clearDisplay>:
void clearDisplay() {
    3cf8:	04 12       	push	r4		
    3cfa:	04 41       	mov	r1,	r4	
	SEND_CMD(CLR_DISP);
    3cfc:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3cfe:	b0 12 ec 41 	call	#0x41ec	
	Delayx100us(10);
    3d02:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3d06:	0f 43       	clr	r15		
    3d08:	b0 12 f0 40 	call	#0x40f0	
}
    3d0c:	34 41       	pop	r4		
    3d0e:	30 41       	ret			

00003d10 <gotoSecondLine>:
void gotoSecondLine() {
    3d10:	04 12       	push	r4		
    3d12:	04 41       	mov	r1,	r4	
//    SEND_CMD(CLR_DISP);
	SEND_CMD(DD_RAM_ADDR2);
    3d14:	7f 40 c0 ff 	mov.b	#-64,	r15	;#0xffc0
    3d18:	b0 12 ec 41 	call	#0x41ec	
}
    3d1c:	34 41       	pop	r4		
    3d1e:	30 41       	ret			

00003d20 <printString>:
void printString(char *String) {
    3d20:	04 12       	push	r4		
    3d22:	21 83       	decd	r1		
    3d24:	04 41       	mov	r1,	r4	
    3d26:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    3d2a:	06 3c       	jmp	$+14     	;abs 0x3d38
	while (*String)
		putch(*String++);
    3d2c:	2f 44       	mov	@r4,	r15	
    3d2e:	6f 4f       	mov.b	@r15,	r15	
    3d30:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    3d34:	b0 12 e2 3c 	call	#0x3ce2	
void gotoSecondLine() {
//    SEND_CMD(CLR_DISP);
	SEND_CMD(DD_RAM_ADDR2);
}
void printString(char *String) {
	while (*String)
    3d38:	2f 44       	mov	@r4,	r15	
    3d3a:	6f 4f       	mov.b	@r15,	r15	
    3d3c:	4f 93       	tst.b	r15		
    3d3e:	f6 23       	jnz	$-18     	;abs 0x3d2c
		putch(*String++);
}
    3d40:	21 53       	incd	r1		
    3d42:	34 41       	pop	r4		
    3d44:	30 41       	ret			

00003d46 <HexDigit>:
char HexDigit(int digitvalue) {
    3d46:	04 12       	push	r4		
    3d48:	21 83       	decd	r1		
    3d4a:	04 41       	mov	r1,	r4	
    3d4c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	if (digitvalue < 10)
    3d50:	b4 90 0a 00 	cmp	#10,	0(r4)	;#0x000a, 0x0000(r4)
    3d54:	00 00 
    3d56:	04 34       	jge	$+10     	;abs 0x3d60
		return (digitvalue + '0');
    3d58:	2f 44       	mov	@r4,	r15	
    3d5a:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3d5e:	03 3c       	jmp	$+8      	;abs 0x3d66
	else
		return (digitvalue + 'A' - 10);
    3d60:	2f 44       	mov	@r4,	r15	
    3d62:	7f 50 37 00 	add.b	#55,	r15	;#0x0037
}
    3d66:	21 53       	incd	r1		
    3d68:	34 41       	pop	r4		
    3d6a:	30 41       	ret			

00003d6c <printByte>:
void printByte(INT8U theByte) {
    3d6c:	04 12       	push	r4		
    3d6e:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3d72:	04 41       	mov	r1,	r4	
    3d74:	c4 4f 04 00 	mov.b	r15,	4(r4)	;0x0004(r4)
	char HexBuffer[3];
	HexBuffer[2] = '\0';
    3d78:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
	HexBuffer[1] = HexDigit(theByte & 0x000f);
    3d7c:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    3d80:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d84:	b0 12 46 3d 	call	#0x3d46	
    3d88:	c4 4f 01 00 	mov.b	r15,	1(r4)	;0x0001(r4)
	theByte = theByte >> 4;
    3d8c:	12 c3       	clrc			
    3d8e:	54 10 04 00 	rrc.b	4(r4)		;0x0004(r4)
    3d92:	54 11 04 00 	rra.b	4(r4)		;0x0004(r4)
    3d96:	54 11 04 00 	rra.b	4(r4)		;0x0004(r4)
    3d9a:	54 11 04 00 	rra.b	4(r4)		;0x0004(r4)
	HexBuffer[0] = HexDigit(theByte & 0x000f);
    3d9e:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    3da2:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3da6:	b0 12 46 3d 	call	#0x3d46	
    3daa:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
	printString(HexBuffer);
    3dae:	0f 44       	mov	r4,	r15	
    3db0:	b0 12 20 3d 	call	#0x3d20	
}
    3db4:	31 50 06 00 	add	#6,	r1	;#0x0006
    3db8:	34 41       	pop	r4		
    3dba:	30 41       	ret			

00003dbc <printHex>:
void printHex(unsigned int Number) {
    3dbc:	04 12       	push	r4		
    3dbe:	31 82       	sub	#8,	r1	;r2 As==11
    3dc0:	04 41       	mov	r1,	r4	
    3dc2:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	char HexBuffer[5];
	HexBuffer[4] = 0;
    3dc6:	c4 43 04 00 	mov.b	#0,	4(r4)	;r3 As==00, 0x0004(r4)
	HexBuffer[3] = HexDigit(Number & 0x000f);
    3dca:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3dce:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3dd2:	b0 12 46 3d 	call	#0x3d46	
    3dd6:	c4 4f 03 00 	mov.b	r15,	3(r4)	;0x0003(r4)
	Number = Number >> 4;
    3dda:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3dde:	12 c3       	clrc			
    3de0:	0f 10       	rrc	r15		
    3de2:	0f 11       	rra	r15		
    3de4:	0f 11       	rra	r15		
    3de6:	0f 11       	rra	r15		
    3de8:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	HexBuffer[2] = HexDigit(Number & 0x000f);
    3dec:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3df0:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3df4:	b0 12 46 3d 	call	#0x3d46	
    3df8:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
	Number = Number >> 4;
    3dfc:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3e00:	12 c3       	clrc			
    3e02:	0f 10       	rrc	r15		
    3e04:	0f 11       	rra	r15		
    3e06:	0f 11       	rra	r15		
    3e08:	0f 11       	rra	r15		
    3e0a:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	HexBuffer[1] = HexDigit(Number & 0x000f);
    3e0e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3e12:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3e16:	b0 12 46 3d 	call	#0x3d46	
    3e1a:	c4 4f 01 00 	mov.b	r15,	1(r4)	;0x0001(r4)
	Number = Number >> 4;
    3e1e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3e22:	12 c3       	clrc			
    3e24:	0f 10       	rrc	r15		
    3e26:	0f 11       	rra	r15		
    3e28:	0f 11       	rra	r15		
    3e2a:	0f 11       	rra	r15		
    3e2c:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	HexBuffer[0] = HexDigit(Number & 0x000f);
    3e30:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3e34:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3e38:	b0 12 46 3d 	call	#0x3d46	
    3e3c:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
	printString(HexBuffer);
    3e40:	0f 44       	mov	r4,	r15	
    3e42:	b0 12 20 3d 	call	#0x3d20	
}
    3e46:	31 52       	add	#8,	r1	;r2 As==11
    3e48:	34 41       	pop	r4		
    3e4a:	30 41       	ret			

00003e4c <printDecimal>:
void printDecimal(int Number) {
    3e4c:	0b 12       	push	r11		
    3e4e:	0a 12       	push	r10		
    3e50:	09 12       	push	r9		
    3e52:	08 12       	push	r8		
    3e54:	04 12       	push	r4		
    3e56:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3e5a:	04 41       	mov	r1,	r4	
    3e5c:	84 4f 0c 00 	mov	r15,	12(r4)	;0x000c(r4)
	// need to move to long int to account for
	// negative 32768
	char DecimalBuffer[7];
	long lNumber = Number;
    3e60:	94 44 0c 00 	mov	12(r4),	0(r4)	;0x000c(r4), 0x0000(r4)
    3e64:	00 00 
    3e66:	a4 44 02 00 	mov	@r4,	2(r4)	;0x0002(r4)
    3e6a:	94 54 02 00 	rla	2(r4)		;0x0002(r4)
    3e6e:	02 00 
    3e70:	94 74 02 00 	subc	2(r4),	2(r4)	;0x0002(r4), 0x0002(r4)
    3e74:	02 00 
    3e76:	b4 e3 02 00 	xor	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
	DecimalBuffer[6] = 0;
    3e7a:	c4 43 0a 00 	mov.b	#0,	10(r4)	;r3 As==00, 0x000a(r4)
	if (lNumber < 0) {
    3e7e:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3e82:	0f 34       	jge	$+32     	;abs 0x3ea2
		DecimalBuffer[0] = '-';
    3e84:	f4 40 2d 00 	mov.b	#45,	4(r4)	;#0x002d, 0x0004(r4)
    3e88:	04 00 
		lNumber = -lNumber;
    3e8a:	2e 44       	mov	@r4,	r14	
    3e8c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3e90:	3e e3       	inv	r14		
    3e92:	3f e3       	inv	r15		
    3e94:	1e 53       	inc	r14		
    3e96:	0f 63       	adc	r15		
    3e98:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3e9c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    3ea0:	03 3c       	jmp	$+8      	;abs 0x3ea8
	} else
		DecimalBuffer[0] = '+';
    3ea2:	f4 40 2b 00 	mov.b	#43,	4(r4)	;#0x002b, 0x0004(r4)
    3ea6:	04 00 
	DecimalBuffer[5] = (lNumber % 10) + '0';
    3ea8:	2c 44       	mov	@r4,	r12	
    3eaa:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3eae:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3eb2:	0f 43       	clr	r15		
    3eb4:	0a 4e       	mov	r14,	r10	
    3eb6:	0b 4f       	mov	r15,	r11	
    3eb8:	b0 12 40 46 	call	#0x4640	
    3ebc:	4f 4e       	mov.b	r14,	r15	
    3ebe:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3ec2:	c4 4f 09 00 	mov.b	r15,	9(r4)	;0x0009(r4)
	lNumber = lNumber / 10;
    3ec6:	2c 44       	mov	@r4,	r12	
    3ec8:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3ecc:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3ed0:	0f 43       	clr	r15		
    3ed2:	0a 4e       	mov	r14,	r10	
    3ed4:	0b 4f       	mov	r15,	r11	
    3ed6:	b0 12 40 46 	call	#0x4640	
    3eda:	0e 4c       	mov	r12,	r14	
    3edc:	0f 4d       	mov	r13,	r15	
    3ede:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3ee2:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[4] = (lNumber % 10) + '0';
    3ee6:	2c 44       	mov	@r4,	r12	
    3ee8:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3eec:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3ef0:	0f 43       	clr	r15		
    3ef2:	0a 4e       	mov	r14,	r10	
    3ef4:	0b 4f       	mov	r15,	r11	
    3ef6:	b0 12 40 46 	call	#0x4640	
    3efa:	4f 4e       	mov.b	r14,	r15	
    3efc:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3f00:	c4 4f 08 00 	mov.b	r15,	8(r4)	;0x0008(r4)
	lNumber = lNumber / 10;
    3f04:	2c 44       	mov	@r4,	r12	
    3f06:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f0a:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f0e:	0f 43       	clr	r15		
    3f10:	0a 4e       	mov	r14,	r10	
    3f12:	0b 4f       	mov	r15,	r11	
    3f14:	b0 12 40 46 	call	#0x4640	
    3f18:	0e 4c       	mov	r12,	r14	
    3f1a:	0f 4d       	mov	r13,	r15	
    3f1c:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3f20:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[3] = (lNumber % 10) + '0';
    3f24:	2c 44       	mov	@r4,	r12	
    3f26:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f2a:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f2e:	0f 43       	clr	r15		
    3f30:	0a 4e       	mov	r14,	r10	
    3f32:	0b 4f       	mov	r15,	r11	
    3f34:	b0 12 40 46 	call	#0x4640	
    3f38:	4f 4e       	mov.b	r14,	r15	
    3f3a:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3f3e:	c4 4f 07 00 	mov.b	r15,	7(r4)	;0x0007(r4)
	lNumber = lNumber / 10;
    3f42:	2c 44       	mov	@r4,	r12	
    3f44:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f48:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f4c:	0f 43       	clr	r15		
    3f4e:	0a 4e       	mov	r14,	r10	
    3f50:	0b 4f       	mov	r15,	r11	
    3f52:	b0 12 40 46 	call	#0x4640	
    3f56:	0e 4c       	mov	r12,	r14	
    3f58:	0f 4d       	mov	r13,	r15	
    3f5a:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3f5e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[2] = (lNumber % 10) + '0';
    3f62:	2c 44       	mov	@r4,	r12	
    3f64:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f68:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f6c:	0f 43       	clr	r15		
    3f6e:	0a 4e       	mov	r14,	r10	
    3f70:	0b 4f       	mov	r15,	r11	
    3f72:	b0 12 40 46 	call	#0x4640	
    3f76:	4f 4e       	mov.b	r14,	r15	
    3f78:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3f7c:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
	lNumber = lNumber / 10;
    3f80:	2c 44       	mov	@r4,	r12	
    3f82:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f86:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f8a:	0f 43       	clr	r15		
    3f8c:	0a 4e       	mov	r14,	r10	
    3f8e:	0b 4f       	mov	r15,	r11	
    3f90:	b0 12 40 46 	call	#0x4640	
    3f94:	0e 4c       	mov	r12,	r14	
    3f96:	0f 4d       	mov	r13,	r15	
    3f98:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3f9c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[1] = (lNumber % 10) + '0';
    3fa0:	2c 44       	mov	@r4,	r12	
    3fa2:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3fa6:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3faa:	0f 43       	clr	r15		
    3fac:	0a 4e       	mov	r14,	r10	
    3fae:	0b 4f       	mov	r15,	r11	
    3fb0:	b0 12 40 46 	call	#0x4640	
    3fb4:	4f 4e       	mov.b	r14,	r15	
    3fb6:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3fba:	c4 4f 05 00 	mov.b	r15,	5(r4)	;0x0005(r4)
	printString(DecimalBuffer);
    3fbe:	0f 44       	mov	r4,	r15	
    3fc0:	2f 52       	add	#4,	r15	;r2 As==10
    3fc2:	b0 12 20 3d 	call	#0x3d20	
}
    3fc6:	31 50 0e 00 	add	#14,	r1	;#0x000e
    3fca:	34 41       	pop	r4		
    3fcc:	38 41       	pop	r8		
    3fce:	39 41       	pop	r9		
    3fd0:	3a 41       	pop	r10		
    3fd2:	3b 41       	pop	r11		
    3fd4:	30 41       	ret			

00003fd6 <InitOsc>:

void InitOsc(void) {
    3fd6:	04 12       	push	r4		
    3fd8:	04 41       	mov	r1,	r4	
	WDTCTL = WDTPW | WDTHOLD; // stop watchdog timer
    3fda:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    3fde:	20 01 

	BCSCTL1 |= XTS; // XT1 as high-frequency
    3fe0:	5f 42 57 00 	mov.b	&0x0057,r15	
    3fe4:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    3fe8:	c2 4f 57 00 	mov.b	r15,	&0x0057	
	_BIC_SR(OSCOFF);
    3fec:	32 c0 20 00 	bic	#32,	r2	;#0x0020
	// turn on XT1 oscillator

	do // wait in loop until crystal is stable
		IFG1 &= ~OFIFG;
    3ff0:	5f 42 02 00 	mov.b	&0x0002,r15	
    3ff4:	6f c3       	bic.b	#2,	r15	;r3 As==10
    3ff6:	c2 4f 02 00 	mov.b	r15,	&0x0002	
	while (IFG1 & OFIFG);
    3ffa:	5f 42 02 00 	mov.b	&0x0002,r15	
    3ffe:	7f f3       	and.b	#-1,	r15	;r3 As==11
    4000:	2f f3       	and	#2,	r15	;r3 As==10
    4002:	f6 23       	jnz	$-18     	;abs 0x3ff0

	BCSCTL1 |= DIVA0; // ACLK = XT1 / 2
    4004:	5f 42 57 00 	mov.b	&0x0057,r15	
    4008:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    400c:	c2 4f 57 00 	mov.b	r15,	&0x0057	
	BCSCTL1 &= ~DIVA1;
    4010:	5f 42 57 00 	mov.b	&0x0057,r15	
    4014:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    4018:	c2 4f 57 00 	mov.b	r15,	&0x0057	

	IE1 &= ~WDTIE; // disable WDT int.
    401c:	5f 42 00 00 	mov.b	&0x0000,r15	
    4020:	5f c3       	bic.b	#1,	r15	;r3 As==01
    4022:	c2 4f 00 00 	mov.b	r15,	&0x0000	
	IFG1 &= ~WDTIFG; // clear WDT int. flag
    4026:	5f 42 02 00 	mov.b	&0x0002,r15	
    402a:	5f c3       	bic.b	#1,	r15	;r3 As==01
    402c:	c2 4f 02 00 	mov.b	r15,	&0x0002	

	WDTCTL = WDTPW | WDTTMSEL | WDTCNTCL | WDTSSEL | WDTIS1; // use WDT as timer, flag each
    4030:	b2 40 1e 5a 	mov	#23070,	&0x0120	;#0x5a1e
    4034:	20 01 
															 // 512 pulses from ACLK

	while (!(IFG1 & WDTIFG))
    4036:	5f 42 02 00 	mov.b	&0x0002,r15	
    403a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    403c:	1f f3       	and	#1,	r15	;r3 As==01
    403e:	fb 27       	jz	$-8      	;abs 0x4036
		; // count 1024 pulses from XT1 (until XT1's
		  // amplitude is OK)

	IFG1 &= ~OFIFG; // clear osc. fault int. flag
    4040:	5f 42 02 00 	mov.b	&0x0002,r15	
    4044:	6f c3       	bic.b	#2,	r15	;r3 As==10
    4046:	c2 4f 02 00 	mov.b	r15,	&0x0002	
	BCSCTL2 |= SELM0 | SELM1; // set XT1 as MCLK
    404a:	5f 42 58 00 	mov.b	&0x0058,r15	
    404e:	7f d0 c0 ff 	bis.b	#-64,	r15	;#0xffc0
    4052:	c2 4f 58 00 	mov.b	r15,	&0x0058	
}
    4056:	34 41       	pop	r4		
    4058:	30 41       	ret			

0000405a <InitPorts>:

void InitPorts(void) {
    405a:	04 12       	push	r4		
    405c:	04 41       	mov	r1,	r4	
	P1SEL = 0; //
    405e:	c2 43 26 00 	mov.b	#0,	&0x0026	;r3 As==00
	P1OUT = 0; //
    4062:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00
	P1DIR = BIT5 | BIT6; //enable only Relay outputs
    4066:	f2 40 60 00 	mov.b	#96,	&0x0022	;#0x0060
    406a:	22 00 

	P2SEL = 0;
    406c:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00
	P2OUT = 0;
    4070:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00
	P2DIR = ~BIT0; //only P2.0 is input
    4074:	f2 40 fe ff 	mov.b	#-2,	&0x002a	;#0xfffe
    4078:	2a 00 

	P3SEL |= BIT4 | BIT5; //enable UART0
    407a:	5f 42 1b 00 	mov.b	&0x001b,r15	
    407e:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    4082:	c2 4f 1b 00 	mov.b	r15,	&0x001b	
	P3DIR |= BIT4; //enable TXD0 as output
    4086:	5f 42 1a 00 	mov.b	&0x001a,r15	
    408a:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    408e:	c2 4f 1a 00 	mov.b	r15,	&0x001a	
	P3DIR &= ~BIT5; //enable RXD0 as input
    4092:	5f 42 1a 00 	mov.b	&0x001a,r15	
    4096:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    409a:	c2 4f 1a 00 	mov.b	r15,	&0x001a	

	P4SEL = 0;
    409e:	c2 43 1f 00 	mov.b	#0,	&0x001f	;r3 As==00
	P4OUT = 0;
    40a2:	c2 43 1d 00 	mov.b	#0,	&0x001d	;r3 As==00
	P4DIR = BIT2 | BIT3; //only buzzer pins are outputs
    40a6:	f2 40 0c 00 	mov.b	#12,	&0x001e	;#0x000c
    40aa:	1e 00 

	//P6SEL = 0x80;
	//P6OUT = 0;
	//P6DIR = 0x00;
	//all output
}
    40ac:	34 41       	pop	r4		
    40ae:	30 41       	ret			

000040b0 <Delay>:

void Delay(unsigned long int a)

{
    40b0:	04 12       	push	r4		
    40b2:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    40b6:	04 41       	mov	r1,	r4	
    40b8:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    40bc:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
	int k;
	for (k = 0; k != a; ++k) {
    40c0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    40c4:	06 3c       	jmp	$+14     	;abs 0x40d2
		_NOP();
    40c6:	03 43       	nop			
		_NOP();
    40c8:	03 43       	nop			
		_NOP();
    40ca:	03 43       	nop			
		_NOP();
    40cc:	03 43       	nop			

void Delay(unsigned long int a)

{
	int k;
	for (k = 0; k != a; ++k) {
    40ce:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    40d2:	2e 44       	mov	@r4,	r14	
    40d4:	0f 4e       	mov	r14,	r15	
    40d6:	0f 5f       	rla	r15		
    40d8:	0f 7f       	subc	r15,	r15	
    40da:	3f e3       	inv	r15		
    40dc:	1e 94 02 00 	cmp	2(r4),	r14	;0x0002(r4)
    40e0:	f2 23       	jnz	$-26     	;abs 0x40c6
    40e2:	1f 94 04 00 	cmp	4(r4),	r15	;0x0004(r4)
    40e6:	ef 23       	jnz	$-32     	;abs 0x40c6
		_NOP();
		_NOP();
		_NOP();
		_NOP();
	}
}
    40e8:	31 50 06 00 	add	#6,	r1	;#0x0006
    40ec:	34 41       	pop	r4		
    40ee:	30 41       	ret			

000040f0 <Delayx100us>:

void Delayx100us(unsigned long int b) {
    40f0:	04 12       	push	r4		
    40f2:	31 82       	sub	#8,	r1	;r2 As==11
    40f4:	04 41       	mov	r1,	r4	
    40f6:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    40fa:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	long int j;

	for (j = 0; j != b; ++j)
    40fe:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    4102:	84 43 02 00 	mov	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    4106:	09 3c       	jmp	$+20     	;abs 0x411a
		Delay(_100us);
    4108:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    410c:	0f 43       	clr	r15		
    410e:	b0 12 b0 40 	call	#0x40b0	
}

void Delayx100us(unsigned long int b) {
	long int j;

	for (j = 0; j != b; ++j)
    4112:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    4116:	84 63 02 00 	adc	2(r4)		;0x0002(r4)
    411a:	2e 44       	mov	@r4,	r14	
    411c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    4120:	1e 94 04 00 	cmp	4(r4),	r14	;0x0004(r4)
    4124:	f1 23       	jnz	$-28     	;abs 0x4108
    4126:	1f 94 06 00 	cmp	6(r4),	r15	;0x0006(r4)
    412a:	ee 23       	jnz	$-34     	;abs 0x4108
		Delay(_100us);
}
    412c:	31 52       	add	#8,	r1	;r2 As==11
    412e:	34 41       	pop	r4		
    4130:	30 41       	ret			

00004132 <_E>:

void _E(void) {
    4132:	04 12       	push	r4		
    4134:	04 41       	mov	r1,	r4	
	bitset(P2OUT, E);
    4136:	5f 42 29 00 	mov.b	&0x0029,r15	
    413a:	7f d2       	bis.b	#8,	r15	;r2 As==11
    413c:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//toggle E for LCD
	Delay(_10us);
    4140:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    4144:	0f 43       	clr	r15		
    4146:	b0 12 b0 40 	call	#0x40b0	
	bitclr(P2OUT, E);
    414a:	5f 42 29 00 	mov.b	&0x0029,r15	
    414e:	7f c2       	bic.b	#8,	r15	;r2 As==11
    4150:	c2 4f 29 00 	mov.b	r15,	&0x0029	
}
    4154:	34 41       	pop	r4		
    4156:	30 41       	ret			

00004158 <SEND_CHAR>:

void SEND_CHAR(unsigned char d) {
    4158:	04 12       	push	r4		
    415a:	21 82       	sub	#4,	r1	;r2 As==10
    415c:	04 41       	mov	r1,	r4	
    415e:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
	int temp;
	Delayx100us(5); //.5ms
    4162:	3e 40 05 00 	mov	#5,	r14	;#0x0005
    4166:	0f 43       	clr	r15		
    4168:	b0 12 f0 40 	call	#0x40f0	
	temp = d & 0xf0; //get upper nibble
    416c:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    4170:	0e 4f       	mov	r15,	r14	
    4172:	3e f0 f0 00 	and	#240,	r14	;#0x00f0
    4176:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    417a:	5f 42 29 00 	mov.b	&0x0029,r15	
    417e:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    4182:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    4186:	2f 44       	mov	@r4,	r15	
    4188:	4e 4f       	mov.b	r15,	r14	
    418a:	5f 42 29 00 	mov.b	&0x0029,r15	
    418e:	4f de       	bis.b	r14,	r15	
    4190:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitset(P2OUT, RS);
    4194:	5f 42 29 00 	mov.b	&0x0029,r15	
    4198:	6f d2       	bis.b	#4,	r15	;r2 As==10
    419a:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to data mode
	_E(); //toggle E for LCD
    419e:	b0 12 32 41 	call	#0x4132	
	temp = d & 0x0f;
    41a2:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    41a6:	0e 4f       	mov	r15,	r14	
    41a8:	3e f0 0f 00 	and	#15,	r14	;#0x000f
    41ac:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	temp = temp << 4; //get down nibble
    41b0:	2f 44       	mov	@r4,	r15	
    41b2:	0f 5f       	rla	r15		
    41b4:	0f 5f       	rla	r15		
    41b6:	0f 5f       	rla	r15		
    41b8:	0f 5f       	rla	r15		
    41ba:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    41be:	5f 42 29 00 	mov.b	&0x0029,r15	
    41c2:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    41c6:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    41ca:	2f 44       	mov	@r4,	r15	
    41cc:	4e 4f       	mov.b	r15,	r14	
    41ce:	5f 42 29 00 	mov.b	&0x0029,r15	
    41d2:	4f de       	bis.b	r14,	r15	
    41d4:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitset(P2OUT, RS);
    41d8:	5f 42 29 00 	mov.b	&0x0029,r15	
    41dc:	6f d2       	bis.b	#4,	r15	;r2 As==10
    41de:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to data mode
	_E(); //toggle E for LCD
    41e2:	b0 12 32 41 	call	#0x4132	
}
    41e6:	21 52       	add	#4,	r1	;r2 As==10
    41e8:	34 41       	pop	r4		
    41ea:	30 41       	ret			

000041ec <SEND_CMD>:

void SEND_CMD(unsigned char e) {
    41ec:	04 12       	push	r4		
    41ee:	21 82       	sub	#4,	r1	;r2 As==10
    41f0:	04 41       	mov	r1,	r4	
    41f2:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
	int temp;
	Delayx100us(10); //10ms
    41f6:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    41fa:	0f 43       	clr	r15		
    41fc:	b0 12 f0 40 	call	#0x40f0	
	temp = e & 0xf0; //get upper nibble
    4200:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    4204:	0e 4f       	mov	r15,	r14	
    4206:	3e f0 f0 00 	and	#240,	r14	;#0x00f0
    420a:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    420e:	5f 42 29 00 	mov.b	&0x0029,r15	
    4212:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    4216:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp; //send CMD to LCD
    421a:	2f 44       	mov	@r4,	r15	
    421c:	4e 4f       	mov.b	r15,	r14	
    421e:	5f 42 29 00 	mov.b	&0x0029,r15	
    4222:	4f de       	bis.b	r14,	r15	
    4224:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitclr(P2OUT, RS);
    4228:	5f 42 29 00 	mov.b	&0x0029,r15	
    422c:	6f c2       	bic.b	#4,	r15	;r2 As==10
    422e:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to CMD mode
	_E(); //toggle E for LCD
    4232:	b0 12 32 41 	call	#0x4132	
	temp = e & 0x0f;
    4236:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    423a:	0e 4f       	mov	r15,	r14	
    423c:	3e f0 0f 00 	and	#15,	r14	;#0x000f
    4240:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	temp = temp << 4; //get down nibble
    4244:	2f 44       	mov	@r4,	r15	
    4246:	0f 5f       	rla	r15		
    4248:	0f 5f       	rla	r15		
    424a:	0f 5f       	rla	r15		
    424c:	0f 5f       	rla	r15		
    424e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    4252:	5f 42 29 00 	mov.b	&0x0029,r15	
    4256:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    425a:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    425e:	2f 44       	mov	@r4,	r15	
    4260:	4e 4f       	mov.b	r15,	r14	
    4262:	5f 42 29 00 	mov.b	&0x0029,r15	
    4266:	4f de       	bis.b	r14,	r15	
    4268:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitclr(P2OUT, RS);
    426c:	5f 42 29 00 	mov.b	&0x0029,r15	
    4270:	6f c2       	bic.b	#4,	r15	;r2 As==10
    4272:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to CMD mode
	_E(); //toggle E for LCD
    4276:	b0 12 32 41 	call	#0x4132	
}
    427a:	21 52       	add	#4,	r1	;r2 As==10
    427c:	34 41       	pop	r4		
    427e:	30 41       	ret			

00004280 <InitLCD>:

void InitLCD(void) {
    4280:	04 12       	push	r4		
    4282:	04 41       	mov	r1,	r4	
	bitclr(P2OUT, RS);
    4284:	5f 42 29 00 	mov.b	&0x0029,r15	
    4288:	6f c2       	bic.b	#4,	r15	;r2 As==10
    428a:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	Delayx100us(250); //Delay 100ms
    428e:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4292:	0f 43       	clr	r15		
    4294:	b0 12 f0 40 	call	#0x40f0	
	Delayx100us(250);
    4298:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    429c:	0f 43       	clr	r15		
    429e:	b0 12 f0 40 	call	#0x40f0	
	Delayx100us(250);
    42a2:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    42a6:	0f 43       	clr	r15		
    42a8:	b0 12 f0 40 	call	#0x40f0	
	Delayx100us(250);
    42ac:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    42b0:	0f 43       	clr	r15		
    42b2:	b0 12 f0 40 	call	#0x40f0	
	LCD_Data |= BIT4 | BIT5; //D7-D4 = 0011
    42b6:	5f 42 29 00 	mov.b	&0x0029,r15	
    42ba:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    42be:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data &= ~BIT6 & ~BIT7;
    42c2:	5f 42 29 00 	mov.b	&0x0029,r15	
    42c6:	7f f0 3f 00 	and.b	#63,	r15	;#0x003f
    42ca:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	_E(); //toggle E for LCD
    42ce:	b0 12 32 41 	call	#0x4132	
	Delayx100us(100); //10ms
    42d2:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    42d6:	0f 43       	clr	r15		
    42d8:	b0 12 f0 40 	call	#0x40f0	
	_E(); //toggle E for LCD
    42dc:	b0 12 32 41 	call	#0x4132	
	Delayx100us(100); //10ms
    42e0:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    42e4:	0f 43       	clr	r15		
    42e6:	b0 12 f0 40 	call	#0x40f0	
	_E(); //toggle E for LCD
    42ea:	b0 12 32 41 	call	#0x4132	
	Delayx100us(100); //10ms
    42ee:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    42f2:	0f 43       	clr	r15		
    42f4:	b0 12 f0 40 	call	#0x40f0	
	LCD_Data &= ~BIT4;
    42f8:	5f 42 29 00 	mov.b	&0x0029,r15	
    42fc:	7f f0 ef ff 	and.b	#-17,	r15	;#0xffef
    4300:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	_E(); //toggle E for LCD
    4304:	b0 12 32 41 	call	#0x4132	

	SEND_CMD(DISP_ON);
    4308:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    430c:	b0 12 ec 41 	call	#0x41ec	
	SEND_CMD(CLR_DISP);
    4310:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4312:	b0 12 ec 41 	call	#0x41ec	
	Delayx100us(250);
    4316:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    431a:	0f 43       	clr	r15		
    431c:	b0 12 f0 40 	call	#0x40f0	
	Delayx100us(250);
    4320:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4324:	0f 43       	clr	r15		
    4326:	b0 12 f0 40 	call	#0x40f0	
	Delayx100us(250);
    432a:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    432e:	0f 43       	clr	r15		
    4330:	b0 12 f0 40 	call	#0x40f0	
	Delayx100us(250);
    4334:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4338:	0f 43       	clr	r15		
    433a:	b0 12 f0 40 	call	#0x40f0	
}
    433e:	34 41       	pop	r4		
    4340:	30 41       	ret			

00004342 <ServiceOutput>:
INT8S setVolume(INT8U cmd, INT8U nb);

// Helpers
INT8S sendOverSPI(INT8U target, INT16U data, INT8U nbits);

void ServiceOutput(void *parg) {
    4342:	04 12       	push	r4		
    4344:	31 82       	sub	#8,	r1	;r2 As==11
    4346:	04 41       	mov	r1,	r4	
    4348:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)

		OS_EVENT *msgQServiceOutput = (OS_EVENT*) parg;
    434c:	94 44 06 00 	mov	6(r4),	2(r4)	;0x0006(r4), 0x0002(r4)
    4350:	02 00 
		INT8U err;
		ServiceMsg* data;

		for (;;) {

			data = (ServiceMsg*) OSQPend (msgQServiceOutput, 0, &err);
    4352:	0e 44       	mov	r4,	r14	
    4354:	2e 52       	add	#4,	r14	;r2 As==10
    4356:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    435a:	0d 4e       	mov	r14,	r13	
    435c:	0e 43       	clr	r14		
    435e:	b0 12 00 2e 	call	#0x2e00	
    4362:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)

			switch(data->serviceType) {
    4366:	2f 44       	mov	@r4,	r15	
    4368:	2f 4f       	mov	@r15,	r15	
    436a:	2f 93       	cmp	#2,	r15	;r3 As==10
    436c:	10 24       	jz	$+34     	;abs 0x438e
    436e:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4372:	05 2c       	jc	$+12     	;abs 0x437e
    4374:	0f 93       	tst	r15		
    4376:	09 24       	jz	$+20     	;abs 0x438a
    4378:	1f 93       	cmp	#1,	r15	;r3 As==01
    437a:	08 24       	jz	$+18     	;abs 0x438c
    437c:	ea 3f       	jmp	$-42     	;abs 0x4352
    437e:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4382:	0b 24       	jz	$+24     	;abs 0x439a
    4384:	2f 92       	cmp	#4,	r15	;r2 As==10
    4386:	11 24       	jz	$+36     	;abs 0x43aa
    4388:	e4 3f       	jmp	$-54     	;abs 0x4352
				break;
			default:
				// Error
				break;
			}
		}
    438a:	18 3c       	jmp	$+50     	;abs 0x43bc

			data = (ServiceMsg*) OSQPend (msgQServiceOutput, 0, &err);

			switch(data->serviceType) {
			case SERV_BARGRAPH:
				break;
    438c:	17 3c       	jmp	$+48     	;abs 0x43bc
			case SERV_EEPROM:
				break;
			case SERV_FREQ:
				setFrequency(data->val);
    438e:	2f 44       	mov	@r4,	r15	
    4390:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    4394:	b0 12 be 43 	call	#0x43be	
    4398:	11 3c       	jmp	$+36     	;abs 0x43bc
				break;
			case SERV_LCD:
				clearDisplay();
    439a:	b0 12 f8 3c 	call	#0x3cf8	
				// Parse string '\n' gotoSecondLine() TODO
				printString(data->msg.pBuffer);
    439e:	2f 44       	mov	@r4,	r15	
    43a0:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    43a4:	b0 12 20 3d 	call	#0x3d20	
    43a8:	09 3c       	jmp	$+20     	;abs 0x43bc
				break;
			case SERV_VOLUME:
				setVolume(VOLUME_CMD, data->val);
    43aa:	2f 44       	mov	@r4,	r15	
    43ac:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    43b0:	4e 4f       	mov.b	r15,	r14	
    43b2:	7f 40 1f 00 	mov.b	#31,	r15	;#0x001f
    43b6:	b0 12 12 44 	call	#0x4412	
    43ba:	cb 3f       	jmp	$-104    	;abs 0x4352
				break;
			default:
				// Error
				break;
			}
		}
    43bc:	ca 3f       	jmp	$-106    	;abs 0x4352

000043be <setFrequency>:

}

INT8S setFrequency(INT16U nb) {
    43be:	04 12       	push	r4		
    43c0:	21 82       	sub	#4,	r1	;r2 As==10
    43c2:	04 41       	mov	r1,	r4	
    43c4:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)

	if(nb>1023) {
    43c8:	b4 90 00 04 	cmp	#1024,	2(r4)	;#0x0400, 0x0002(r4)
    43cc:	02 00 
    43ce:	02 28       	jnc	$+6      	;abs 0x43d4
		return -1;
    43d0:	7f 43       	mov.b	#-1,	r15	;r3 As==11
    43d2:	1c 3c       	jmp	$+58     	;abs 0x440c
	}

	INT16U data = (nb << 2) & 0x0fff; // "create" dummy bits and select lowest 12 bits
    43d4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    43d8:	0f 5f       	rla	r15		
    43da:	0f 5f       	rla	r15		
    43dc:	0e 4f       	mov	r15,	r14	
    43de:	3e f0 ff 0f 	and	#4095,	r14	;#0x0fff
    43e2:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)

	clearDisplay();
    43e6:	b0 12 f8 3c 	call	#0x3cf8	
	printDecimal(nb);
    43ea:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    43ee:	b0 12 4c 3e 	call	#0x3e4c	
	gotoSecondLine();
    43f2:	b0 12 10 3d 	call	#0x3d10	
	printHex(data);
    43f6:	2f 44       	mov	@r4,	r15	
    43f8:	b0 12 bc 3d 	call	#0x3dbc	
	sendOverSPI(SPI_FREQ, data, 12);
    43fc:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    4400:	4d 4f       	mov.b	r15,	r13	
    4402:	2e 44       	mov	@r4,	r14	
    4404:	4f 43       	clr.b	r15		
    4406:	b0 12 48 44 	call	#0x4448	

	return 0;
    440a:	4f 43       	clr.b	r15		
}
    440c:	21 52       	add	#4,	r1	;r2 As==10
    440e:	34 41       	pop	r4		
    4410:	30 41       	ret			

00004412 <setVolume>:

INT8S setVolume(INT8U cmd, INT8U nb) {
    4412:	04 12       	push	r4		
    4414:	21 82       	sub	#4,	r1	;r2 As==10
    4416:	04 41       	mov	r1,	r4	
    4418:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
    441c:	c4 4e 03 00 	mov.b	r14,	3(r4)	;0x0003(r4)

	INT16U data = (cmd << 8) | nb;
    4420:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    4424:	7f f3       	and.b	#-1,	r15	;r3 As==11
    4426:	8f 10       	swpb	r15		
    4428:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    442c:	0f de       	bis	r14,	r15	
    442e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	// Send command & data
	sendOverSPI(SPI_VOL, data, 16);
    4432:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    4436:	5f 43       	mov.b	#1,	r15	;r3 As==01
    4438:	4d 4e       	mov.b	r14,	r13	
    443a:	2e 44       	mov	@r4,	r14	
    443c:	b0 12 48 44 	call	#0x4448	

	return 0;
    4440:	4f 43       	clr.b	r15		
}
    4442:	21 52       	add	#4,	r1	;r2 As==10
    4444:	34 41       	pop	r4		
    4446:	30 41       	ret			

00004448 <sendOverSPI>:
/////////////////////////////////////////////////////////////////
// HELPERS /////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

// nbits=[1,15], nbits de poids faible
INT8S sendOverSPI(INT8U target, INT16U data, INT8U nbits) {
    4448:	04 12       	push	r4		
    444a:	31 82       	sub	#8,	r1	;r2 As==11
    444c:	04 41       	mov	r1,	r4	
    444e:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
    4452:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    4456:	c4 4d 06 00 	mov.b	r13,	6(r4)	;0x0006(r4)
	// Select SPI path
	if (target == SPI_FREQ) {
    445a:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    445e:	07 20       	jnz	$+16     	;abs 0x446e
		SEL_OFF;
    4460:	5f 42 35 00 	mov.b	&0x0035,r15	
    4464:	7f f0 7f 00 	and.b	#127,	r15	;#0x007f
    4468:	c2 4f 35 00 	mov.b	r15,	&0x0035	
    446c:	0c 3c       	jmp	$+26     	;abs 0x4486
	} else if(target == SPI_VOL) {
    446e:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    4472:	07 20       	jnz	$+16     	;abs 0x4482
		SEL_ON;
    4474:	5f 42 35 00 	mov.b	&0x0035,r15	
    4478:	7f d0 80 ff 	bis.b	#-128,	r15	;#0xff80
    447c:	c2 4f 35 00 	mov.b	r15,	&0x0035	
    4480:	02 3c       	jmp	$+6      	;abs 0x4486
	} else {
		return -1;
    4482:	7f 43       	mov.b	#-1,	r15	;r3 As==11
    4484:	57 3c       	jmp	$+176    	;abs 0x4534
	}

	// Three state gate : disable and re-enable output
	CS_ON;
    4486:	5f 42 35 00 	mov.b	&0x0035,r15	
    448a:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    448e:	c2 4f 35 00 	mov.b	r15,	&0x0035	
	Delayx100us(1);
    4492:	1e 43       	mov	#1,	r14	;r3 As==01
    4494:	0f 43       	clr	r15		
    4496:	b0 12 f0 40 	call	#0x40f0	
	CS_OFF;
    449a:	5f 42 35 00 	mov.b	&0x0035,r15	
    449e:	7f f0 bf ff 	and.b	#-65,	r15	;#0xffbf
    44a2:	c2 4f 35 00 	mov.b	r15,	&0x0035	

	INT8U currentBit;
	INT8U k = nbits;
    44a6:	d4 44 06 00 	mov.b	6(r4),	0(r4)	;0x0006(r4), 0x0000(r4)
    44aa:	00 00 
    44ac:	39 3c       	jmp	$+116    	;abs 0x4520
	while (k > 0)
	{
		currentBit = (data >> (k-1)) & 0x1;
    44ae:	6f 44       	mov.b	@r4,	r15	
    44b0:	0e 4f       	mov	r15,	r14	
    44b2:	3e 53       	add	#-1,	r14	;r3 As==11
    44b4:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    44b8:	0e 93       	tst	r14		
    44ba:	04 24       	jz	$+10     	;abs 0x44c4
    44bc:	12 c3       	clrc			
    44be:	0f 10       	rrc	r15		
    44c0:	1e 83       	dec	r14		
    44c2:	fc 23       	jnz	$-6      	;abs 0x44bc
    44c4:	4e 4f       	mov.b	r15,	r14	
    44c6:	5e f3       	and.b	#1,	r14	;r3 As==01
    44c8:	c4 4e 01 00 	mov.b	r14,	1(r4)	;0x0001(r4)
		if (currentBit)
    44cc:	c4 93 01 00 	tst.b	1(r4)		;0x0001(r4)
    44d0:	13 24       	jz	$+40     	;abs 0x44f8
		{
			// currentBit = 1
			P6OUT |=0x10;	// DIN=1 	SCLK=0	 CS=0
    44d2:	5f 42 35 00 	mov.b	&0x0035,r15	
    44d6:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    44da:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT |=0x20;	// SCLK=1
    44de:	5f 42 35 00 	mov.b	&0x0035,r15	
    44e2:	7f d0 20 00 	bis.b	#32,	r15	;#0x0020
    44e6:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT &=~0x20;	// SCLK=0
    44ea:	5f 42 35 00 	mov.b	&0x0035,r15	
    44ee:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    44f2:	c2 4f 35 00 	mov.b	r15,	&0x0035	
    44f6:	12 3c       	jmp	$+38     	;abs 0x451c
		}
		else
		{
			// currentBit = 0
			P6OUT &=~0x70;	// DIN=0 	SCLK=0	 CS=0
    44f8:	5f 42 35 00 	mov.b	&0x0035,r15	
    44fc:	7f f0 8f ff 	and.b	#-113,	r15	;#0xff8f
    4500:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT |=0x20;	// SCLK=1
    4504:	5f 42 35 00 	mov.b	&0x0035,r15	
    4508:	7f d0 20 00 	bis.b	#32,	r15	;#0x0020
    450c:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT &=~0x20;	// SCLK=0
    4510:	5f 42 35 00 	mov.b	&0x0035,r15	
    4514:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    4518:	c2 4f 35 00 	mov.b	r15,	&0x0035	
		}
		--k;
    451c:	f4 53 00 00 	add.b	#-1,	0(r4)	;r3 As==11, 0x0000(r4)
	Delayx100us(1);
	CS_OFF;

	INT8U currentBit;
	INT8U k = nbits;
	while (k > 0)
    4520:	c4 93 00 00 	tst.b	0(r4)		;0x0000(r4)
    4524:	c4 23       	jnz	$-118    	;abs 0x44ae
		}
		--k;
	}

	// Three state gate : disable output
	CS_ON;
    4526:	5f 42 35 00 	mov.b	&0x0035,r15	
    452a:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    452e:	c2 4f 35 00 	mov.b	r15,	&0x0035	
		SEL_ON;
	} else if(target == SPI_VOL) {
		SEL_OFF;
	}*/

	return 0;
    4532:	4f 43       	clr.b	r15		
}
    4534:	31 52       	add	#8,	r1	;r2 As==11
    4536:	34 41       	pop	r4		
    4538:	30 41       	ret			

0000453a <ModeStep>:
//} //----- fin de nom

//////////////////////////////////////////////////////////////////  PUBLIC
//---------------------------------------------------- Fonctions publiques

void ModeStep(INT16U event) {
    453a:	04 12       	push	r4		
    453c:	21 83       	decd	r1		
    453e:	04 41       	mov	r1,	r4	
    4540:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	switch (mode) {
    4544:	1f 42 02 02 	mov	&0x0202,r15	
    4548:	2f 93       	cmp	#2,	r15	;r3 As==10
    454a:	20 24       	jz	$+66     	;abs 0x458c
    454c:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4550:	05 2c       	jc	$+12     	;abs 0x455c
    4552:	0f 93       	tst	r15		
    4554:	09 24       	jz	$+20     	;abs 0x4568
    4556:	1f 93       	cmp	#1,	r15	;r3 As==01
    4558:	13 24       	jz	$+40     	;abs 0x4580
    455a:	33 3c       	jmp	$+104    	;abs 0x45c2
    455c:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4560:	1c 24       	jz	$+58     	;abs 0x459a
    4562:	2f 92       	cmp	#4,	r15	;r2 As==10
    4564:	21 24       	jz	$+68     	;abs 0x45a8
    4566:	2d 3c       	jmp	$+92     	;abs 0x45c2
	case VEILLE:
		if(event == CMD0) {
    4568:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    456c:	03 20       	jnz	$+8      	;abs 0x4574
			mode = MR_INIT;
    456e:	92 43 02 02 	mov	#1,	&0x0202	;r3 As==01
    4572:	27 3c       	jmp	$+80     	;abs 0x45c2
		} else if (event == CMD1) {
    4574:	94 93 00 00 	cmp	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    4578:	1d 20       	jnz	$+60     	;abs 0x45b4
			mode = MS;
    457a:	a2 42 02 02 	mov	#4,	&0x0202	;r2 As==10
    457e:	21 3c       	jmp	$+68     	;abs 0x45c2
		}
		break;
	case MR_INIT:
		if(event == MR_INIT_ACK) {
    4580:	a4 92 00 00 	cmp	#4,	0(r4)	;r2 As==10, 0x0000(r4)
    4584:	19 20       	jnz	$+52     	;abs 0x45b8
			mode = MR;
    4586:	a2 43 02 02 	mov	#2,	&0x0202	;r3 As==10
    458a:	1b 3c       	jmp	$+56     	;abs 0x45c2
		}
		break;
	case MR:
		if(event == CMD0) {
    458c:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    4590:	15 20       	jnz	$+44     	;abs 0x45bc
			mode = MR_FIN;
    4592:	b2 40 03 00 	mov	#3,	&0x0202	;#0x0003
    4596:	02 02 
    4598:	14 3c       	jmp	$+42     	;abs 0x45c2
		}
		break;
	case MR_FIN:
		if(event == MR_FIN_ACK) {
    459a:	b4 90 05 00 	cmp	#5,	0(r4)	;#0x0005, 0x0000(r4)
    459e:	00 00 
    45a0:	0f 20       	jnz	$+32     	;abs 0x45c0
			mode = VEILLE;
    45a2:	82 43 02 02 	mov	#0,	&0x0202	;r3 As==00
    45a6:	0d 3c       	jmp	$+28     	;abs 0x45c2
		}
		break;
	case MS:
		if(event == CMD1) {
    45a8:	94 93 00 00 	cmp	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    45ac:	0a 20       	jnz	$+22     	;abs 0x45c2
			mode = VEILLE;
    45ae:	82 43 02 02 	mov	#0,	&0x0202	;r3 As==00
    45b2:	07 3c       	jmp	$+16     	;abs 0x45c2
		if(event == CMD0) {
			mode = MR_INIT;
		} else if (event == CMD1) {
			mode = MS;
		}
		break;
    45b4:	03 43       	nop			
    45b6:	05 3c       	jmp	$+12     	;abs 0x45c2
	case MR_INIT:
		if(event == MR_INIT_ACK) {
			mode = MR;
		}
		break;
    45b8:	03 43       	nop			
    45ba:	03 3c       	jmp	$+8      	;abs 0x45c2
	case MR:
		if(event == CMD0) {
			mode = MR_FIN;
		}
		break;
    45bc:	03 43       	nop			
    45be:	01 3c       	jmp	$+4      	;abs 0x45c2
	case MR_FIN:
		if(event == MR_FIN_ACK) {
			mode = VEILLE;
		}
		break;
    45c0:	03 43       	nop			
		}
		break;
	default:
		break;
	}
}
    45c2:	21 53       	incd	r1		
    45c4:	34 41       	pop	r4		
    45c6:	30 41       	ret			

000045c8 <GestionMode>:


void GestionMode(void *parg) {
    45c8:	04 12       	push	r4		
    45ca:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    45ce:	04 41       	mov	r1,	r4	
    45d0:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)

		OS_EVENT *msgQServiceOutput = (OS_EVENT*) parg;
    45d4:	94 44 0a 00 	mov	10(r4),	2(r4)	;0x000a(r4), 0x0002(r4)
    45d8:	02 00 
		INT8U err;
		ServiceMsg data;

		for(;;) {

			data.serviceType = SERV_LCD;
    45da:	b4 40 03 00 	mov	#3,	4(r4)	;#0x0003, 0x0004(r4)
    45de:	04 00 
			data.val = 33;
    45e0:	b4 40 21 00 	mov	#33,	6(r4)	;#0x0021, 0x0006(r4)
    45e4:	06 00 

			err = OSQPost (msgQServiceOutput, (void *)&data);
    45e6:	0e 44       	mov	r4,	r14	
    45e8:	2e 52       	add	#4,	r14	;r2 As==10
    45ea:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    45ee:	b0 12 52 2f 	call	#0x2f52	
    45f2:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
			STATUS_LED_ON;
    45f6:	5f 42 29 00 	mov.b	&0x0029,r15	
    45fa:	6f c3       	bic.b	#2,	r15	;r3 As==10
    45fc:	c2 4f 29 00 	mov.b	r15,	&0x0029	
			OSTimeDly(2*OS_TICKS_PER_SEC);
    4600:	3f 40 c8 00 	mov	#200,	r15	;#0x00c8
    4604:	b0 12 ac 3a 	call	#0x3aac	
			STATUS_LED_OFF;
    4608:	5f 42 29 00 	mov.b	&0x0029,r15	
    460c:	6f d3       	bis.b	#2,	r15	;r3 As==10
    460e:	c2 4f 29 00 	mov.b	r15,	&0x0029	
    4612:	e3 3f       	jmp	$-56     	;abs 0x45da

00004614 <_unexpected_>:
    4614:	00 13       	reti			

00004616 <__udivmodsi4>:
    4616:	0f ef       	xor	r15,	r15	
    4618:	0e ee       	xor	r14,	r14	
    461a:	39 40 21 00 	mov	#33,	r9	;#0x0021
    461e:	0a 3c       	jmp	$+22     	;abs 0x4634
    4620:	08 10       	rrc	r8		
    4622:	0e 6e       	rlc	r14		
    4624:	0f 6f       	rlc	r15		
    4626:	0f 9b       	cmp	r11,	r15	
    4628:	05 28       	jnc	$+12     	;abs 0x4634
    462a:	02 20       	jnz	$+6      	;abs 0x4630
    462c:	0e 9a       	cmp	r10,	r14	
    462e:	02 28       	jnc	$+6      	;abs 0x4634
    4630:	0e 8a       	sub	r10,	r14	
    4632:	0f 7b       	subc	r11,	r15	
    4634:	0c 6c       	rlc	r12		
    4636:	0d 6d       	rlc	r13		
    4638:	08 68       	rlc	r8		
    463a:	19 83       	dec	r9		
    463c:	f1 23       	jnz	$-28     	;abs 0x4620
    463e:	30 41       	ret			

00004640 <__divmodsi4>:
    4640:	08 43       	clr	r8		
    4642:	3d b0 00 80 	bit	#-32768,r13	;#0x8000
    4646:	05 24       	jz	$+12     	;abs 0x4652
    4648:	3d e3       	inv	r13		
    464a:	3c e3       	inv	r12		
    464c:	1c 53       	inc	r12		
    464e:	0d 63       	adc	r13		
    4650:	28 d2       	bis	#4,	r8	;r2 As==10
    4652:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    4656:	05 24       	jz	$+12     	;abs 0x4662
    4658:	3b e3       	inv	r11		
    465a:	3a e3       	inv	r10		
    465c:	1a 53       	inc	r10		
    465e:	0b 63       	adc	r11		
    4660:	38 d2       	bis	#8,	r8	;r2 As==11
    4662:	b0 12 16 46 	call	#0x4616	
    4666:	08 10       	rrc	r8		
    4668:	28 b2       	bit	#4,	r8	;r2 As==10
    466a:	08 24       	jz	$+18     	;abs 0x467c
    466c:	3e e3       	inv	r14		
    466e:	3f e3       	inv	r15		
    4670:	1e 53       	inc	r14		
    4672:	0f 63       	adc	r15		
    4674:	3c e3       	inv	r12		
    4676:	3d e3       	inv	r13		
    4678:	1c 53       	inc	r12		
    467a:	0d 63       	adc	r13		
    467c:	38 b2       	bit	#8,	r8	;r2 As==11
    467e:	04 24       	jz	$+10     	;abs 0x4688
    4680:	3c e3       	inv	r12		
    4682:	3d e3       	inv	r13		
    4684:	1c 53       	inc	r12		
    4686:	0d 63       	adc	r13		
    4688:	30 41       	ret			

0000468a <__stop_progExec__>:
    468a:	ff 3f       	jmp	$+0      	;abs 0x468a

Disassembly of section .vectors:

0000ffe0 <InterruptVectors>:
    ffe0:	30 11 0c 13 30 11 30 11 52 12 30 11 ce 13 30 11     0...0.0.R.0...0.
    fff0:	30 11 30 11 30 11 30 11 30 11 30 11 30 11 00 11     0.0.0.0.0.0.0...
