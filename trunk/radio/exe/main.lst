
exe/main.elf:     file format elf32-msp430

SYMBOL TABLE:
00001100 l    d  .text	00000000 .text
00000200 l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
0000012e l       *ABS*	00000000 TA0IV
00000160 l       *ABS*	00000000 TA0CTL
00000170 l       *ABS*	00000000 TA0R
00000162 l       *ABS*	00000000 TA0CCTL0
00000164 l       *ABS*	00000000 TA0CCTL1
00000172 l       *ABS*	00000000 TA0CCR0
00000174 l       *ABS*	00000000 TA0CCR1
00000166 l       *ABS*	00000000 TA0CCTL2
00000176 l       *ABS*	00000000 TA0CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000190 l       *ABS*	00000000 TBR
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000004 l       *ABS*	00000000 ME1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000005 l       *ABS*	00000000 ME2
00000002 l       *ABS*	00000000 PUSH_BYTES
00001130 l       .text	00000000 _branch_to_unexpected_
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 main.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
0000012e l       *ABS*	00000000 TA0IV
00000160 l       *ABS*	00000000 TA0CTL
00000170 l       *ABS*	00000000 TA0R
00000162 l       *ABS*	00000000 TA0CCTL0
00000164 l       *ABS*	00000000 TA0CCTL1
00000172 l       *ABS*	00000000 TA0CCR0
00000174 l       *ABS*	00000000 TA0CCR1
00000166 l       *ABS*	00000000 TA0CCTL2
00000176 l       *ABS*	00000000 TA0CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000190 l       *ABS*	00000000 TBR
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000004 l       *ABS*	00000000 ME1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000005 l       *ABS*	00000000 ME2
00001370 l       .text	00000000 TA0_ISR
000013a0 l       .text	00000000 L1
000013bc l       .text	00000000 L2
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_core.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001c0c l     F .text	00000028 OS_InitMisc
00001c34 l     F .text	00000042 OS_InitRdyList
00001caa l     F .text	0000006c OS_InitTCBList
00001ba2 l     F .text	0000006a OS_InitEventList
00001c76 l     F .text	00000034 OS_InitTaskIdle
00000000 l    df *ABS*	00000000 os_flag.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00002602 l     F .text	000000fa OS_FlagBlock
00002766 l     F .text	000000a8 OS_FlagTaskRdy
00000000 l    df *ABS*	00000000 os_mbox.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_mem.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_mutex.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_q.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_sem.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_task.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 os_time.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Display.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 ServiceOutput.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 GestionMode.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 StatLogger.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 TraitementInput.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 g       *ABS*	00000000 __data_size
000013f0 g     F .text	00000010 OSTaskCreateHook
00003f78 g     F .text	00000084 InitOsc
00001654 g     F .text	00000022 OSIntEnter
000043b4 g     F .text	00000036 setVolume
00001418 g     F .text	00000008 OSTaskStatHook
0000030c g     O .bss	00000001 OSLockNesting
0000030d g     O .bss	00000001 OSRunning
000040fa g     F .text	00000094 SEND_CHAR
00003cc2 g     F .text	00000026 printString
000013e0 g     F .text	00000008 OSInitHookBegin
0000030e g     O .bss	00000004 OSIdleCtr
00001e5a g     F .text	000001f0 OS_TCBInit
00000312 g     O .bss	00000001 OSPrioHighRdy
00001400 g     F .text	00000010 OSTaskDelHook
0000462e g       .text	00000000 _etext
00003c9a g     F .text	00000018 clearDisplay
000012c2 g     F .text	00000000 OSStartHighRdy
000037de g     F .text	0000010a OSTaskCreateExt
00002434 g     F .text	0000002c OSFlagPendGetFlagsRdy
0000204a g     F .text	0000012a OSFlagAccept
00002d46 g     F .text	0000005c OSQFlush
00002b80 g     F .text	000000c4 OSQAccept
00003702 g     F .text	000000dc OSTaskCreate
000034c0 g     F .text	00000242 OSTaskChangePrio
000003a0 g       *ABS*	00000000 __bss_size
00000314 g     O .bss	00000012 OSFlagTbl
0000462c  w      .text	00000000 __stop_progExec__
00001130  w      .text	00000000 vector_ffe0
000040d4 g     F .text	00000026 _E
00001676 g     F .text	000000c2 OSIntExit
00000326 g     O .bss	00000001 OSPrioCur
00003dee g     F .text	0000018a printDecimal
000012ee g       .text	00000000 OSCtxSw
000043ea g     F .text	000000f2 sendOverSPI
0000456a g     F .text	0000004c GestionMode
00003d0e g     F .text	00000050 printByte
00000328 g     O .bss	00000002 OSTCBList
0000032a g     O .bss	00000001 OSTickStepState
00002ef4 g     F .text	000000dc OSQPost
0000280e g     F .text	00000068 OS_FlagUnlink
00001d40 g     F .text	0000003c OS_MemCopy
00001d7c g     F .text	000000a8 OS_Sched
0000032c g     O .bss	00000004 OSCtxSwCtr
00001370 g       .text	00000000 vector_ffec
00001518 g     F .text	00000008 OSTimeTickHook
00001130  w      .text	00000000 vector_fff0
0000462e g       *ABS*	00000000 __data_load_start
00003342 g     F .text	000000f6 OSSemPend
00001520 g     O .text	00000008 OSMapTbl
00001130 g       .text	00000000 __dtors_end
00001130  w      .text	00000000 vector_fffc
00001508 g     F .text	00000010 OSTCBInitHook
00002a50 g     F .text	00000084 OSMboxPost
00003c84 g     F .text	00000016 putch
000026fc g     F .text	0000006a OS_FlagInit
00001130  w      .text	00000000 vector_ffe4
0000326a g     F .text	0000005e OSSemAccept
00001340 g       .text	00000000 OSIntCtxSw
00003ce8 g     F .text	00000026 HexDigit
00000330 g     O .bss	00000002 OSTCBFreeList
0000ffe0 g     O .vectors	00000020 InterruptVectors
000044dc g     F .text	0000008e ModeStep
000042e4 g     F .text	0000007c ServiceOutput
00000202 g     O .bss	00000002 mode
00004092 g     F .text	00000042 Delayx100us
0000111c  w      .text	00000000 __do_clear_bss
00001d16 g     F .text	0000002a OS_MemClr
00001420 g     F .text	000000e0 OSTaskStkInit
000018dc g     F .text	00000142 OS_EventTaskRdy
00002da2 g     F .text	00000152 OSQPend
0000418e g     F .text	00000094 SEND_CMD
00003a4e g     F .text	00000084 OSTimeDly
00000332 g     O .bss	00000001 OSTaskCtr
00003ad2 g     F .text	0000019a OSTimeDlyHMSM
000012ae g       .text	00000000 vector_ffe2
00003438 g     F .text	00000088 OSSemPost
0000124e g       .text	00000000 vector_ffe8
000045b6  w      .text	00000000 _unexpected_
00001130  w      .text	00000000 vector_fffa
00004222 g     F .text	000000c2 InitLCD
00000334 g     O .bss	00000046 OSQTbl
00001100  w      .text	00000000 _reset_vector__
00001130 g       .text	00000000 __ctors_start
0000037a g     O .bss	00000002 OSTCBHighRdy
0000037c g     O .bss	00000002 OSQFreeList
0000110a  w      .text	00000000 __do_copy_data
0000124e g     F .text	00000060 ButtInterrupt
0000037e g     O .bss	00000001 OSRdyGrp
00000200 g       .bss	00000000 __bss_start
00001130  w      .text	00000000 vector_ffee
00001130  w      .text	00000000 vector_fff4
00000204 g     O .bss	00000002 count_int_me
00001146 g     F .text	00000108 main
00001130  w      .text	00000000 vector_fff8
00001528 g     O .text	00000100 OSUnMapTbl
00000200 g     O .bss	00000002 global_pb_gd
00001130  w      .text	00000000 vector_fff2
00002460 g     F .text	000001a2 OSFlagPost
00003c6c g     F .text	00000018 initDisplay
00001a1e g     F .text	000000b0 OS_EventTaskWait
00001738 g     F .text	00000066 OSStart
00002fd0 g     F .text	000000e4 OSQPostFront
00000380 g     O .bss	00000003 OSRdyTbl
00010000 g       .vectors	00000000 _vectors_end
00002c44 g     F .text	00000102 OSQCreate
000030b4 g     F .text	0000015c OSQPostOpt
0000179e g     F .text	00000132 OSTimeTick
00001130  w      .text	00000000 vector_ffe6
000032c8 g     F .text	0000007a OSSemCreate
00003ffc g     F .text	00000056 InitPorts
00002174 g     F .text	0000008e OSFlagCreate
00000206 g     O .bss	00000002 StkServiceOutput
00000384 g     O .bss	00000002 OSEventFreeList
00003d5e g     F .text	00000090 printHex
00001100  w      .text	00000000 __init_stack
00002202 g     F .text	00000232 OSFlagPend
00000208 g     O .bss	00000002 StkGestionMode
00004052 g     F .text	00000040 Delay
0000020a g     O .bss	00000080 TaskStartStk2
000013e8 g     F .text	00000008 OSInitHookEnd
00001130 g       .text	00000000 __dtors_start
00001130 g       .text	00000000 __ctors_end
000045e2 g       .text	00000000 __divmodsi4
00000a00 g       *ABS*	00000000 __stack
000028c0 g     F .text	00000078 OSMboxCreate
000013dc g     F .text	00000000 OSCPURestoreSR
00000200 g       .text	00000000 _edata
000005a0 g       .bss	00000000 _end
00000386 g     O .bss	00000001 OSIntNesting
0000028a g     O .bss	00000080 TaskStartStk
000013d6 g     F .text	00000000 OSCPUSaveSR
00002938 g     F .text	00000118 OSMboxPend
000038e8 g     F .text	00000118 OSTaskStkChk
00000388 g     O .bss	00000002 OSTCBCur
00004360 g     F .text	00000054 setFrequency
000045b8 g       .text	00000000 __udivmodsi4
00002876 g     F .text	0000004a OSMboxAccept
00001628 g     F .text	0000002c OSInit
00001ace g     F .text	00000092 OS_EventTO
00003210 g     F .text	0000005a OS_QInit
00001130  w      .text	00000000 vector_fff6
000012ae g     F .text	00000014 TelInterrupt
0000038a g     O .bss	00000080 OSTaskIdleStk
00002ad4 g     F .text	000000ac OSMboxPostOpt
00001500 g     F .text	00000008 OSTaskSwHook
0000040a g     O .bss	00000032 OSEventTbl
00001104  w      .text	00000000 __low_level_init
0000043c g     O .bss	00000138 OSTCBTbl
0000112c  w      .text	00000000 __jump_to_main
00003cb2 g     F .text	00000010 gotoSecondLine
00000200 g       .text	00000000 __data_start
00000574 g     O .bss	00000002 OSFlagFreeList
00000576 g     O .bss	0000002a OSTCBPrioTbl
00000120  w      *ABS*	00000000 __WDTCTL
0000030a g     O .bss	00000002 OSISRStkPtr
00001130  w      .text	00000000 vector_ffea
000018d0 g     F .text	0000000c OSVersion
00003a00 g     F .text	0000004e OS_TaskStkClr
00001b60 g     F .text	00000042 OS_EventWaitListInit
00001410 g     F .text	00000008 OSTaskIdleHook
00001e24 g     F .text	00000036 OS_TaskIdle



Disassembly of section .text:

00001100 <__init_stack>:
    1100:	31 40 00 0a 	mov	#2560,	r1	;#0x0a00

00001104 <__low_level_init>:
    1104:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    1108:	20 01 

0000110a <__do_copy_data>:
    110a:	3f 40 00 00 	mov	#0,	r15	;#0x0000
    110e:	0f 93       	tst	r15		
    1110:	05 24       	jz	$+12     	;abs 0x111c
    1112:	2f 83       	decd	r15		
    1114:	9f 4f 2e 46 	mov	17966(r15),512(r15);0x462e(r15), 0x0200(r15)
    1118:	00 02 
    111a:	fb 23       	jnz	$-8      	;abs 0x1112

0000111c <__do_clear_bss>:
    111c:	3f 40 a0 03 	mov	#928,	r15	;#0x03a0
    1120:	0f 93       	tst	r15		
    1122:	04 24       	jz	$+10     	;abs 0x112c
    1124:	1f 83       	dec	r15		
    1126:	cf 43 00 02 	mov.b	#0,	512(r15);r3 As==00, 0x0200(r15)
    112a:	fc 23       	jnz	$-6      	;abs 0x1124

0000112c <__jump_to_main>:
    112c:	30 40 46 11 	br	#0x1146	

00001130 <__ctors_end>:
    1130:	30 40 b6 45 	br	#0x45b6	
    1134:	53 74       	.word	0x7453;	????	Illegal as 2-op instr
    1136:	61 72       	subc.b	#4,	r1	;r2 As==10
    1138:	74 69       	addc.b	@r9+,	r4	
    113a:	6e 67       	addc.b	@r7,	r14	
    113c:	00 53       	add	#0,	r0	;r3 As==00
    113e:	74 61       	addc.b	@r1+,	r4	
    1140:	72 74       	subc.b	@r4+,	r2	
    1142:	20 4f       	br	@r15		
    1144:	53 00       	.word	0x0053;	????	

00001146 <main>:
 *********************************************************************************************************
 *                                                MAIN
 *********************************************************************************************************
 */

int main(void) {
    1146:	31 40 e8 09 	mov	#2536,	r1	;#0x09e8
    114a:	04 41       	mov	r1,	r4	

	WDTCTL = WDTCTL_INIT; //Init watchdog timer
    114c:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    1150:	20 01 

	P6OUT = P1OUT_INIT; //Init output data of port1
    1152:	c2 43 35 00 	mov.b	#0,	&0x0035	;r3 As==00
	P6OUT = P1OUT_INIT; //Init output data of port2
    1156:	c2 43 35 00 	mov.b	#0,	&0x0035	;r3 As==00

	P6SEL = P1SEL_INIT; //Select port or module -function on port1
    115a:	c2 43 37 00 	mov.b	#0,	&0x0037	;r3 As==00
	P6SEL = P2SEL_INIT; //Select port or module -function on port2
    115e:	c2 43 37 00 	mov.b	#0,	&0x0037	;r3 As==00

	P6DIR = P1DIR_INIT; //Init port direction register of port1
    1162:	f2 43 36 00 	mov.b	#-1,	&0x0036	;r3 As==11
	P6DIR = P2DIR_INIT; //Init port direction register of port2
    1166:	f2 43 36 00 	mov.b	#-1,	&0x0036	;r3 As==11

	P1IES = P1IES_INIT; //init port interrupts
    116a:	d2 43 24 00 	mov.b	#1,	&0x0024	;r3 As==01
	P2IES = P2IES_INIT;
    116e:	c2 43 2c 00 	mov.b	#0,	&0x002c	;r3 As==00
	P1IE = 0xff;
    1172:	f2 43 25 00 	mov.b	#-1,	&0x0025	;r3 As==11
	P2IE = P2IE_INIT;
    1176:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00
// changement au vue de tournier , 3 lignes
	P2SEL = 0;
    117a:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00
	P2OUT = 0;
    117e:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00
	P2DIR = ~BIT0; //only P2.0 is input
    1182:	f2 40 fe ff 	mov.b	#-2,	&0x002a	;#0xfffe
    1186:	2a 00 

	/*Initialisation ineruptions Buttons et Irda*/

	//Pour avoir les pins en interruptions, il faut configurer
	P1SEL = 0; //
    1188:	c2 43 26 00 	mov.b	#0,	&0x0026	;r3 As==00
	P2SEL = 0; // sélection "input/output" (0) au lieu de "périphérique" (1)
    118c:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00
	P1DIR = ~BIT0;
    1190:	f2 40 fe ff 	mov.b	#-2,	&0x0022	;#0xfffe
    1194:	22 00 
	P2DIR = ~BIT0;
    1196:	f2 40 fe ff 	mov.b	#-2,	&0x002a	;#0xfffe
    119a:	2a 00 
	P1IES = 1;
    119c:	d2 43 24 00 	mov.b	#1,	&0x0024	;r3 As==01
	P2IES = 0; //-> savoir si c'est un front montant (0) ou descendant (1)
    11a0:	c2 43 2c 00 	mov.b	#0,	&0x002c	;r3 As==00
	P1IFG = 0;
    11a4:	c2 43 23 00 	mov.b	#0,	&0x0023	;r3 As==00
	P2IFG = 0;
    11a8:	c2 43 2b 00 	mov.b	#0,	&0x002b	;r3 As==00
	//	il faut utiliser eint(); pour enable global interrupt, P1IE = 1 et P2IE = 1
	/*Fin initialisation*/

	eint();
    11ac:	32 d2       	eint			
	InitPorts();
    11ae:	b0 12 fc 3f 	call	#0x3ffc	
	initDisplay();
    11b2:	b0 12 6c 3c 	call	#0x3c6c	
	clearDisplay();
    11b6:	b0 12 9a 3c 	call	#0x3c9a	
	printString("Starting");
    11ba:	3f 40 34 11 	mov	#4404,	r15	;#0x1134
    11be:	b0 12 c2 3c 	call	#0x3cc2	

	WDTCTL = WDTPW + WDTHOLD; /* Disable the watchdog timer   */
    11c2:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    11c6:	20 01 
	//   P6DIR = 0x01;                       /* P1.0 is the only output.     */
	//  P6OUT = 0x00;                       /* P1.0 initially low.          */

	// TIMERA Configuration             /* Configure TIMERA for the system Tick source. */
	//
	TACTL = TASSEL1 + TACLR; /* Clear the Timer and set SMCLK as the source. */
    11c8:	b2 40 04 02 	mov	#516,	&0x0160	;#0x0204
    11cc:	60 01 
	TACTL |= 0x00C0; /* Input divider is /8.  		*/
    11ce:	1f 42 60 01 	mov	&0x0160,r15	
    11d2:	3f d0 c0 00 	bis	#192,	r15	;#0x00c0
    11d6:	82 4f 60 01 	mov	r15,	&0x0160	
	TACCTL0 = CCIE; /* Enable the TACCR0 interrupt. */
    11da:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    11de:	62 01 
	TACCR0 = 2304; /* Load the TACCR0 register.    	*/
    11e0:	b2 40 00 09 	mov	#2304,	&0x0172	;#0x0900
    11e4:	72 01 

	OSInit(); /* Initialize uC/OS-II                     */
    11e6:	b0 12 28 16 	call	#0x1628	

	/*  P6OUT = 0;*/

	void *CommMsg[10];
	OS_EVENT *msgQServiceOutput = OSQCreate(&CommMsg[0], 10);
    11ea:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    11ee:	0f 44       	mov	r4,	r15	
    11f0:	2f 52       	add	#4,	r15	;r2 As==10
    11f2:	b0 12 44 2c 	call	#0x2c44	
    11f6:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	INT8U prio = 0;
    11fa:	c4 43 00 00 	mov.b	#0,	0(r4)	;r3 As==00, 0x0000(r4)

	OSTaskCreate(GestionMode, (void *) msgQServiceOutput,
    11fe:	3e 40 08 03 	mov	#776,	r14	;#0x0308
    1202:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1206:	6c 44       	mov.b	@r4,	r12	
    1208:	0d 4e       	mov	r14,	r13	
    120a:	0e 4f       	mov	r15,	r14	
    120c:	3f 40 6a 45 	mov	#17770,	r15	;#0x456a
    1210:	b0 12 02 37 	call	#0x3702	
			&TaskStartStk[TASK_STK_SIZE - 1], prio);

	prio = 5;
    1214:	f4 40 05 00 	mov.b	#5,	0(r4)	;#0x0005, 0x0000(r4)
    1218:	00 00 

	OSTaskCreate(ServiceOutput, (void *) msgQServiceOutput,
    121a:	3e 40 88 02 	mov	#648,	r14	;#0x0288
    121e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1222:	6c 44       	mov.b	@r4,	r12	
    1224:	0d 4e       	mov	r14,	r13	
    1226:	0e 4f       	mov	r15,	r14	
    1228:	3f 40 e4 42 	mov	#17124,	r15	;#0x42e4
    122c:	b0 12 02 37 	call	#0x3702	
			&TaskStartStk2[TASK_STK_SIZE - 1], prio);
	clearDisplay();
    1230:	b0 12 9a 3c 	call	#0x3c9a	
	printString("Start OS");
    1234:	3f 40 3d 11 	mov	#4413,	r15	;#0x113d
    1238:	b0 12 c2 3c 	call	#0x3cc2	
	count_int_me = 0;
    123c:	82 43 04 02 	mov	#0,	&0x0204	;r3 As==00
	OSStart();
    1240:	b0 12 38 17 	call	#0x1738	
	return (0);
    1244:	0f 43       	clr	r15		
}
    1246:	31 50 18 00 	add	#24,	r1	;#0x0018
    124a:	30 40 2c 46 	br	#0x462c	

0000124e <ButtInterrupt>:
 *********************************************************************************************************
 *                                            STARTUP TASK
 *********************************************************************************************************
 */

interrupt (PORT1_VECTOR) ButtInterrupt(void) {
    124e:	0f 12       	push	r15		
    1250:	0e 12       	push	r14		
    1252:	0d 12       	push	r13		
    1254:	0c 12       	push	r12		
    1256:	04 12       	push	r4		
    1258:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    125c:	04 41       	mov	r1,	r4	
	INT16U poll = 0;
    125e:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
	INT8U P4Buffer;
	InputEvent Message;
	OS_CPU_SR cpu_sr = 0;
    1262:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)

	OS_ENTER_CRITICAL();
    1266:	b0 12 d6 13 	call	#0x13d6	
    126a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	OSIntEnter();
    126e:	b0 12 54 16 	call	#0x1654	

	//désactiver les interruptions
	P1IE = 0;
    1272:	c2 43 25 00 	mov.b	#0,	&0x0025	;r3 As==00

	//remise du sémaphore à 0
	P1IFG = 0;
    1276:	c2 43 23 00 	mov.b	#0,	&0x0023	;r3 As==00
	clearDisplay();
    127a:	b0 12 9a 3c 	call	#0x3c9a	
	printDecimal(count_int_me++);
    127e:	1f 42 04 02 	mov	&0x0204,r15	
    1282:	0e 4f       	mov	r15,	r14	
    1284:	1f 53       	inc	r15		
    1286:	82 4f 04 02 	mov	r15,	&0x0204	
    128a:	0f 4e       	mov	r14,	r15	
    128c:	b0 12 ee 3d 	call	#0x3dee	
//	} while (Message.bEvent == 65535);

	//todo:les transmettre par MailBox ou MessageQueue au TraitementInput

	//réactiver les interruptions
	P1IE = 0xFF;
    1290:	f2 43 25 00 	mov.b	#-1,	&0x0025	;r3 As==11
	OSIntExit();
    1294:	b0 12 76 16 	call	#0x1676	
	OS_EXIT_CRITICAL();
    1298:	2f 44       	mov	@r4,	r15	
    129a:	b0 12 dc 13 	call	#0x13dc	
}
    129e:	31 50 0a 00 	add	#10,	r1	;#0x000a
    12a2:	34 41       	pop	r4		
    12a4:	3c 41       	pop	r12		
    12a6:	3d 41       	pop	r13		
    12a8:	3e 41       	pop	r14		
    12aa:	3f 41       	pop	r15		
    12ac:	00 13       	reti			

000012ae <TelInterrupt>:

//todo: a finir
interrupt (PORT2_VECTOR) TelInterrupt(void) {
    12ae:	04 12       	push	r4		
    12b0:	04 41       	mov	r1,	r4	
	//désactiver les interruptions
	P2IE = 0;
    12b2:	c2 43 2d 00 	mov.b	#0,	&0x002d	;r3 As==00

	//remise des sémaphores à 0
	P2IFG = 0;
    12b6:	c2 43 2b 00 	mov.b	#0,	&0x002b	;r3 As==00
	//récupération des infos -> lesquelles et comment? Comment marche la liaison série?

	//transmission par MB ou MQ au traitement input

	//réactiver les interruptions
	P2IE = 1;
    12ba:	d2 43 2d 00 	mov.b	#1,	&0x002d	;r3 As==01
}
    12be:	34 41       	pop	r4		
    12c0:	00 13       	reti			

000012c2 <OSStartHighRdy>:

	.global OSStartHighRdy
	.type OSStartHighRdy, @function

OSStartHighRdy:	
            call     #OSTaskSwHook
    12c2:	b0 12 00 15 	call	#0x1500	

            mov.b    #1, &OSRunning         /* kernel running */
    12c6:	d2 43 0d 03 	mov.b	#1,	&0x030d	;r3 As==01

            mov.w    r1, &OSISRStkPtr       /* save interrupt stack  */            
    12ca:	82 41 0a 03 	mov	r1,	&0x030a	

            mov.w    &OSTCBHighRdy, r13     /* load highest ready task stack  */
    12ce:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w    @r13, r1
    12d2:	21 4d       	mov	@r13,	r1	

            POPALL							/* Restore all the registers.  */
    12d4:	3f 41       	pop	r15		
    12d6:	3e 41       	pop	r14		
    12d8:	3d 41       	pop	r13		
    12da:	3c 41       	pop	r12		
    12dc:	3b 41       	pop	r11		
    12de:	3a 41       	pop	r10		
    12e0:	39 41       	pop	r9		
    12e2:	38 41       	pop	r8		
    12e4:	37 41       	pop	r7		
    12e6:	36 41       	pop	r6		
    12e8:	35 41       	pop	r5		
    12ea:	34 41       	pop	r4		
                    
            reti                            /* emulate return from interrupt  */
    12ec:	00 13       	reti			

000012ee <OSCtxSw>:
;********************************************************************************************************
*/

.global OSCtxSw
OSCtxSw:
            push      r2                    /* emulate interrupt by also saving the SR */
    12ee:	02 12       	push	r2		
            
            PUSHALL							/* Save all the task registers.  */
    12f0:	04 12       	push	r4		
    12f2:	05 12       	push	r5		
    12f4:	06 12       	push	r6		
    12f6:	07 12       	push	r7		
    12f8:	08 12       	push	r8		
    12fa:	09 12       	push	r9		
    12fc:	0a 12       	push	r10		
    12fe:	0b 12       	push	r11		
    1300:	0c 12       	push	r12		
    1302:	0d 12       	push	r13		
    1304:	0e 12       	push	r14		
    1306:	0f 12       	push	r15		
            
            mov.w     &OSTCBCur, r13        /* OSTCBCur->OSTCBStkPtr = SP  */
    1308:	1d 42 88 03 	mov	&0x0388,r13	
            mov.w     r1, 0(r13)
    130c:	8d 41 00 00 	mov	r1,	0(r13)	;0x0000(r13)

            call      #OSTaskSwHook
    1310:	b0 12 00 15 	call	#0x1500	

            mov.b     &OSPrioHighRdy, r13   /*  OSPrioCur = OSPrioHighRdy  */
    1314:	5d 42 12 03 	mov.b	&0x0312,r13	
            mov.b     r13, &OSPrioCur       /*                             */
    1318:	c2 4d 26 03 	mov.b	r13,	&0x0326	
                          
            mov.w     &OSTCBHighRdy, r13    /* OSTCBCur  = OSTCBHighRdy    */
    131c:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w     r13, &OSTCBCur        /*                             */
    1320:	82 4d 88 03 	mov	r13,	&0x0388	
                          
            mov.w     @r13, r1              /*  SP        = OSTCBHighRdy->OSTCBStkPtr  */
    1324:	21 4d       	mov	@r13,	r1	
             
            POPALL							/* Restore the new task registers.  */
    1326:	3f 41       	pop	r15		
    1328:	3e 41       	pop	r14		
    132a:	3d 41       	pop	r13		
    132c:	3c 41       	pop	r12		
    132e:	3b 41       	pop	r11		
    1330:	3a 41       	pop	r10		
    1332:	39 41       	pop	r9		
    1334:	38 41       	pop	r8		
    1336:	37 41       	pop	r7		
    1338:	36 41       	pop	r6		
    133a:	35 41       	pop	r5		
    133c:	34 41       	pop	r4		
            
            reti                            /* return from interrup  */
    133e:	00 13       	reti			

00001340 <OSIntCtxSw>:

.global OSIntCtxSw

OSIntCtxSw:
             
            call      #OSTaskSwHook
    1340:	b0 12 00 15 	call	#0x1500	

            mov.b     &OSPrioHighRdy, r13   /* OSPrioCur = OSPrioHighRdy */
    1344:	5d 42 12 03 	mov.b	&0x0312,r13	
            mov.b     r13, &OSPrioCur       
    1348:	c2 4d 26 03 	mov.b	r13,	&0x0326	
                          
            mov.w     &OSTCBHighRdy, r13    /* OSTCBCur  = OSTCBHighRdy  */
    134c:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w     r13, &OSTCBCur
    1350:	82 4d 88 03 	mov	r13,	&0x0388	
                          
            mov.w     @r13, r1              /* SP        = OSTCBHighRdy->OSTCBStkPtr */
    1354:	21 4d       	mov	@r13,	r1	
             
            POPALL							/* Restore the registers.  */
    1356:	3f 41       	pop	r15		
    1358:	3e 41       	pop	r14		
    135a:	3d 41       	pop	r13		
    135c:	3c 41       	pop	r12		
    135e:	3b 41       	pop	r11		
    1360:	3a 41       	pop	r10		
    1362:	39 41       	pop	r9		
    1364:	38 41       	pop	r8		
    1366:	37 41       	pop	r7		
    1368:	36 41       	pop	r6		
    136a:	35 41       	pop	r5		
    136c:	34 41       	pop	r4		
             
            reti                            /* return from interrup */
    136e:	00 13       	reti			

00001370 <vector_ffec>:
;********************************************************************************************************
*/

interrupt(TIMERA0_VECTOR)
TA0_ISR:                                    /* TIMERA0 timer ISR */
            PUSHALL
    1370:	04 12       	push	r4		
    1372:	05 12       	push	r5		
    1374:	06 12       	push	r6		
    1376:	07 12       	push	r7		
    1378:	08 12       	push	r8		
    137a:	09 12       	push	r9		
    137c:	0a 12       	push	r10		
    137e:	0b 12       	push	r11		
    1380:	0c 12       	push	r12		
    1382:	0d 12       	push	r13		
    1384:	0e 12       	push	r14		
    1386:	0f 12       	push	r15		
                        
            add.w	 #2304, &TACCR0			/* Reset the Timer Period*/
    1388:	b2 50 00 09 	add	#2304,	&0x0172	;#0x0900
    138c:	72 01 
                         
            cmp.b    #0, &OSIntNesting      /* if (OSIntNesting == 0)  */
    138e:	c2 93 86 03 	tst.b	&0x0386	
            jne      L1
    1392:	06 20       	jnz	$+14     	;abs 0x13a0
                               
            mov.w    &OSTCBCur, r13         /* save task stack */
    1394:	1d 42 88 03 	mov	&0x0388,r13	
            mov.w    r1, 0(r13)
    1398:	8d 41 00 00 	mov	r1,	0(r13)	;0x0000(r13)

            mov.w    &OSISRStkPtr, r1       /* load interrupt stack  */
    139c:	11 42 0a 03 	mov	&0x030a,r1	

000013a0 <L1>:

L1:
            inc.b    &OSIntNesting          /* increase OSIntNesting */
    13a0:	d2 53 86 03 	inc.b	&0x0386	
             
            EINT                           /* enable general interrupt to allow for interrupt nesting */
    13a4:	32 d2       	eint			

            call     #OSTimeTick            /* call ticks routine       */
    13a6:	b0 12 9e 17 	call	#0x179e	

            DINT                           /* IMPORTANT: disable general interrupt BEFORE calling OSIntExit() */
    13aa:	32 c2       	dint			

            call     #OSIntExit             /* call ticks routine */
    13ac:	b0 12 76 16 	call	#0x1676	

            cmp.b    #0, &OSIntNesting      /* if (OSIntNesting == 0) */ 
    13b0:	c2 93 86 03 	tst.b	&0x0386	
            jne      L2
    13b4:	03 20       	jnz	$+8      	;abs 0x13bc

            mov.w    &OSTCBHighRdy, r13     /* restore task stack SP */
    13b6:	1d 42 7a 03 	mov	&0x037a,r13	
            mov.w    @r13, r1
    13ba:	21 4d       	mov	@r13,	r1	

000013bc <L2>:
                       
L2:
			POPALL
    13bc:	3f 41       	pop	r15		
    13be:	3e 41       	pop	r14		
    13c0:	3d 41       	pop	r13		
    13c2:	3c 41       	pop	r12		
    13c4:	3b 41       	pop	r11		
    13c6:	3a 41       	pop	r10		
    13c8:	39 41       	pop	r9		
    13ca:	38 41       	pop	r8		
    13cc:	37 41       	pop	r7		
    13ce:	36 41       	pop	r6		
    13d0:	35 41       	pop	r5		
    13d2:	34 41       	pop	r4		

            reti                            ; return from interrupt
    13d4:	00 13       	reti			

000013d6 <OSCPUSaveSR>:
*/

.global OSCPUSaveSR
.type OSCPUSaveSR, @function
OSCPUSaveSR:
            MOV.W    r2,r15			/* gcc returns the value of the sr in r15 */
    13d6:	0f 42       	mov	r2,	r15	
            DINT
    13d8:	32 c2       	dint			
            RET
    13da:	30 41       	ret			

000013dc <OSCPURestoreSR>:

.global OSCPURestoreSR
.type OSCPURestoreSR, @function
OSCPURestoreSR:
            MOV.W    r15,r2			/* gcc passes the sr in r15 */
    13dc:	02 4f       	mov	r15,	r2	
            RET
    13de:	30 41       	ret			

000013e0 <OSInitHookBegin>:
* Note(s)    : 1) Interrupts should be disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSInitHookBegin (void)
{
    13e0:	04 12       	push	r4		
    13e2:	04 41       	mov	r1,	r4	
}
    13e4:	34 41       	pop	r4		
    13e6:	30 41       	ret			

000013e8 <OSInitHookEnd>:
* Note(s)    : 1) Interrupts should be disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSInitHookEnd (void)
{
    13e8:	04 12       	push	r4		
    13ea:	04 41       	mov	r1,	r4	
}
    13ec:	34 41       	pop	r4		
    13ee:	30 41       	ret			

000013f0 <OSTaskCreateHook>:
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 
void  OSTaskCreateHook (OS_TCB *ptcb)
{
    13f0:	04 12       	push	r4		
    13f2:	21 83       	decd	r1		
    13f4:	04 41       	mov	r1,	r4	
    13f6:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
    13fa:	21 53       	incd	r1		
    13fc:	34 41       	pop	r4		
    13fe:	30 41       	ret			

00001400 <OSTaskDelHook>:
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 
void  OSTaskDelHook (OS_TCB *ptcb)
{
    1400:	04 12       	push	r4		
    1402:	21 83       	decd	r1		
    1404:	04 41       	mov	r1,	r4	
    1406:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
    140a:	21 53       	incd	r1		
    140c:	34 41       	pop	r4		
    140e:	30 41       	ret			

00001410 <OSTaskIdleHook>:
* Note(s)    : 1) Interrupts are enabled during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION >= 251
void  OSTaskIdleHook (void)
{
    1410:	04 12       	push	r4		
    1412:	04 41       	mov	r1,	r4	
#if 0
    LPM0;                                         /* Enter low power mode                              */
#endif    
}
    1414:	34 41       	pop	r4		
    1416:	30 41       	ret			

00001418 <OSTaskStatHook>:
*********************************************************************************************************
*/

#if OS_CPU_HOOKS_EN > 0 
void  OSTaskStatHook (void)
{
    1418:	04 12       	push	r4		
    141a:	04 41       	mov	r1,	r4	
}
    141c:	34 41       	pop	r4		
    141e:	30 41       	ret			

00001420 <OSTaskStkInit>:
*                 }
*********************************************************************************************************
*/

OS_STK  *OSTaskStkInit (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT16U opt)
{
    1420:	04 12       	push	r4		
    1422:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    1426:	04 41       	mov	r1,	r4	
    1428:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    142c:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    1430:	84 4d 06 00 	mov	r13,	6(r4)	;0x0006(r4)
    1434:	84 4c 08 00 	mov	r12,	8(r4)	;0x0008(r4)
    INT16U  *top;


    opt    = opt;                 
    top    = (INT16U *)ptos;
    1438:	94 44 06 00 	mov	6(r4),	0(r4)	;0x0006(r4), 0x0000(r4)
    143c:	00 00 
    top--;  
    143e:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)task;
    1442:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    1446:	2f 44       	mov	@r4,	r15	
    1448:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    top--;
    144c:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)task;                          /* Interrupt return pointer                          */
    1450:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    1454:	2f 44       	mov	@r4,	r15	
    1456:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    top--;
    145a:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0008;                        /* Status register                                   */
    145e:	2f 44       	mov	@r4,	r15	
    1460:	bf 42 00 00 	mov	#8,	0(r15)	;r2 As==11, 0x0000(r15)
    top--;
    1464:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0404;
    1468:	2f 44       	mov	@r4,	r15	
    146a:	bf 40 04 04 	mov	#1028,	0(r15)	;#0x0404, 0x0000(r15)
    146e:	00 00 
    top--;
    1470:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0505;
    1474:	2f 44       	mov	@r4,	r15	
    1476:	bf 40 05 05 	mov	#1285,	0(r15)	;#0x0505, 0x0000(r15)
    147a:	00 00 
    top--;
    147c:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0606;
    1480:	2f 44       	mov	@r4,	r15	
    1482:	bf 40 06 06 	mov	#1542,	0(r15)	;#0x0606, 0x0000(r15)
    1486:	00 00 
    top--;
    1488:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0707;
    148c:	2f 44       	mov	@r4,	r15	
    148e:	bf 40 07 07 	mov	#1799,	0(r15)	;#0x0707, 0x0000(r15)
    1492:	00 00 
    top--;
    1494:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0808;
    1498:	2f 44       	mov	@r4,	r15	
    149a:	bf 40 08 08 	mov	#2056,	0(r15)	;#0x0808, 0x0000(r15)
    149e:	00 00 
    top--;
    14a0:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x0909;
    14a4:	2f 44       	mov	@r4,	r15	
    14a6:	bf 40 09 09 	mov	#2313,	0(r15)	;#0x0909, 0x0000(r15)
    14aa:	00 00 
    top--;
    14ac:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1010;
    14b0:	2f 44       	mov	@r4,	r15	
    14b2:	bf 40 10 10 	mov	#4112,	0(r15)	;#0x1010, 0x0000(r15)
    14b6:	00 00 
    top--;
    14b8:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1111;
    14bc:	2f 44       	mov	@r4,	r15	
    14be:	bf 40 11 11 	mov	#4369,	0(r15)	;#0x1111, 0x0000(r15)
    14c2:	00 00 
    top--;
    14c4:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1212;           /* IAR Only */  /* Pass 'p_arg' through register R12                 */
    14c8:	2f 44       	mov	@r4,	r15	
    14ca:	bf 40 12 12 	mov	#4626,	0(r15)	;#0x1212, 0x0000(r15)
    14ce:	00 00 
    top--;
    14d0:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1313;
    14d4:	2f 44       	mov	@r4,	r15	
    14d6:	bf 40 13 13 	mov	#4883,	0(r15)	;#0x1313, 0x0000(r15)
    14da:	00 00 
    top--;
    14dc:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)0x1414;                         
    14e0:	2f 44       	mov	@r4,	r15	
    14e2:	bf 40 14 14 	mov	#5140,	0(r15)	;#0x1414, 0x0000(r15)
    14e6:	00 00 
    top--;
    14e8:	a4 83 00 00 	decd	0(r4)		;0x0000(r4)
    *top = (INT16U)p_arg;           /* GCC uses r15 */
    14ec:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    14f0:	2f 44       	mov	@r4,	r15	
    14f2:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    return ((OS_STK *)top);    
    14f6:	2f 44       	mov	@r4,	r15	
}
    14f8:	31 50 0a 00 	add	#10,	r1	;#0x000a
    14fc:	34 41       	pop	r4		
    14fe:	30 41       	ret			

00001500 <OSTaskSwHook>:
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0
void  OSTaskSwHook (void)
{
    1500:	04 12       	push	r4		
    1502:	04 41       	mov	r1,	r4	
}
    1504:	34 41       	pop	r4		
    1506:	30 41       	ret			

00001508 <OSTCBInitHook>:
* Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0 && OS_VERSION > 203
void  OSTCBInitHook (OS_TCB *ptcb)
{
    1508:	04 12       	push	r4		
    150a:	21 83       	decd	r1		
    150c:	04 41       	mov	r1,	r4	
    150e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = ptcb;                                           /* Prevent Compiler warning                 */
}
    1512:	21 53       	incd	r1		
    1514:	34 41       	pop	r4		
    1516:	30 41       	ret			

00001518 <OSTimeTickHook>:
* Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
*********************************************************************************************************
*/
#if OS_CPU_HOOKS_EN > 0
void  OSTimeTickHook (void)
{
    1518:	04 12       	push	r4		
    151a:	04 41       	mov	r1,	r4	
}
    151c:	34 41       	pop	r4		
    151e:	30 41       	ret			

00001520 <OSMapTbl>:
    1520:	01 02 04 08 10 20 40 80                             ..... @.

00001528 <OSUnMapTbl>:
    1528:	00 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1538:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1548:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1558:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1568:	06 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1578:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1588:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1598:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15a8:	07 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15b8:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15c8:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15d8:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15e8:	06 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    15f8:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1608:	05 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................
    1618:	04 00 01 00 02 00 01 00 03 00 01 00 02 00 01 00     ................

00001628 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
    1628:	04 12       	push	r4		
    162a:	04 41       	mov	r1,	r4	
#if OS_VERSION >= 204
    OSInitHookBegin();                                           /* Call port specific initialization code   */
    162c:	b0 12 e0 13 	call	#0x13e0	
#endif

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
    1630:	b0 12 0c 1c 	call	#0x1c0c	

    OS_InitRdyList();                                            /* Initialize the Ready List                */
    1634:	b0 12 34 1c 	call	#0x1c34	

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
    1638:	b0 12 aa 1c 	call	#0x1caa	

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
    163c:	b0 12 a2 1b 	call	#0x1ba2	

#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
    1640:	b0 12 fc 26 	call	#0x26fc	
#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
    1644:	b0 12 10 32 	call	#0x3210	
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
    1648:	b0 12 76 1c 	call	#0x1c76	
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
#endif

#if OS_VERSION >= 204
    OSInitHookEnd();                                             /* Call port specific init. code            */
    164c:	b0 12 e8 13 	call	#0x13e8	
#endif

#if OS_VERSION >= 270 && OS_DEBUG_EN > 0
    OSDebugInit();
#endif
}
    1650:	34 41       	pop	r4		
    1652:	30 41       	ret			

00001654 <OSIntEnter>:
*                 OSIntEnter() is always called with interrupts disabled.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
    1654:	04 12       	push	r4		
    1656:	04 41       	mov	r1,	r4	
    if (OSRunning == TRUE) {
    1658:	5f 42 0d 03 	mov.b	&0x030d,r15	
    165c:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    165e:	09 20       	jnz	$+20     	;abs 0x1672
        if (OSIntNesting < 255u) {
    1660:	5f 42 86 03 	mov.b	&0x0386,r15	
    1664:	7f 93       	cmp.b	#-1,	r15	;r3 As==11
    1666:	05 24       	jz	$+12     	;abs 0x1672
            OSIntNesting++;                      /* Increment ISR nesting level                        */
    1668:	5f 42 86 03 	mov.b	&0x0386,r15	
    166c:	5f 53       	inc.b	r15		
    166e:	c2 4f 86 03 	mov.b	r15,	&0x0386	
        }
    }
}
    1672:	34 41       	pop	r4		
    1674:	30 41       	ret			

00001676 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
    1676:	04 12       	push	r4		
    1678:	21 82       	sub	#4,	r1	;r2 As==10
    167a:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    167c:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSRunning == TRUE) {
    1680:	5f 42 0d 03 	mov.b	&0x030d,r15	
    1684:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    1686:	55 20       	jnz	$+172    	;abs 0x1732
        OS_ENTER_CRITICAL();
    1688:	b0 12 d6 13 	call	#0x13d6	
    168c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
    1690:	5f 42 86 03 	mov.b	&0x0386,r15	
    1694:	4f 93       	tst.b	r15		
    1696:	05 24       	jz	$+12     	;abs 0x16a2
            OSIntNesting--;
    1698:	5f 42 86 03 	mov.b	&0x0386,r15	
    169c:	7f 53       	add.b	#-1,	r15	;r3 As==11
    169e:	c2 4f 86 03 	mov.b	r15,	&0x0386	
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
    16a2:	5f 42 86 03 	mov.b	&0x0386,r15	
    16a6:	4f 93       	tst.b	r15		
    16a8:	41 20       	jnz	$+132    	;abs 0x172c
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
    16aa:	5f 42 0c 03 	mov.b	&0x030c,r15	
    16ae:	4f 93       	tst.b	r15		
    16b0:	3d 20       	jnz	$+124    	;abs 0x172c
                y             = OSUnMapTbl[OSRdyGrp];          
    16b2:	5f 42 7e 03 	mov.b	&0x037e,r15	
    16b6:	7f f3       	and.b	#-1,	r15	;r3 As==11
    16b8:	d4 4f 28 15 	mov.b	5416(r15),2(r4)	;0x1528(r15), 0x0002(r4)
    16bc:	02 00 
                OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
    16be:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    16c2:	4f 5f       	rla.b	r15		
    16c4:	4f 5f       	rla.b	r15		
    16c6:	4f 5f       	rla.b	r15		
    16c8:	4e 4f       	mov.b	r15,	r14	
    16ca:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    16ce:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    16d2:	7f f3       	and.b	#-1,	r15	;r3 As==11
    16d4:	5f 4f 28 15 	mov.b	5416(r15),r15	;0x1528(r15)
    16d8:	4f 5e       	add.b	r14,	r15	
    16da:	c2 4f 12 03 	mov.b	r15,	&0x0312	
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
    16de:	5e 42 12 03 	mov.b	&0x0312,r14	
    16e2:	5f 42 26 03 	mov.b	&0x0326,r15	
    16e6:	4e 9f       	cmp.b	r15,	r14	
    16e8:	21 24       	jz	$+68     	;abs 0x172c
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
    16ea:	5f 42 12 03 	mov.b	&0x0312,r15	
    16ee:	7f f3       	and.b	#-1,	r15	;r3 As==11
    16f0:	0f 5f       	rla	r15		
    16f2:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    16f6:	2f 4f       	mov	@r15,	r15	
    16f8:	82 4f 7a 03 	mov	r15,	&0x037a	
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
    16fc:	1d 42 7a 03 	mov	&0x037a,r13	
    1700:	1e 4d 22 00 	mov	34(r13),r14	;0x0022(r13)
    1704:	1f 4d 24 00 	mov	36(r13),r15	;0x0024(r13)
    1708:	1e 53       	inc	r14		
    170a:	0f 63       	adc	r15		
    170c:	8d 4e 22 00 	mov	r14,	34(r13)	;0x0022(r13)
    1710:	8d 4f 24 00 	mov	r15,	36(r13)	;0x0024(r13)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
    1714:	1e 42 2c 03 	mov	&0x032c,r14	
    1718:	1f 42 2e 03 	mov	&0x032e,r15	
    171c:	1e 53       	inc	r14		
    171e:	0f 63       	adc	r15		
    1720:	82 4e 2c 03 	mov	r14,	&0x032c	
    1724:	82 4f 2e 03 	mov	r15,	&0x032e	
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
    1728:	b0 12 40 13 	call	#0x1340	
                }
            }
        }
        OS_EXIT_CRITICAL();
    172c:	2f 44       	mov	@r4,	r15	
    172e:	b0 12 dc 13 	call	#0x13dc	
    }
}
    1732:	21 52       	add	#4,	r1	;r2 As==10
    1734:	34 41       	pop	r4		
    1736:	30 41       	ret			

00001738 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
    1738:	04 12       	push	r4		
    173a:	21 83       	decd	r1		
    173c:	04 41       	mov	r1,	r4	
    INT8U y;
    INT8U x;


    if (OSRunning == FALSE) {
    173e:	5f 42 0d 03 	mov.b	&0x030d,r15	
    1742:	4f 93       	tst.b	r15		
    1744:	29 20       	jnz	$+84     	;abs 0x1798
        y             = OSUnMapTbl[OSRdyGrp];        /* Find highest priority's task priority number   */
    1746:	5f 42 7e 03 	mov.b	&0x037e,r15	
    174a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    174c:	d4 4f 28 15 	mov.b	5416(r15),1(r4)	;0x1528(r15), 0x0001(r4)
    1750:	01 00 
        x             = OSUnMapTbl[OSRdyTbl[y]];
    1752:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    1756:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    175a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    175c:	d4 4f 28 15 	mov.b	5416(r15),0(r4)	;0x1528(r15), 0x0000(r4)
    1760:	00 00 
        OSPrioHighRdy = (INT8U)((y << 3) + x);
    1762:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    1766:	4f 5f       	rla.b	r15		
    1768:	4f 5f       	rla.b	r15		
    176a:	4f 5f       	rla.b	r15		
    176c:	6f 54       	add.b	@r4,	r15	
    176e:	c2 4f 12 03 	mov.b	r15,	&0x0312	
        OSPrioCur     = OSPrioHighRdy;
    1772:	5f 42 12 03 	mov.b	&0x0312,r15	
    1776:	c2 4f 26 03 	mov.b	r15,	&0x0326	
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
    177a:	5f 42 12 03 	mov.b	&0x0312,r15	
    177e:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1780:	0f 5f       	rla	r15		
    1782:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    1786:	2f 4f       	mov	@r15,	r15	
    1788:	82 4f 7a 03 	mov	r15,	&0x037a	
        OSTCBCur      = OSTCBHighRdy;
    178c:	1f 42 7a 03 	mov	&0x037a,r15	
    1790:	82 4f 88 03 	mov	r15,	&0x0388	
        OSStartHighRdy();                            /* Execute target specific code to start task     */
    1794:	b0 12 c2 12 	call	#0x12c2	
    }
}
    1798:	21 53       	incd	r1		
    179a:	34 41       	pop	r4		
    179c:	30 41       	ret			

0000179e <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
    179e:	04 12       	push	r4		
    17a0:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    17a4:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                     */
    17a6:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif
#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
    17aa:	b0 12 18 15 	call	#0x1518	
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
    OSTime++;
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == TRUE) {
    17ae:	5f 42 0d 03 	mov.b	&0x030d,r15	
    17b2:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    17b4:	89 20       	jnz	$+276    	;abs 0x18c8
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
    17b6:	5f 42 2a 03 	mov.b	&0x032a,r15	
    17ba:	7f f3       	and.b	#-1,	r15	;r3 As==11
    17bc:	1f 93       	cmp	#1,	r15	;r3 As==01
    17be:	07 24       	jz	$+16     	;abs 0x17ce
    17c0:	2f 93       	cmp	#2,	r15	;r3 As==10
    17c2:	08 24       	jz	$+18     	;abs 0x17d4
    17c4:	0f 93       	tst	r15		
    17c6:	0b 20       	jnz	$+24     	;abs 0x17de
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = TRUE;
    17c8:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    17cc:	0c 3c       	jmp	$+26     	;abs 0x17e6
                 break;

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = FALSE;                             /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
    17ce:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    17d2:	09 3c       	jmp	$+20     	;abs 0x17e6
                 break;

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = TRUE;                   /*      ... step command from uC/OS-View        */
    17d4:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
                 OSTickStepState = OS_TICK_STEP_WAIT;
    17d8:	d2 43 2a 03 	mov.b	#1,	&0x032a	;r3 As==01
    17dc:	04 3c       	jmp	$+10     	;abs 0x17e6
                 break;

            default:                                       /* Invalid case, correct situation              */
                 step            = TRUE;
    17de:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
                 OSTickStepState = OS_TICK_STEP_DIS;
    17e2:	c2 43 2a 03 	mov.b	#0,	&0x032a	;r3 As==00
                 break;
        }
        if (step == FALSE) {                               /* Return if waiting for step command           */
    17e6:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    17ea:	6d 24       	jz	$+220    	;abs 0x18c6
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
    17ec:	94 42 28 03 	mov	&0x0328,4(r4)	;0x0004(r4)
    17f0:	04 00 
    17f2:	61 3c       	jmp	$+196    	;abs 0x18b6
        while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {          /* Go through all TCBs in TCB list              */
            OS_ENTER_CRITICAL();
    17f4:	b0 12 d6 13 	call	#0x13d6	
    17f8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
    17fc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1800:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    1804:	0f 93       	tst	r15		
    1806:	4f 24       	jz	$+160    	;abs 0x18a6
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
    1808:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    180c:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    1810:	0e 4f       	mov	r15,	r14	
    1812:	3e 53       	add	#-1,	r14	;r3 As==11
    1814:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1818:	8f 4e 18 00 	mov	r14,	24(r15)	;0x0018(r15)
    181c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1820:	1f 4f 18 00 	mov	24(r15),r15	;0x0018(r15)
    1824:	0f 93       	tst	r15		
    1826:	3f 20       	jnz	$+128    	;abs 0x18a6
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
    1828:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    182c:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1830:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1832:	3f f0 37 00 	and	#55,	r15	;#0x0037
    1836:	10 24       	jz	$+34     	;abs 0x1858
                        ptcb->OSTCBStat   &= ~OS_STAT_PEND_ANY;                /* Yes, Clear status flag   */
    1838:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    183c:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1840:	4e 4f       	mov.b	r15,	r14	
    1842:	7e f0 c8 ff 	and.b	#-56,	r14	;#0xffc8
    1846:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    184a:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
                        ptcb->OSTCBPendTO  = TRUE;                             /* Indicate PEND timeout    */
    184e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1852:	df 43 1b 00 	mov.b	#1,	27(r15)	;r3 As==01, 0x001b(r15)
    1856:	04 3c       	jmp	$+10     	;abs 0x1860
                    } else {
                        ptcb->OSTCBPendTO  = FALSE;
    1858:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    185c:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
    1860:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1864:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    1868:	7f f3       	and.b	#-1,	r15	;r3 As==11
    186a:	3f f2       	and	#8,	r15	;r2 As==11
    186c:	1c 20       	jnz	$+58     	;abs 0x18a6
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
    186e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1872:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    1876:	5f 42 7e 03 	mov.b	&0x037e,r15	
    187a:	4f de       	bis.b	r14,	r15	
    187c:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    1880:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    1884:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1888:	4d 4f       	mov.b	r15,	r13	
    188a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    188e:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1892:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1894:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    1898:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    189c:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    18a0:	4f de       	bis.b	r14,	r15	
    18a2:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
    18a6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18aa:	94 4f 0e 00 	mov	14(r15),4(r4)	;0x000e(r15), 0x0004(r4)
    18ae:	04 00 
            OS_EXIT_CRITICAL();
    18b0:	2f 44       	mov	@r4,	r15	
    18b2:	b0 12 dc 13 	call	#0x13dc	
        if (step == FALSE) {                               /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_IDLE_PRIO) {          /* Go through all TCBs in TCB list              */
    18b6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    18ba:	5f 4f 1c 00 	mov.b	28(r15),r15	;0x001c(r15)
    18be:	7f 90 14 00 	cmp.b	#20,	r15	;#0x0014
    18c2:	98 23       	jnz	$-206    	;abs 0x17f4
    18c4:	01 3c       	jmp	$+4      	;abs 0x18c8
                 step            = TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == FALSE) {                               /* Return if waiting for step command           */
            return;
    18c6:	03 43       	nop			
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
    18c8:	31 50 06 00 	add	#6,	r1	;#0x0006
    18cc:	34 41       	pop	r4		
    18ce:	30 41       	ret			

000018d0 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
    18d0:	04 12       	push	r4		
    18d2:	04 41       	mov	r1,	r4	
    return (OS_VERSION);
    18d4:	3f 40 14 01 	mov	#276,	r15	;#0x0114
}
    18d8:	34 41       	pop	r4		
    18da:	30 41       	ret			

000018dc <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *msg, INT8U msk)
{
    18dc:	04 12       	push	r4		
    18de:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    18e2:	04 41       	mov	r1,	r4	
    18e4:	84 4f 08 00 	mov	r15,	8(r4)	;0x0008(r4)
    18e8:	84 4e 0a 00 	mov	r14,	10(r4)	;0x000a(r4)
    18ec:	c4 4d 0c 00 	mov.b	r13,	12(r4)	;0x000c(r4)
    INT8U   bitx;
    INT8U   bity;
    INT8U   prio;


    y                      = OSUnMapTbl[pevent->OSEventGrp];   /* Find HPT waiting for message         */
    18f0:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    18f4:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    18f8:	7f f3       	and.b	#-1,	r15	;r3 As==11
    18fa:	d4 4f 28 15 	mov.b	5416(r15),3(r4)	;0x1528(r15), 0x0003(r4)
    18fe:	03 00 
    bity                   = OSMapTbl[y];
    1900:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    1904:	d4 4f 20 15 	mov.b	5408(r15),1(r4)	;0x1520(r15), 0x0001(r4)
    1908:	01 00 
    x                      = OSUnMapTbl[pevent->OSEventTbl[y]];
    190a:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    190e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1912:	0f 5e       	add	r14,	r15	
    1914:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1918:	6f 4f       	mov.b	@r15,	r15	
    191a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    191c:	d4 4f 28 15 	mov.b	5416(r15),4(r4)	;0x1528(r15), 0x0004(r4)
    1920:	04 00 
    bitx                   = OSMapTbl[x];
    1922:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    1926:	d4 4f 20 15 	mov.b	5408(r15),2(r4)	;0x1520(r15), 0x0002(r4)
    192a:	02 00 
    prio                   = (INT8U)((y << 3) + x);     /* Find priority of task getting the msg       */
    192c:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    1930:	4f 5f       	rla.b	r15		
    1932:	4f 5f       	rla.b	r15		
    1934:	4f 5f       	rla.b	r15		
    1936:	4e 4f       	mov.b	r15,	r14	
    1938:	5e 54 04 00 	add.b	4(r4),	r14	;0x0004(r4)
    193c:	c4 4e 00 00 	mov.b	r14,	0(r4)	;0x0000(r4)
    pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
    1940:	5d 44 03 00 	mov.b	3(r4),	r13	;0x0003(r4)
    1944:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    1948:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    194c:	0f 5e       	add	r14,	r15	
    194e:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1952:	6f 4f       	mov.b	@r15,	r15	
    1954:	4e 4f       	mov.b	r15,	r14	
    1956:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    195a:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    195c:	4f fe       	and.b	r14,	r15	
    195e:	4e 4f       	mov.b	r15,	r14	
    1960:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1964:	0f 5d       	add	r13,	r15	
    1966:	3f 50 06 00 	add	#6,	r15	;#0x0006
    196a:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    if (pevent->OSEventTbl[y] == 0x00) {                
    196e:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    1972:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1976:	0f 5e       	add	r14,	r15	
    1978:	3f 50 06 00 	add	#6,	r15	;#0x0006
    197c:	6f 4f       	mov.b	@r15,	r15	
    197e:	4f 93       	tst.b	r15		
    1980:	0e 20       	jnz	$+30     	;abs 0x199e
        pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
    1982:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    1986:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    198a:	4e 4f       	mov.b	r15,	r14	
    198c:	5f 44 01 00 	mov.b	1(r4),	r15	;0x0001(r4)
    1990:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1992:	4f fe       	and.b	r14,	r15	
    1994:	4e 4f       	mov.b	r15,	r14	
    1996:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    199a:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
    }
    ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
    199e:	6f 44       	mov.b	@r4,	r15	
    19a0:	0f 5f       	rla	r15		
    19a2:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    19a6:	a4 4f 06 00 	mov	@r15,	6(r4)	;0x0006(r4)
    ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
    19aa:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19ae:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)
    ptcb->OSTCBEventPtr  = (OS_EVENT *)0;               /* Unlink ECB from this task                   */
    19b2:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19b6:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg       = msg;                         /* Send message directly to waiting task       */
    19ba:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19be:	9f 44 0a 00 	mov	10(r4),	20(r15)	;0x000a(r4), 0x0014(r15)
    19c2:	14 00 
#else
    msg                  = msg;                         /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBPendTO    = FALSE;                       /* Cancel 'any' timeout because of post        */
    19c4:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19c8:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
    19cc:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19d0:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    19d4:	4e 4f       	mov.b	r15,	r14	
    19d6:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    19da:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    19dc:	4f fe       	and.b	r14,	r15	
    19de:	4e 4f       	mov.b	r15,	r14	
    19e0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19e4:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {               /* See if task is ready (could be susp'd)      */
    19e8:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    19ec:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    19f0:	4f 93       	tst.b	r15		
    19f2:	10 20       	jnz	$+34     	;abs 0x1a14
        OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
    19f4:	5f 42 7e 03 	mov.b	&0x037e,r15	
    19f8:	5f d4 01 00 	bis.b	1(r4),	r15	;0x0001(r4)
    19fc:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[y]     |=  bitx;
    1a00:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    1a04:	5f 44 03 00 	mov.b	3(r4),	r15	;0x0003(r4)
    1a08:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1a0c:	5f d4 02 00 	bis.b	2(r4),	r15	;0x0002(r4)
    1a10:	ce 4f 80 03 	mov.b	r15,	896(r14);0x0380(r14)
    }
    return (prio);
    1a14:	6f 44       	mov.b	@r4,	r15	
}
    1a16:	31 50 0e 00 	add	#14,	r1	;#0x000e
    1a1a:	34 41       	pop	r4		
    1a1c:	30 41       	ret			

00001a1e <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTaskWait (OS_EVENT *pevent)
{
    1a1e:	04 12       	push	r4		
    1a20:	21 82       	sub	#4,	r1	;r2 As==10
    1a22:	04 41       	mov	r1,	r4	
    1a24:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr = pevent;             /* Store pointer to event control block in TCB       */
    1a28:	1f 42 88 03 	mov	&0x0388,r15	
    1a2c:	9f 44 02 00 	mov	2(r4),	18(r15)	;0x0002(r4), 0x0012(r15)
    1a30:	12 00 
    y                       = OSTCBCur->OSTCBY;   /* Task no longer ready                              */
    1a32:	1f 42 88 03 	mov	&0x0388,r15	
    1a36:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    1a3a:	00 00 
    OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
    1a3c:	6d 44       	mov.b	@r4,	r13	
    1a3e:	6f 44       	mov.b	@r4,	r15	
    1a40:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1a44:	4e 4f       	mov.b	r15,	r14	
    1a46:	1f 42 88 03 	mov	&0x0388,r15	
    1a4a:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1a4e:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1a50:	4f fe       	and.b	r14,	r15	
    1a52:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
    if (OSRdyTbl[y] == 0x00) {                   
    1a56:	6f 44       	mov.b	@r4,	r15	
    1a58:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1a5c:	4f 93       	tst.b	r15		
    1a5e:	0b 20       	jnz	$+24     	;abs 0x1a76
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
    1a60:	1f 42 88 03 	mov	&0x0388,r15	
    1a64:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1a68:	4e 4f       	mov.b	r15,	r14	
    1a6a:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    1a6c:	5f 42 7e 03 	mov.b	&0x037e,r15	
    1a70:	4f fe       	and.b	r14,	r15	
    1a72:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
    }
    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
    1a76:	1f 42 88 03 	mov	&0x0388,r15	
    1a7a:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1a7e:	4d 4f       	mov.b	r15,	r13	
    1a80:	1f 42 88 03 	mov	&0x0388,r15	
    1a84:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1a88:	4e 4f       	mov.b	r15,	r14	
    1a8a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1a8e:	0f 5e       	add	r14,	r15	
    1a90:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1a94:	6e 4f       	mov.b	@r15,	r14	
    1a96:	1f 42 88 03 	mov	&0x0388,r15	
    1a9a:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1a9e:	4e df       	bis.b	r15,	r14	
    1aa0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1aa4:	0f 5d       	add	r13,	r15	
    1aa6:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1aaa:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
    1aae:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ab2:	5e 4f 01 00 	mov.b	1(r15),	r14	;0x0001(r15)
    1ab6:	1f 42 88 03 	mov	&0x0388,r15	
    1aba:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1abe:	4e df       	bis.b	r15,	r14	
    1ac0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ac4:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
}
    1ac8:	21 52       	add	#4,	r1	;r2 As==10
    1aca:	34 41       	pop	r4		
    1acc:	30 41       	ret			

00001ace <OS_EventTO>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventTO (OS_EVENT *pevent)
{
    1ace:	04 12       	push	r4		
    1ad0:	21 82       	sub	#4,	r1	;r2 As==10
    1ad2:	04 41       	mov	r1,	r4	
    1ad4:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  y;


    y                      = OSTCBCur->OSTCBY;
    1ad8:	1f 42 88 03 	mov	&0x0388,r15	
    1adc:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    1ae0:	00 00 
    pevent->OSEventTbl[y] &= ~OSTCBCur->OSTCBBitX;     /* Remove task from wait list                   */
    1ae2:	6d 44       	mov.b	@r4,	r13	
    1ae4:	6e 44       	mov.b	@r4,	r14	
    1ae6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1aea:	0f 5e       	add	r14,	r15	
    1aec:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1af0:	6f 4f       	mov.b	@r15,	r15	
    1af2:	4e 4f       	mov.b	r15,	r14	
    1af4:	1f 42 88 03 	mov	&0x0388,r15	
    1af8:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    1afc:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1afe:	4f fe       	and.b	r14,	r15	
    1b00:	4e 4f       	mov.b	r15,	r14	
    1b02:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b06:	0f 5d       	add	r13,	r15	
    1b08:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b0c:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    if (pevent->OSEventTbl[y] == 0x00) {
    1b10:	6e 44       	mov.b	@r4,	r14	
    1b12:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b16:	0f 5e       	add	r14,	r15	
    1b18:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b1c:	6f 4f       	mov.b	@r15,	r15	
    1b1e:	4f 93       	tst.b	r15		
    1b20:	10 20       	jnz	$+34     	;abs 0x1b42
        pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
    1b22:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b26:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    1b2a:	4e 4f       	mov.b	r15,	r14	
    1b2c:	1f 42 88 03 	mov	&0x0388,r15	
    1b30:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    1b34:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    1b36:	4f fe       	and.b	r14,	r15	
    1b38:	4e 4f       	mov.b	r15,	r14	
    1b3a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b3e:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
    }
    OSTCBCur->OSTCBPendTO   = FALSE;                   /* Clear the Pend Timeout flag                  */
    1b42:	1f 42 88 03 	mov	&0x0388,r15	
    1b46:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;             /* Set status to ready                          */
    1b4a:	1f 42 88 03 	mov	&0x0388,r15	
    1b4e:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
    1b52:	1f 42 88 03 	mov	&0x0388,r15	
    1b56:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
}
    1b5a:	21 52       	add	#4,	r1	;r2 As==10
    1b5c:	34 41       	pop	r4		
    1b5e:	30 41       	ret			

00001b60 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if OS_EVENT_EN
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
    1b60:	04 12       	push	r4		
    1b62:	21 82       	sub	#4,	r1	;r2 As==10
    1b64:	04 41       	mov	r1,	r4	
    1b66:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    INT8U  *ptbl;


    pevent->OSEventGrp = 0x00;                   /* No task waiting on event                           */
    1b6a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b6e:	cf 43 01 00 	mov.b	#0,	1(r15)	;r3 As==00, 0x0001(r15)
    ptbl               = &pevent->OSEventTbl[0];
    1b72:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1b76:	3f 50 06 00 	add	#6,	r15	;#0x0006
    1b7a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)

#if OS_EVENT_TBL_SIZE > 0
    *ptbl++            = 0x00;
    1b7e:	2f 44       	mov	@r4,	r15	
    1b80:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1b84:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 1
    *ptbl++            = 0x00;
    1b88:	2f 44       	mov	@r4,	r15	
    1b8a:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1b8e:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 2
    *ptbl++            = 0x00;
    1b92:	2f 44       	mov	@r4,	r15	
    1b94:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1b98:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
#endif

#if OS_EVENT_TBL_SIZE > 7
    *ptbl              = 0x00;
#endif
}
    1b9c:	21 52       	add	#4,	r1	;r2 As==10
    1b9e:	34 41       	pop	r4		
    1ba0:	30 41       	ret			

00001ba2 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
    1ba2:	04 12       	push	r4		
    1ba4:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1ba8:	04 41       	mov	r1,	r4	
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    1baa:	3f 40 0a 04 	mov	#1034,	r15	;#0x040a
    1bae:	3e 40 32 00 	mov	#50,	r14	;#0x0032
    1bb2:	b0 12 16 1d 	call	#0x1d16	
    pevent1 = &OSEventTbl[0];
    1bb6:	b4 40 0a 04 	mov	#1034,	2(r4)	;#0x040a, 0x0002(r4)
    1bba:	02 00 
    pevent2 = &OSEventTbl[1];
    1bbc:	b4 40 14 04 	mov	#1044,	0(r4)	;#0x0414, 0x0000(r4)
    1bc0:	00 00 
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
    1bc2:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    1bc6:	10 3c       	jmp	$+34     	;abs 0x1be8
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
    1bc8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bcc:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        pevent1->OSEventPtr     = pevent2;
    1bd0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bd4:	af 44 04 00 	mov	@r4,	4(r15)	;0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
    1bd8:	b4 50 0a 00 	add	#10,	2(r4)	;#0x000a, 0x0002(r4)
    1bdc:	02 00 
        pevent2++;
    1bde:	b4 50 0a 00 	add	#10,	0(r4)	;#0x000a, 0x0000(r4)
    1be2:	00 00 


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
    1be4:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    1be8:	a4 92 04 00 	cmp	#4,	4(r4)	;r2 As==10, 0x0004(r4)
    1bec:	ed 2b       	jnc	$-36     	;abs 0x1bc8
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
    1bee:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bf2:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
    1bf6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1bfa:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';                  
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
#endif
    OSEventFreeList                 = &OSEventTbl[0];
    1bfe:	b2 40 0a 04 	mov	#1034,	&0x0384	;#0x040a
    1c02:	84 03 
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
    1c04:	31 50 06 00 	add	#6,	r1	;#0x0006
    1c08:	34 41       	pop	r4		
    1c0a:	30 41       	ret			

00001c0c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
    1c0c:	04 12       	push	r4		
    1c0e:	04 41       	mov	r1,	r4	
#if OS_TIME_GET_SET_EN > 0   
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
    1c10:	c2 43 86 03 	mov.b	#0,	&0x0386	;r3 As==00
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
    1c14:	c2 43 0c 03 	mov.b	#0,	&0x030c	;r3 As==00

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
    1c18:	c2 43 32 03 	mov.b	#0,	&0x0332	;r3 As==00

    OSRunning     = FALSE;                                 /* Indicate that multitasking not started   */
    1c1c:	c2 43 0d 03 	mov.b	#0,	&0x030d	;r3 As==00
    
    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
    1c20:	82 43 2c 03 	mov	#0,	&0x032c	;r3 As==00
    1c24:	82 43 2e 03 	mov	#0,	&0x032e	;r3 As==00
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
    1c28:	82 43 0e 03 	mov	#0,	&0x030e	;r3 As==00
    1c2c:	82 43 10 03 	mov	#0,	&0x0310	;r3 As==00
#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
    OSIdleCtrMax  = 0L;
    OSStatRdy     = FALSE;                                 /* Statistic task is not ready              */
#endif
}
    1c30:	34 41       	pop	r4		
    1c32:	30 41       	ret			

00001c34 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
    1c34:	04 12       	push	r4		
    1c36:	21 82       	sub	#4,	r1	;r2 As==10
    1c38:	04 41       	mov	r1,	r4	
    INT8U    i;
    INT8U   *prdytbl;


    OSRdyGrp      = 0x00;                                  /* Clear the ready list                     */
    1c3a:	c2 43 7e 03 	mov.b	#0,	&0x037e	;r3 As==00
    prdytbl       = &OSRdyTbl[0];
    1c3e:	b4 40 80 03 	mov	#896,	0(r4)	;#0x0380, 0x0000(r4)
    1c42:	00 00 
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
    1c44:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    1c48:	07 3c       	jmp	$+16     	;abs 0x1c58
        *prdytbl++ = 0x00;
    1c4a:	2f 44       	mov	@r4,	r15	
    1c4c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1c50:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    INT8U   *prdytbl;


    OSRdyGrp      = 0x00;                                  /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
    1c54:	d4 53 02 00 	inc.b	2(r4)		;0x0002(r4)
    1c58:	f4 90 03 00 	cmp.b	#3,	2(r4)	;#0x0003, 0x0002(r4)
    1c5c:	02 00 
    1c5e:	f5 2b       	jnc	$-20     	;abs 0x1c4a
        *prdytbl++ = 0x00;
    }

    OSPrioCur     = 0;
    1c60:	c2 43 26 03 	mov.b	#0,	&0x0326	;r3 As==00
    OSPrioHighRdy = 0;
    1c64:	c2 43 12 03 	mov.b	#0,	&0x0312	;r3 As==00

    OSTCBHighRdy  = (OS_TCB *)0;                                 
    1c68:	82 43 7a 03 	mov	#0,	&0x037a	;r3 As==00
    OSTCBCur      = (OS_TCB *)0;
    1c6c:	82 43 88 03 	mov	#0,	&0x0388	;r3 As==00
}
    1c70:	21 52       	add	#4,	r1	;r2 As==10
    1c72:	34 41       	pop	r4		
    1c74:	30 41       	ret			

00001c76 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
    1c76:	04 12       	push	r4		
    1c78:	04 41       	mov	r1,	r4	
#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
    1c7a:	7e 40 14 00 	mov.b	#20,	r14	;#0x0014
    1c7e:	3f 40 08 04 	mov	#1032,	r15	;#0x0408
    1c82:	30 12 03 00 	push	#3		;#0x0003
    1c86:	03 12       	push	#0		;r3 As==00
    1c88:	03 12       	push	#0		;r3 As==00
    1c8a:	30 12 40 00 	push	#64		;#0x0040
    1c8e:	30 12 8a 03 	push	#906		;#0x038a
    1c92:	33 12       	push	#-1		;r3 As==11
    1c94:	4c 4e       	mov.b	r14,	r12	
    1c96:	0d 4f       	mov	r15,	r13	
    1c98:	0e 43       	clr	r14		
    1c9a:	3f 40 24 1e 	mov	#7716,	r15	;#0x1e24
    1c9e:	b0 12 de 37 	call	#0x37de	
    1ca2:	31 50 0c 00 	add	#12,	r1	;#0x000c
                       (void *)0,
                       &OSTaskIdleStk[0],
                       OS_IDLE_PRIO);
    #endif
#endif
}
    1ca6:	34 41       	pop	r4		
    1ca8:	30 41       	ret			

00001caa <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
    1caa:	04 12       	push	r4		
    1cac:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1cb0:	04 41       	mov	r1,	r4	
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    1cb2:	3f 40 3c 04 	mov	#1084,	r15	;#0x043c
    1cb6:	3e 40 38 01 	mov	#312,	r14	;#0x0138
    1cba:	b0 12 16 1d 	call	#0x1d16	
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    1cbe:	3f 40 76 05 	mov	#1398,	r15	;#0x0576
    1cc2:	3e 40 2a 00 	mov	#42,	r14	;#0x002a
    1cc6:	b0 12 16 1d 	call	#0x1d16	
    ptcb1 = &OSTCBTbl[0];
    1cca:	b4 40 3c 04 	mov	#1084,	2(r4)	;#0x043c, 0x0002(r4)
    1cce:	02 00 
    ptcb2 = &OSTCBTbl[1];
    1cd0:	b4 40 70 04 	mov	#1136,	0(r4)	;#0x0470, 0x0000(r4)
    1cd4:	00 00 
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
    1cd6:	c4 43 04 00 	mov.b	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    1cda:	0c 3c       	jmp	$+26     	;abs 0x1cf4
        ptcb1->OSTCBNext = ptcb2;
    1cdc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ce0:	af 44 0e 00 	mov	@r4,	14(r15)	;0x000e(r15)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
    1ce4:	b4 50 34 00 	add	#52,	2(r4)	;#0x0034, 0x0002(r4)
    1ce8:	02 00 
        ptcb2++;
    1cea:	b4 50 34 00 	add	#52,	0(r4)	;#0x0034, 0x0000(r4)
    1cee:	00 00 

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
    1cf0:	d4 53 04 00 	inc.b	4(r4)		;0x0004(r4)
    1cf4:	f4 90 05 00 	cmp.b	#5,	4(r4)	;#0x0005, 0x0004(r4)
    1cf8:	04 00 
    1cfa:	f0 2b       	jnc	$-30     	;abs 0x1cdc
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
    1cfc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1d00:	8f 43 0e 00 	mov	#0,	14(r15)	;r3 As==00, 0x000e(r15)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
    1d04:	82 43 28 03 	mov	#0,	&0x0328	;r3 As==00
    OSTCBFreeList           = &OSTCBTbl[0];
    1d08:	b2 40 3c 04 	mov	#1084,	&0x0330	;#0x043c
    1d0c:	30 03 
}
    1d0e:	31 50 06 00 	add	#6,	r1	;#0x0006
    1d12:	34 41       	pop	r4		
    1d14:	30 41       	ret			

00001d16 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    1d16:	04 12       	push	r4		
    1d18:	21 82       	sub	#4,	r1	;r2 As==10
    1d1a:	04 41       	mov	r1,	r4	
    1d1c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    1d20:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    1d24:	07 3c       	jmp	$+16     	;abs 0x1d34
    while (size > 0) {
        *pdest++ = (INT8U)0;
    1d26:	2f 44       	mov	@r4,	r15	
    1d28:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    1d2c:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
        size--;
    1d30:	b4 53 02 00 	add	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
    1d34:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    1d38:	f6 23       	jnz	$-18     	;abs 0x1d26
        *pdest++ = (INT8U)0;
        size--;
    }
}
    1d3a:	21 52       	add	#4,	r1	;r2 As==10
    1d3c:	34 41       	pop	r4		
    1d3e:	30 41       	ret			

00001d40 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    1d40:	04 12       	push	r4		
    1d42:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    1d46:	04 41       	mov	r1,	r4	
    1d48:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    1d4c:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    1d50:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
    1d54:	0c 3c       	jmp	$+26     	;abs 0x1d6e
    while (size > 0) {
        *pdest++ = *psrc++;
    1d56:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1d5a:	6e 4f       	mov.b	@r15,	r14	
    1d5c:	2f 44       	mov	@r4,	r15	
    1d5e:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
    1d62:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    1d66:	94 53 02 00 	inc	2(r4)		;0x0002(r4)
        size--;
    1d6a:	b4 53 04 00 	add	#-1,	4(r4)	;r3 As==11, 0x0004(r4)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
    1d6e:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    1d72:	f1 23       	jnz	$-28     	;abs 0x1d56
        *pdest++ = *psrc++;
        size--;
    }
}
    1d74:	31 50 06 00 	add	#6,	r1	;#0x0006
    1d78:	34 41       	pop	r4		
    1d7a:	30 41       	ret			

00001d7c <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
    1d7c:	04 12       	push	r4		
    1d7e:	21 82       	sub	#4,	r1	;r2 As==10
    1d80:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    1d82:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    1d86:	b0 12 d6 13 	call	#0x13d6	
    1d8a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
    1d8e:	5f 42 86 03 	mov.b	&0x0386,r15	
    1d92:	4f 93       	tst.b	r15		
    1d94:	41 20       	jnz	$+132    	;abs 0x1e18
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
    1d96:	5f 42 0c 03 	mov.b	&0x030c,r15	
    1d9a:	4f 93       	tst.b	r15		
    1d9c:	3d 20       	jnz	$+124    	;abs 0x1e18
            y             = OSUnMapTbl[OSRdyGrp];      /* Get pointer to HPT ready to run              */
    1d9e:	5f 42 7e 03 	mov.b	&0x037e,r15	
    1da2:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1da4:	d4 4f 28 15 	mov.b	5416(r15),2(r4)	;0x1528(r15), 0x0002(r4)
    1da8:	02 00 
            OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
    1daa:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1dae:	4f 5f       	rla.b	r15		
    1db0:	4f 5f       	rla.b	r15		
    1db2:	4f 5f       	rla.b	r15		
    1db4:	4e 4f       	mov.b	r15,	r14	
    1db6:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    1dba:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    1dbe:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1dc0:	5f 4f 28 15 	mov.b	5416(r15),r15	;0x1528(r15)
    1dc4:	4f 5e       	add.b	r14,	r15	
    1dc6:	c2 4f 12 03 	mov.b	r15,	&0x0312	
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
    1dca:	5e 42 12 03 	mov.b	&0x0312,r14	
    1dce:	5f 42 26 03 	mov.b	&0x0326,r15	
    1dd2:	4e 9f       	cmp.b	r15,	r14	
    1dd4:	21 24       	jz	$+68     	;abs 0x1e18
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
    1dd6:	5f 42 12 03 	mov.b	&0x0312,r15	
    1dda:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1ddc:	0f 5f       	rla	r15		
    1dde:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    1de2:	2f 4f       	mov	@r15,	r15	
    1de4:	82 4f 7a 03 	mov	r15,	&0x037a	
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
    1de8:	1d 42 7a 03 	mov	&0x037a,r13	
    1dec:	1e 4d 22 00 	mov	34(r13),r14	;0x0022(r13)
    1df0:	1f 4d 24 00 	mov	36(r13),r15	;0x0024(r13)
    1df4:	1e 53       	inc	r14		
    1df6:	0f 63       	adc	r15		
    1df8:	8d 4e 22 00 	mov	r14,	34(r13)	;0x0022(r13)
    1dfc:	8d 4f 24 00 	mov	r15,	36(r13)	;0x0024(r13)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
    1e00:	1e 42 2c 03 	mov	&0x032c,r14	
    1e04:	1f 42 2e 03 	mov	&0x032e,r15	
    1e08:	1e 53       	inc	r14		
    1e0a:	0f 63       	adc	r15		
    1e0c:	82 4e 2c 03 	mov	r14,	&0x032c	
    1e10:	82 4f 2e 03 	mov	r15,	&0x032e	
                OS_TASK_SW();                          /* Perform a context switch                     */
    1e14:	b0 12 ee 12 	call	#0x12ee	
            }
        }
    }
    OS_EXIT_CRITICAL();
    1e18:	2f 44       	mov	@r4,	r15	
    1e1a:	b0 12 dc 13 	call	#0x13dc	
}
    1e1e:	21 52       	add	#4,	r1	;r2 As==10
    1e20:	34 41       	pop	r4		
    1e22:	30 41       	ret			

00001e24 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *parg)
{
    1e24:	04 12       	push	r4		
    1e26:	21 82       	sub	#4,	r1	;r2 As==10
    1e28:	04 41       	mov	r1,	r4	
    1e2a:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    1e2e:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    parg   = parg;                               /* Prevent compiler warning for not using 'parg'      */
    for (;;) {
        OS_ENTER_CRITICAL();
    1e32:	b0 12 d6 13 	call	#0x13d6	
    1e36:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        OSIdleCtr++;
    1e3a:	1e 42 0e 03 	mov	&0x030e,r14	
    1e3e:	1f 42 10 03 	mov	&0x0310,r15	
    1e42:	1e 53       	inc	r14		
    1e44:	0f 63       	adc	r15		
    1e46:	82 4e 0e 03 	mov	r14,	&0x030e	
    1e4a:	82 4f 10 03 	mov	r15,	&0x0310	
        OS_EXIT_CRITICAL();
    1e4e:	2f 44       	mov	@r4,	r15	
    1e50:	b0 12 dc 13 	call	#0x13dc	
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
    1e54:	b0 12 10 14 	call	#0x1410	
    1e58:	ec 3f       	jmp	$-38     	;abs 0x1e32

00001e5a <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
    1e5a:	04 12       	push	r4		
    1e5c:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    1e60:	04 41       	mov	r1,	r4	
    1e62:	c4 4f 04 00 	mov.b	r15,	4(r4)	;0x0004(r4)
    1e66:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    1e6a:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
    1e6e:	84 4c 0a 00 	mov	r12,	10(r4)	;0x000a(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    1e72:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    1e76:	b0 12 d6 13 	call	#0x13d6	
    1e7a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
    1e7e:	94 42 30 03 	mov	&0x0330,2(r4)	;0x0002(r4)
    1e82:	02 00 
    if (ptcb != (OS_TCB *)0) {
    1e84:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    1e88:	d7 24       	jz	$+432    	;abs 0x2038
        OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
    1e8a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1e8e:	1f 4f 0e 00 	mov	14(r15),r15	;0x000e(r15)
    1e92:	82 4f 30 03 	mov	r15,	&0x0330	
        OS_EXIT_CRITICAL();
    1e96:	2f 44       	mov	@r4,	r15	
    1e98:	b0 12 dc 13 	call	#0x13dc	
        ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
    1e9c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ea0:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    1ea4:	00 00 
        ptcb->OSTCBPrio      = prio;                       /* Load task priority into TCB              */
    1ea6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1eaa:	df 44 04 00 	mov.b	4(r4),	28(r15)	;0x0004(r4), 0x001c(r15)
    1eae:	1c 00 
        ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
    1eb0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1eb4:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
        ptcb->OSTCBPendTO    = FALSE;                      /* Clear the Pend timeout flag              */
    1eb8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ebc:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
        ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */
    1ec0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ec4:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
    1ec8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ecc:	9f 44 14 00 	mov	20(r4),	2(r15)	;0x0014(r4), 0x0002(r15)
    1ed0:	02 00 
        ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
    1ed2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ed6:	9f 44 10 00 	mov	16(r4),	6(r15)	;0x0010(r4), 0x0006(r15)
    1eda:	06 00 
    1edc:	9f 44 12 00 	mov	18(r4),	8(r15)	;0x0012(r4), 0x0008(r15)
    1ee0:	08 00 
        ptcb->OSTCBStkBottom = pbos;                       /* Store pointer to bottom of stack         */
    1ee2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ee6:	9f 44 08 00 	mov	8(r4),	4(r15)	;0x0008(r4), 0x0004(r15)
    1eea:	04 00 
        ptcb->OSTCBOpt       = opt;                        /* Store task options                       */
    1eec:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ef0:	9f 44 16 00 	mov	22(r4),	10(r15)	;0x0016(r4), 0x000a(r15)
    1ef4:	0a 00 
        ptcb->OSTCBId        = id;                         /* Store task ID                            */
    1ef6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1efa:	9f 44 0a 00 	mov	10(r4),	12(r15)	;0x000a(r4), 0x000c(r15)
    1efe:	0c 00 

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq    = OS_NO_ERR;
#endif

        ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
    1f00:	5e 44 04 00 	mov.b	4(r4),	r14	;0x0004(r4)
    1f04:	12 c3       	clrc			
    1f06:	4e 10       	rrc.b	r14		
    1f08:	4e 11       	rra.b	r14		
    1f0a:	4e 11       	rra.b	r14		
    1f0c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f10:	cf 4e 1e 00 	mov.b	r14,	30(r15)	;0x001e(r15)
        ptcb->OSTCBBitY      = OSMapTbl[ptcb->OSTCBY];
    1f14:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f18:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    1f1c:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1f1e:	5e 4f 20 15 	mov.b	5408(r15),r14	;0x1520(r15)
    1f22:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f26:	cf 4e 20 00 	mov.b	r14,	32(r15)	;0x0020(r15)
        ptcb->OSTCBX         = (INT8U)(prio & 0x07);
    1f2a:	5e 44 04 00 	mov.b	4(r4),	r14	;0x0004(r4)
    1f2e:	7e f0 07 00 	and.b	#7,	r14	;#0x0007
    1f32:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f36:	cf 4e 1d 00 	mov.b	r14,	29(r15)	;0x001d(r15)
        ptcb->OSTCBBitX      = OSMapTbl[ptcb->OSTCBX];
    1f3a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f3e:	5f 4f 1d 00 	mov.b	29(r15),r15	;0x001d(r15)
    1f42:	7f f3       	and.b	#-1,	r15	;r3 As==11
    1f44:	5e 4f 20 15 	mov.b	5408(r15),r14	;0x1520(r15)
    1f48:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f4c:	cf 4e 1f 00 	mov.b	r14,	31(r15)	;0x001f(r15)

#if OS_EVENT_EN
        ptcb->OSTCBEventPtr  = (OS_EVENT *)0;              /* Task is not pending on an event          */
    1f50:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f54:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if (OS_VERSION >= 251) && (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
    1f58:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f5c:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
    1f60:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f64:	8f 43 22 00 	mov	#0,	34(r15)	;r3 As==00, 0x0022(r15)
    1f68:	8f 43 24 00 	mov	#0,	36(r15)	;r3 As==00, 0x0024(r15)
        ptcb->OSTCBCyclesStart = 0L;
    1f6c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f70:	8f 43 2a 00 	mov	#0,	42(r15)	;r3 As==00, 0x002a(r15)
    1f74:	8f 43 2c 00 	mov	#0,	44(r15)	;r3 As==00, 0x002c(r15)
        ptcb->OSTCBCyclesTot   = 0L;
    1f78:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f7c:	8f 43 26 00 	mov	#0,	38(r15)	;r3 As==00, 0x0026(r15)
    1f80:	8f 43 28 00 	mov	#0,	40(r15)	;r3 As==00, 0x0028(r15)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
    1f84:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f88:	8f 43 2e 00 	mov	#0,	46(r15)	;r3 As==00, 0x002e(r15)
        ptcb->OSTCBStkUsed     = 0L;
    1f8c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f90:	8f 43 30 00 	mov	#0,	48(r15)	;r3 As==00, 0x0030(r15)
    1f94:	8f 43 32 00 	mov	#0,	50(r15)	;r3 As==00, 0x0032(r15)
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif

#if OS_VERSION >= 204
        OSTCBInitHook(ptcb);
    1f98:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1f9c:	b0 12 08 15 	call	#0x1508	
#endif

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
    1fa0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fa4:	b0 12 f0 13 	call	#0x13f0	
        
        OS_ENTER_CRITICAL();
    1fa8:	b0 12 d6 13 	call	#0x13d6	
    1fac:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        OSTCBPrioTbl[prio] = ptcb;
    1fb0:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    1fb4:	0f 5f       	rla	r15		
    1fb6:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    1fba:	9f 44 02 00 	mov	2(r4),	0(r15)	;0x0002(r4), 0x0000(r15)
    1fbe:	00 00 
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
    1fc0:	1e 42 28 03 	mov	&0x0328,r14	
    1fc4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fc8:	8f 4e 0e 00 	mov	r14,	14(r15)	;0x000e(r15)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
    1fcc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1fd0:	8f 43 10 00 	mov	#0,	16(r15)	;r3 As==00, 0x0010(r15)
        if (OSTCBList != (OS_TCB *)0) {
    1fd4:	1f 42 28 03 	mov	&0x0328,r15	
    1fd8:	0f 93       	tst	r15		
    1fda:	05 24       	jz	$+12     	;abs 0x1fe6
            OSTCBList->OSTCBPrev = ptcb;
    1fdc:	1f 42 28 03 	mov	&0x0328,r15	
    1fe0:	9f 44 02 00 	mov	2(r4),	16(r15)	;0x0002(r4), 0x0010(r15)
    1fe4:	10 00 
        }
        OSTCBList               = ptcb;
    1fe6:	92 44 02 00 	mov	2(r4),	&0x0328	;0x0002(r4)
    1fea:	28 03 
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
    1fec:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    1ff0:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    1ff4:	5f 42 7e 03 	mov.b	&0x037e,r15	
    1ff8:	4f de       	bis.b	r14,	r15	
    1ffa:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    1ffe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2002:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    2006:	4d 4f       	mov.b	r15,	r13	
    2008:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    200c:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    2010:	7f f3       	and.b	#-1,	r15	;r3 As==11
    2012:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    2016:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    201a:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    201e:	4f de       	bis.b	r14,	r15	
    2020:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
    2024:	5f 42 32 03 	mov.b	&0x0332,r15	
    2028:	5f 53       	inc.b	r15		
    202a:	c2 4f 32 03 	mov.b	r15,	&0x0332	
        OS_EXIT_CRITICAL();
    202e:	2f 44       	mov	@r4,	r15	
    2030:	b0 12 dc 13 	call	#0x13dc	
        return (OS_NO_ERR);
    2034:	4f 43       	clr.b	r15		
    2036:	05 3c       	jmp	$+12     	;abs 0x2042
    }
    OS_EXIT_CRITICAL();
    2038:	2f 44       	mov	@r4,	r15	
    203a:	b0 12 dc 13 	call	#0x13dc	
    return (OS_NO_MORE_TCB);
    203e:	7f 40 46 00 	mov.b	#70,	r15	;#0x0046
}
    2042:	31 50 0c 00 	add	#12,	r1	;#0x000c
    2046:	34 41       	pop	r4		
    2048:	30 41       	ret			

0000204a <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *err)
{
    204a:	04 12       	push	r4		
    204c:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    2050:	04 41       	mov	r1,	r4	
    2052:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2056:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    205a:	c4 4d 0a 00 	mov.b	r13,	10(r4)	;0x000a(r4)
    205e:	84 4c 0c 00 	mov	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    2062:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
    2066:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    206a:	6f 4f       	mov.b	@r15,	r15	
    206c:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    2070:	06 24       	jz	$+14     	;abs 0x207e
        *err = OS_ERR_EVENT_TYPE;
    2072:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2076:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    207a:	0f 43       	clr	r15		
    207c:	77 3c       	jmp	$+240    	;abs 0x216c
    }
    if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
    207e:	5f 44 0a 00 	mov.b	10(r4),	r15	;0x000a(r4)
    2082:	4f 93       	tst.b	r15		
    2084:	06 34       	jge	$+14     	;abs 0x2092
        wait_type &= ~OS_FLAG_CONSUME;
    2086:	f4 f0 7f 00 	and.b	#127,	10(r4)	;#0x007f, 0x000a(r4)
    208a:	0a 00 
        consume    = TRUE;
    208c:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2090:	02 3c       	jmp	$+6      	;abs 0x2096
    } else {
        consume    = FALSE;
    2092:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    }
/*$PAGE*/
    *err = OS_NO_ERR;                                      /* Assume NO error until proven otherwise.  */
    2096:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    209a:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OS_ENTER_CRITICAL();
    209e:	b0 12 d6 13 	call	#0x13d6	
    20a2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (wait_type) {
    20a6:	5f 44 0a 00 	mov.b	10(r4),	r15	;0x000a(r4)
    20aa:	2f 93       	cmp	#2,	r15	;r3 As==10
    20ac:	04 24       	jz	$+10     	;abs 0x20b6
    20ae:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    20b2:	29 24       	jz	$+84     	;abs 0x2106
    20b4:	4f 3c       	jmp	$+160    	;abs 0x2154
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    20b6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    20ba:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    20be:	0e 4f       	mov	r15,	r14	
    20c0:	1e f4 08 00 	and	8(r4),	r14	;0x0008(r4)
    20c4:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    20c8:	94 94 08 00 	cmp	8(r4),	4(r4)	;0x0008(r4), 0x0004(r4)
    20cc:	04 00 
    20ce:	10 20       	jnz	$+34     	;abs 0x20f0
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    20d0:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    20d4:	13 20       	jnz	$+40     	;abs 0x20fc
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    20d6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    20da:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    20de:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    20e2:	3f e3       	inv	r15		
    20e4:	0e ff       	and	r15,	r14	
    20e6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    20ea:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    20ee:	07 3c       	jmp	$+16     	;abs 0x20fe
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
    20f0:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    20f4:	ff 40 98 ff 	mov.b	#-104,	0(r15)	;#0xff98, 0x0000(r15)
    20f8:	00 00 
    20fa:	01 3c       	jmp	$+4      	;abs 0x20fe
    switch (wait_type) {
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    20fc:	03 43       	nop			
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
    20fe:	2f 44       	mov	@r4,	r15	
    2100:	b0 12 dc 13 	call	#0x13dc	
    2104:	31 3c       	jmp	$+100    	;abs 0x2168
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    2106:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    210a:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    210e:	0e 4f       	mov	r15,	r14	
    2110:	1e f4 08 00 	and	8(r4),	r14	;0x0008(r4)
    2114:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    2118:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    211c:	10 24       	jz	$+34     	;abs 0x213e
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    211e:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2122:	13 20       	jnz	$+40     	;abs 0x214a
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    2124:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2128:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    212c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2130:	3f e3       	inv	r15		
    2132:	0e ff       	and	r15,	r14	
    2134:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2138:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    213c:	07 3c       	jmp	$+16     	;abs 0x214c
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
    213e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2142:	ff 40 98 ff 	mov.b	#-104,	0(r15)	;#0xff98, 0x0000(r15)
    2146:	00 00 
    2148:	01 3c       	jmp	$+4      	;abs 0x214c

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    214a:	03 43       	nop			
                 }
             } else {
                 *err  = OS_FLAG_ERR_NOT_RDY;
             }
             OS_EXIT_CRITICAL();
    214c:	2f 44       	mov	@r4,	r15	
    214e:	b0 12 dc 13 	call	#0x13dc	
    2152:	0a 3c       	jmp	$+22     	;abs 0x2168
             OS_EXIT_CRITICAL();
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
    2154:	2f 44       	mov	@r4,	r15	
    2156:	b0 12 dc 13 	call	#0x13dc	
             flags_rdy = (OS_FLAGS)0;
    215a:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
             *err      = OS_FLAG_ERR_WAIT_TYPE;
    215e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2162:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    2166:	00 00 
             break;
    }
    return (flags_rdy);
    2168:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    216c:	31 50 0e 00 	add	#14,	r1	;#0x000e
    2170:	34 41       	pop	r4		
    2172:	30 41       	ret			

00002174 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *err)
{
    2174:	04 12       	push	r4		
    2176:	31 82       	sub	#8,	r1	;r2 As==11
    2178:	04 41       	mov	r1,	r4	
    217a:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    217e:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr;



    cpu_sr = 0;                                     /* Prevent compiler warning                        */
    2182:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
    2186:	5f 42 86 03 	mov.b	&0x0386,r15	
    218a:	4f 93       	tst.b	r15		
    218c:	07 24       	jz	$+16     	;abs 0x219c
        *err = OS_ERR_CREATE_ISR;                   /* ... can't CREATE from an ISR                    */
    218e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2192:	ff 40 8d ff 	mov.b	#-115,	0(r15)	;#0xff8d, 0x0000(r15)
    2196:	00 00 
        return ((OS_FLAG_GRP *)0);
    2198:	0f 43       	clr	r15		
    219a:	30 3c       	jmp	$+98     	;abs 0x21fc
    }
    OS_ENTER_CRITICAL();
    219c:	b0 12 d6 13 	call	#0x13d6	
    21a0:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
    21a4:	94 42 74 05 	mov	&0x0574,2(r4)	;0x0002(r4)
    21a8:	02 00 
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
    21aa:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    21ae:	1c 24       	jz	$+58     	;abs 0x21e8
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
    21b0:	1f 42 74 05 	mov	&0x0574,r15	
    21b4:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    21b8:	82 4f 74 05 	mov	r15,	&0x0574	
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
    21bc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    21c0:	ff 40 05 00 	mov.b	#5,	0(r15)	;#0x0005, 0x0000(r15)
    21c4:	00 00 
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
    21c6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    21ca:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    21ce:	04 00 
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
    21d0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    21d4:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        OS_EXIT_CRITICAL();
    21d8:	2f 44       	mov	@r4,	r15	
    21da:	b0 12 dc 13 	call	#0x13dc	
        *err                 = OS_NO_ERR;
    21de:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    21e2:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    21e6:	08 3c       	jmp	$+18     	;abs 0x21f8
    } else {
        OS_EXIT_CRITICAL();
    21e8:	2f 44       	mov	@r4,	r15	
    21ea:	b0 12 dc 13 	call	#0x13dc	
        *err                 = OS_FLAG_GRP_DEPLETED;
    21ee:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    21f2:	ff 40 9a ff 	mov.b	#-102,	0(r15)	;#0xff9a, 0x0000(r15)
    21f6:	00 00 
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
    21f8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    21fc:	31 52       	add	#8,	r1	;r2 As==11
    21fe:	34 41       	pop	r4		
    2200:	30 41       	ret			

00002202 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *err)
{
    2202:	04 12       	push	r4		
    2204:	31 50 e6 ff 	add	#-26,	r1	;#0xffe6
    2208:	04 41       	mov	r1,	r4	
    220a:	84 4f 12 00 	mov	r15,	18(r4)	;0x0012(r4)
    220e:	84 4e 14 00 	mov	r14,	20(r4)	;0x0014(r4)
    2212:	c4 4d 16 00 	mov.b	r13,	22(r4)	;0x0016(r4)
    2216:	84 4c 18 00 	mov	r12,	24(r4)	;0x0018(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    221a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
    221e:	5f 42 86 03 	mov.b	&0x0386,r15	
    2222:	4f 93       	tst.b	r15		
    2224:	06 24       	jz	$+14     	;abs 0x2232
        *err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR               */
    2226:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    222a:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((OS_FLAGS)0);
    222e:	0f 43       	clr	r15		
    2230:	fd 3c       	jmp	$+508    	;abs 0x242c
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
    2232:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2236:	6f 4f       	mov.b	@r15,	r15	
    2238:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    223c:	06 24       	jz	$+14     	;abs 0x224a
        *err = OS_ERR_EVENT_TYPE;
    223e:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2242:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    2246:	0f 43       	clr	r15		
    2248:	f1 3c       	jmp	$+484    	;abs 0x242c
    }
    if (wait_type & OS_FLAG_CONSUME) {                     /* See if we need to consume the flags      */
    224a:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    224e:	4f 93       	tst.b	r15		
    2250:	06 34       	jge	$+14     	;abs 0x225e
        wait_type &= ~OS_FLAG_CONSUME;
    2252:	f4 f0 7f 00 	and.b	#127,	22(r4)	;#0x007f, 0x0016(r4)
    2256:	16 00 
        consume    = TRUE;
    2258:	d4 43 02 00 	mov.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    225c:	02 3c       	jmp	$+6      	;abs 0x2262
    } else {
        consume    = FALSE;
    225e:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    2262:	b0 12 d6 13 	call	#0x13d6	
    2266:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (wait_type) {
    226a:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    226e:	2f 93       	cmp	#2,	r15	;r3 As==10
    2270:	04 24       	jz	$+10     	;abs 0x227a
    2272:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    2276:	3e 24       	jz	$+126    	;abs 0x22f4
    2278:	79 3c       	jmp	$+244    	;abs 0x236c
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    227a:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    227e:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2282:	0e 4f       	mov	r15,	r14	
    2284:	1e f4 14 00 	and	20(r4),	r14	;0x0014(r4)
    2288:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    228c:	94 94 14 00 	cmp	20(r4),	4(r4)	;0x0014(r4), 0x0004(r4)
    2290:	04 00 
    2292:	1e 20       	jnz	$+62     	;abs 0x22d0
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    2294:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2298:	0c 20       	jnz	$+26     	;abs 0x22b2
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    229a:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    229e:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    22a2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    22a6:	3f e3       	inv	r15		
    22a8:	0e ff       	and	r15,	r14	
    22aa:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22ae:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    22b2:	1f 42 88 03 	mov	&0x0388,r15	
    22b6:	9f 44 04 00 	mov	4(r4),	22(r15)	;0x0004(r4), 0x0016(r15)
    22ba:	16 00 
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    22bc:	2f 44       	mov	@r4,	r15	
    22be:	b0 12 dc 13 	call	#0x13dc	
                 *err                    = OS_NO_ERR;
    22c2:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    22c6:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
                 return (flags_rdy);
    22ca:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    22ce:	ae 3c       	jmp	$+350    	;abs 0x242c
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    22d0:	5c 44 16 00 	mov.b	22(r4),	r12	;0x0016(r4)
    22d4:	1d 44 14 00 	mov	20(r4),	r13	;0x0014(r4)
    22d8:	0e 44       	mov	r4,	r14	
    22da:	3e 50 06 00 	add	#6,	r14	;#0x0006
    22de:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22e2:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    22e6:	b0 12 02 26 	call	#0x2602	
    22ea:	21 53       	incd	r1		
                 OS_EXIT_CRITICAL();
    22ec:	2f 44       	mov	@r4,	r15	
    22ee:	b0 12 dc 13 	call	#0x13dc	
    22f2:	49 3c       	jmp	$+148    	;abs 0x2386
             }
             break;

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = pgrp->OSFlagFlags & flags;        /* Extract only the bits we want            */
    22f4:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    22f8:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    22fc:	0e 4f       	mov	r15,	r14	
    22fe:	1e f4 14 00 	and	20(r4),	r14	;0x0014(r4)
    2302:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    2306:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    230a:	1e 24       	jz	$+62     	;abs 0x2348
                 if (consume == TRUE) {                    /* See if we need to consume the flags      */
    230c:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2310:	0c 20       	jnz	$+26     	;abs 0x232a
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    2312:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2316:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    231a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    231e:	3f e3       	inv	r15		
    2320:	0e ff       	and	r15,	r14	
    2322:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2326:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    232a:	1f 42 88 03 	mov	&0x0388,r15	
    232e:	9f 44 04 00 	mov	4(r4),	22(r15)	;0x0004(r4), 0x0016(r15)
    2332:	16 00 
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    2334:	2f 44       	mov	@r4,	r15	
    2336:	b0 12 dc 13 	call	#0x13dc	
                 *err                    = OS_NO_ERR;
    233a:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    233e:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
                 return (flags_rdy);
    2342:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2346:	72 3c       	jmp	$+230    	;abs 0x242c
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    2348:	5c 44 16 00 	mov.b	22(r4),	r12	;0x0016(r4)
    234c:	1d 44 14 00 	mov	20(r4),	r13	;0x0014(r4)
    2350:	0e 44       	mov	r4,	r14	
    2352:	3e 50 06 00 	add	#6,	r14	;#0x0006
    2356:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    235a:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    235e:	b0 12 02 26 	call	#0x2602	
    2362:	21 53       	incd	r1		
                 OS_EXIT_CRITICAL();
    2364:	2f 44       	mov	@r4,	r15	
    2366:	b0 12 dc 13 	call	#0x13dc	
    236a:	0d 3c       	jmp	$+28     	;abs 0x2386
             }
             break;
#endif

        default:
             OS_EXIT_CRITICAL();
    236c:	2f 44       	mov	@r4,	r15	
    236e:	b0 12 dc 13 	call	#0x13dc	
             flags_rdy = (OS_FLAGS)0;
    2372:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
             *err      = OS_FLAG_ERR_WAIT_TYPE;
    2376:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    237a:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    237e:	00 00 
             return (flags_rdy);
    2380:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2384:	53 3c       	jmp	$+168    	;abs 0x242c
    }
    OS_Sched();                                            /* Find next HPT ready to run               */
    2386:	b0 12 7c 1d 	call	#0x1d7c	
    OS_ENTER_CRITICAL();
    238a:	b0 12 d6 13 	call	#0x13d6	
    238e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {                   /* Have we timed-out?                       */
    2392:	1f 42 88 03 	mov	&0x0388,r15	
    2396:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    239a:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    239c:	1a 20       	jnz	$+54     	;abs 0x23d2
        OSTCBCur->OSTCBPendTO = FALSE;
    239e:	1f 42 88 03 	mov	&0x0388,r15	
    23a2:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
        OS_FlagUnlink(&node);
    23a6:	0f 44       	mov	r4,	r15	
    23a8:	3f 50 06 00 	add	#6,	r15	;#0x0006
    23ac:	b0 12 0e 28 	call	#0x280e	
        OSTCBCur->OSTCBStat   = OS_STAT_RDY;               /* Yes, make task ready-to-run              */
    23b0:	1f 42 88 03 	mov	&0x0388,r15	
    23b4:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
        OS_EXIT_CRITICAL();
    23b8:	2f 44       	mov	@r4,	r15	
    23ba:	b0 12 dc 13 	call	#0x13dc	
        flags_rdy             = (OS_FLAGS)0;
    23be:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
        *err                  = OS_TIMEOUT;                /* Indicate that we timed-out waiting       */
    23c2:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    23c6:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    23ca:	00 00 
        return (flags_rdy);
    23cc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    23d0:	2d 3c       	jmp	$+92     	;abs 0x242c
    } 
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
    23d2:	1f 42 88 03 	mov	&0x0388,r15	
    23d6:	94 4f 16 00 	mov	22(r15),4(r4)	;0x0016(r15), 0x0004(r4)
    23da:	04 00 
    if (consume == TRUE) {                                 /* See if we need to consume the flags      */
    23dc:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    23e0:	1c 20       	jnz	$+58     	;abs 0x241a
        switch (wait_type) {
    23e2:	5f 44 16 00 	mov.b	22(r4),	r15	;0x0016(r4)
    23e6:	2f 83       	decd	r15		
    23e8:	2f 93       	cmp	#2,	r15	;r3 As==10
    23ea:	0d 2c       	jc	$+28     	;abs 0x2406
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
    23ec:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    23f0:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    23f4:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    23f8:	3f e3       	inv	r15		
    23fa:	0e ff       	and	r15,	r14	
    23fc:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    2400:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    2404:	0a 3c       	jmp	$+22     	;abs 0x241a
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
    2406:	2f 44       	mov	@r4,	r15	
    2408:	b0 12 dc 13 	call	#0x13dc	
                 *err = OS_FLAG_ERR_WAIT_TYPE;
    240c:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2410:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    2414:	00 00 
                 return ((OS_FLAGS)0);
    2416:	0f 43       	clr	r15		
    2418:	09 3c       	jmp	$+20     	;abs 0x242c
        }
    }
    OS_EXIT_CRITICAL();
    241a:	2f 44       	mov	@r4,	r15	
    241c:	b0 12 dc 13 	call	#0x13dc	
    *err = OS_NO_ERR;                                      /* Event(s) must have occurred              */
    2420:	1f 44 1e 00 	mov	30(r4),	r15	;0x001e(r4)
    2424:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (flags_rdy);
    2428:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    242c:	31 50 1a 00 	add	#26,	r1	;#0x001a
    2430:	34 41       	pop	r4		
    2432:	30 41       	ret			

00002434 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
    2434:	04 12       	push	r4		
    2436:	21 82       	sub	#4,	r1	;r2 As==10
    2438:	04 41       	mov	r1,	r4	
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    243a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    OS_ENTER_CRITICAL();
    243e:	b0 12 d6 13 	call	#0x13d6	
    2442:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    flags = OSTCBCur->OSTCBFlagsRdy;
    2446:	1f 42 88 03 	mov	&0x0388,r15	
    244a:	94 4f 16 00 	mov	22(r15),2(r4)	;0x0016(r15), 0x0002(r4)
    244e:	02 00 
    OS_EXIT_CRITICAL();
    2450:	2f 44       	mov	@r4,	r15	
    2452:	b0 12 dc 13 	call	#0x13dc	
    return (flags);
    2456:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    245a:	21 52       	add	#4,	r1	;r2 As==10
    245c:	34 41       	pop	r4		
    245e:	30 41       	ret			

00002460 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *err)
{
    2460:	04 12       	push	r4		
    2462:	31 50 ec ff 	add	#-20,	r1	;#0xffec
    2466:	04 41       	mov	r1,	r4	
    2468:	84 4f 0c 00 	mov	r15,	12(r4)	;0x000c(r4)
    246c:	84 4e 0e 00 	mov	r14,	14(r4)	;0x000e(r4)
    2470:	c4 4d 10 00 	mov.b	r13,	16(r4)	;0x0010(r4)
    2474:	84 4c 12 00 	mov	r12,	18(r4)	;0x0012(r4)
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr;



    cpu_sr = 0;                                      /* Prevent compiler warning                       */
    2478:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
        *err = OS_FLAG_INVALID_PGRP;
        return ((OS_FLAGS)0);
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
    247c:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    2480:	6f 4f       	mov.b	@r15,	r15	
    2482:	7f 90 05 00 	cmp.b	#5,	r15	;#0x0005
    2486:	06 24       	jz	$+14     	;abs 0x2494
        *err = OS_ERR_EVENT_TYPE;
    2488:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    248c:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((OS_FLAGS)0);
    2490:	0f 43       	clr	r15		
    2492:	b3 3c       	jmp	$+360    	;abs 0x25fa
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
    2494:	b0 12 d6 13 	call	#0x13d6	
    2498:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    switch (opt) {
    249c:	5f 44 10 00 	mov.b	16(r4),	r15	;0x0010(r4)
    24a0:	0f 93       	tst	r15		
    24a2:	03 24       	jz	$+8      	;abs 0x24aa
    24a4:	1f 93       	cmp	#1,	r15	;r3 As==01
    24a6:	0e 24       	jz	$+30     	;abs 0x24c4
    24a8:	19 3c       	jmp	$+52     	;abs 0x24dc
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
    24aa:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24ae:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    24b2:	1f 44 0e 00 	mov	14(r4),	r15	;0x000e(r4)
    24b6:	3f e3       	inv	r15		
    24b8:	0e ff       	and	r15,	r14	
    24ba:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24be:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    24c2:	16 3c       	jmp	$+46     	;abs 0x24f0
             break;

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
    24c4:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24c8:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    24cc:	0e 4f       	mov	r15,	r14	
    24ce:	1e d4 0e 00 	bis	14(r4),	r14	;0x000e(r4)
    24d2:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24d6:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    24da:	0a 3c       	jmp	$+22     	;abs 0x24f0
             break;

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
    24dc:	2f 44       	mov	@r4,	r15	
    24de:	b0 12 dc 13 	call	#0x13dc	
             *err = OS_FLAG_INVALID_OPT;
    24e2:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    24e6:	ff 40 99 ff 	mov.b	#-103,	0(r15)	;#0xff99, 0x0000(r15)
    24ea:	00 00 
             return ((OS_FLAGS)0);
    24ec:	0f 43       	clr	r15		
    24ee:	85 3c       	jmp	$+268    	;abs 0x25fa
    }
    sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
    24f0:	c4 43 08 00 	mov.b	#0,	8(r4)	;r3 As==00, 0x0008(r4)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    24f4:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    24f8:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    24fc:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)
    2500:	5f 3c       	jmp	$+192    	;abs 0x25c0
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
        switch (pnode->OSFlagNodeWaitType) {
    2502:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2506:	5f 4f 0a 00 	mov.b	10(r15),r15	;0x000a(r15)
    250a:	7f f3       	and.b	#-1,	r15	;r3 As==11
    250c:	2f 93       	cmp	#2,	r15	;r3 As==10
    250e:	04 24       	jz	$+10     	;abs 0x2518
    2510:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    2514:	22 24       	jz	$+70     	;abs 0x255a
    2516:	3e 3c       	jmp	$+126    	;abs 0x2594
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
    2518:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    251c:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2520:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2524:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2528:	0d 4e       	mov	r14,	r13	
    252a:	0d ff       	and	r15,	r13	
    252c:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
    2530:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2534:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2538:	1f 94 04 00 	cmp	4(r4),	r15	;0x0004(r4)
    253c:	35 20       	jnz	$+108    	;abs 0x25a8
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    253e:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2542:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2546:	b0 12 66 27 	call	#0x2766	
    254a:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
                     if (rdy == TRUE) {                     
    254e:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    2552:	2c 20       	jnz	$+90     	;abs 0x25ac
                         sched = TRUE;                        /* When done we will reschedule          */
    2554:	d4 43 08 00 	mov.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    2558:	2e 3c       	jmp	$+94     	;abs 0x25b6
                     }
                 }
                 break;

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
    255a:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    255e:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    2562:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2566:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    256a:	0d 4e       	mov	r14,	r13	
    256c:	0d ff       	and	r15,	r13	
    256e:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
                 if (flags_rdy != (OS_FLAGS)0) {
    2572:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    2576:	1c 24       	jz	$+58     	;abs 0x25b0
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    2578:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    257c:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2580:	b0 12 66 27 	call	#0x2766	
    2584:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
                     if (rdy == TRUE) {                      
    2588:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    258c:	13 20       	jnz	$+40     	;abs 0x25b4
                         sched = TRUE;                        /* When done we will reschedule          */
    258e:	d4 43 08 00 	mov.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    2592:	11 3c       	jmp	$+36     	;abs 0x25b6
                     }
                 }
                 break;
#endif
            default:
                 OS_EXIT_CRITICAL();
    2594:	2f 44       	mov	@r4,	r15	
    2596:	b0 12 dc 13 	call	#0x13dc	
                 *err = OS_FLAG_ERR_WAIT_TYPE;
    259a:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    259e:	ff 40 97 ff 	mov.b	#-105,	0(r15)	;#0xff97, 0x0000(r15)
    25a2:	00 00 
                 return ((OS_FLAGS)0);
    25a4:	0f 43       	clr	r15		
    25a6:	29 3c       	jmp	$+84     	;abs 0x25fa
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                     
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
    25a8:	03 43       	nop			
    25aa:	05 3c       	jmp	$+12     	;abs 0x25b6
    25ac:	03 43       	nop			
    25ae:	03 3c       	jmp	$+8      	;abs 0x25b6
				     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == TRUE) {                      
                         sched = TRUE;                        /* When done we will reschedule          */
                     }
                 }
                 break;
    25b0:	03 43       	nop			
    25b2:	01 3c       	jmp	$+4      	;abs 0x25b6
    25b4:	03 43       	nop			
            default:
                 OS_EXIT_CRITICAL();
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    25b6:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    25ba:	2f 4f       	mov	@r15,	r15	
    25bc:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)
             *err = OS_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = FALSE;                                   /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
    25c0:	84 93 0a 00 	tst	10(r4)		;0x000a(r4)
    25c4:	9e 23       	jnz	$-194    	;abs 0x2502
                 *err = OS_FLAG_ERR_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    25c6:	2f 44       	mov	@r4,	r15	
    25c8:	b0 12 dc 13 	call	#0x13dc	
    if (sched == TRUE) {
    25cc:	d4 93 08 00 	cmp.b	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    25d0:	02 20       	jnz	$+6      	;abs 0x25d6
        OS_Sched();
    25d2:	b0 12 7c 1d 	call	#0x1d7c	
    }
    OS_ENTER_CRITICAL();
    25d6:	b0 12 d6 13 	call	#0x13d6	
    25da:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    flags_cur = pgrp->OSFlagFlags;
    25de:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    25e2:	94 4f 04 00 	mov	4(r15),	6(r4)	;0x0004(r15), 0x0006(r4)
    25e6:	06 00 
    OS_EXIT_CRITICAL();
    25e8:	2f 44       	mov	@r4,	r15	
    25ea:	b0 12 dc 13 	call	#0x13dc	
    *err      = OS_NO_ERR;
    25ee:	1f 44 12 00 	mov	18(r4),	r15	;0x0012(r4)
    25f2:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (flags_cur);
    25f6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
}
    25fa:	31 50 14 00 	add	#20,	r1	;#0x0014
    25fe:	34 41       	pop	r4		
    2600:	30 41       	ret			

00002602 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
    2602:	04 12       	push	r4		
    2604:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    2608:	04 41       	mov	r1,	r4	
    260a:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    260e:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    2612:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
    2616:	c4 4c 0a 00 	mov.b	r12,	10(r4)	;0x000a(r4)
    OS_FLAG_NODE  *pnode_next;
	INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
    261a:	1f 42 88 03 	mov	&0x0388,r15	
    261e:	1e 42 88 03 	mov	&0x0388,r14	
    2622:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    2626:	7e d0 20 00 	bis.b	#32,	r14	;#0x0020
    262a:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO     = FALSE;
    262e:	1f 42 88 03 	mov	&0x0388,r15	
    2632:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
    2636:	1f 42 88 03 	mov	&0x0388,r15	
    263a:	9f 44 10 00 	mov	16(r4),	24(r15)	;0x0010(r4), 0x0018(r15)
    263e:	18 00 
    OSTCBCur->OSTCBEventPtr   = (OS_EVENT *)0;
    2640:	1f 42 88 03 	mov	&0x0388,r15	
    2644:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
    2648:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    264c:	9f 44 08 00 	mov	8(r4),	8(r15)	;0x0008(r4), 0x0008(r15)
    2650:	08 00 
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
    2652:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2656:	df 44 0a 00 	mov.b	10(r4),	10(r15)	;0x000a(r4), 0x000a(r15)
    265a:	0a 00 
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
    265c:	1e 42 88 03 	mov	&0x0388,r14	
    2660:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2664:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
    2668:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    266c:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2670:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2674:	8f 4e 00 00 	mov	r14,	0(r15)	;0x0000(r15)
    pnode->OSFlagNodePrev     = (void *)0;
    2678:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    267c:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
    2680:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2684:	9f 44 04 00 	mov	4(r4),	6(r15)	;0x0004(r4), 0x0006(r15)
    2688:	06 00 
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    268a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    268e:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    2692:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
    2696:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    269a:	05 24       	jz	$+12     	;abs 0x26a6
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
    269c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    26a0:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    26a4:	02 00 
    }
    pgrp->OSFlagWaitList = (void *)pnode;
    26a6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    26aa:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    26ae:	02 00 
                                                      
    y            =  OSTCBCur->OSTCBY;		 	      /* Suspend current task until flag(s) received   */
    26b0:	1f 42 88 03 	mov	&0x0388,r15	
    26b4:	d4 4f 1e 00 	mov.b	30(r15),0(r4)	;0x001e(r15), 0x0000(r4)
    26b8:	00 00 
	OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
    26ba:	6d 44       	mov.b	@r4,	r13	
    26bc:	6f 44       	mov.b	@r4,	r15	
    26be:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    26c2:	4e 4f       	mov.b	r15,	r14	
    26c4:	1f 42 88 03 	mov	&0x0388,r15	
    26c8:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    26cc:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    26ce:	4f fe       	and.b	r14,	r15	
    26d0:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
    if (OSRdyTbl[y] == 0x00) {
    26d4:	6f 44       	mov.b	@r4,	r15	
    26d6:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    26da:	4f 93       	tst.b	r15		
    26dc:	0b 20       	jnz	$+24     	;abs 0x26f4
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
    26de:	1f 42 88 03 	mov	&0x0388,r15	
    26e2:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    26e6:	4e 4f       	mov.b	r15,	r14	
    26e8:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    26ea:	5f 42 7e 03 	mov.b	&0x037e,r15	
    26ee:	4f fe       	and.b	r14,	r15	
    26f0:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
    }
}
    26f4:	31 50 0c 00 	add	#12,	r1	;#0x000c
    26f8:	34 41       	pop	r4		
    26fa:	30 41       	ret			

000026fc <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
    26fc:	04 12       	push	r4		
    26fe:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2702:	04 41       	mov	r1,	r4	
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    2704:	3f 40 14 03 	mov	#788,	r15	;#0x0314
    2708:	3e 40 12 00 	mov	#18,	r14	;#0x0012
    270c:	b0 12 16 1d 	call	#0x1d16	
    pgrp1 = &OSFlagTbl[0];
    2710:	b4 40 14 03 	mov	#788,	2(r4)	;#0x0314, 0x0002(r4)
    2714:	02 00 
    pgrp2 = &OSFlagTbl[1];
    2716:	b4 40 1a 03 	mov	#794,	0(r4)	;#0x031a, 0x0000(r4)
    271a:	00 00 
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
    271c:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    2720:	10 3c       	jmp	$+34     	;abs 0x2742
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    2722:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2726:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
    272a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    272e:	af 44 02 00 	mov	@r4,	2(r15)	;0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
    2732:	b4 50 06 00 	add	#6,	2(r4)	;#0x0006, 0x0002(r4)
    2736:	02 00 
        pgrp2++;
    2738:	b4 50 06 00 	add	#6,	0(r4)	;#0x0006, 0x0000(r4)
    273c:	00 00 


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
    273e:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    2742:	a4 93 04 00 	cmp	#2,	4(r4)	;r3 As==10, 0x0004(r4)
    2746:	ed 2b       	jnc	$-36     	;abs 0x2722
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
    2748:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    274c:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    pgrp1->OSFlagWaitList = (void *)0;
    2750:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2754:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
    OSFlagFreeList        = (OS_FLAG_GRP *)&OSFlagTbl[0];
    2758:	b2 40 14 03 	mov	#788,	&0x0574	;#0x0314
    275c:	74 05 
#endif
}
    275e:	31 50 06 00 	add	#6,	r1	;#0x0006
    2762:	34 41       	pop	r4		
    2764:	30 41       	ret			

00002766 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
    2766:	04 12       	push	r4		
    2768:	31 82       	sub	#8,	r1	;r2 As==11
    276a:	04 41       	mov	r1,	r4	
    276c:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2770:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;  /* Point to TCB of waiting task             */
    2774:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2778:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    277c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    ptcb->OSTCBDly      = 0;
    2780:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2784:	8f 43 18 00 	mov	#0,	24(r15)	;r3 As==00, 0x0018(r15)
    ptcb->OSTCBFlagsRdy = flags_rdy;
    2788:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    278c:	9f 44 06 00 	mov	6(r4),	22(r15)	;0x0006(r4), 0x0016(r15)
    2790:	16 00 
    ptcb->OSTCBStat    &= ~OS_STAT_FLAG;
    2792:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2796:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    279a:	4e 4f       	mov.b	r15,	r14	
    279c:	7e f0 df ff 	and.b	#-33,	r14	;#0xffdf
    27a0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27a4:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    ptcb->OSTCBPendTO   = FALSE;
    27a8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27ac:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
    27b0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27b4:	5f 4f 1a 00 	mov.b	26(r15),r15	;0x001a(r15)
    27b8:	4f 93       	tst.b	r15		
    27ba:	1f 20       	jnz	$+64     	;abs 0x27fa
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
    27bc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27c0:	5e 4f 20 00 	mov.b	32(r15),r14	;0x0020(r15)
    27c4:	5f 42 7e 03 	mov.b	&0x037e,r15	
    27c8:	4f de       	bis.b	r14,	r15	
    27ca:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    27ce:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27d2:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    27d6:	4d 4f       	mov.b	r15,	r13	
    27d8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27dc:	5f 4f 1e 00 	mov.b	30(r15),r15	;0x001e(r15)
    27e0:	7f f3       	and.b	#-1,	r15	;r3 As==11
    27e2:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    27e6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    27ea:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    27ee:	4f de       	bis.b	r14,	r15	
    27f0:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        sched                   = TRUE;
    27f4:	d4 43 00 00 	mov.b	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    27f8:	02 3c       	jmp	$+6      	;abs 0x27fe
    } else {
        sched                   = FALSE;
    27fa:	c4 43 00 00 	mov.b	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    OS_FlagUnlink(pnode);
    27fe:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2802:	b0 12 0e 28 	call	#0x280e	
    return (sched);
    2806:	6f 44       	mov.b	@r4,	r15	
}
    2808:	31 52       	add	#8,	r1	;r2 As==11
    280a:	34 41       	pop	r4		
    280c:	30 41       	ret			

0000280e <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
    280e:	04 12       	push	r4		
    2810:	31 82       	sub	#8,	r1	;r2 As==11
    2812:	04 41       	mov	r1,	r4	
    2814:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
    2818:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    281c:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    2820:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    2824:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2828:	2f 4f       	mov	@r15,	r15	
    282a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
    282e:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2832:	11 20       	jnz	$+36     	;abs 0x2856
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
    2834:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2838:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    283c:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
    2840:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2844:	af 44 02 00 	mov	@r4,	2(r15)	;0x0002(r15)
        if (pnode_next != (OS_FLAG_NODE *)0) {
    2848:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    284c:	10 24       	jz	$+34     	;abs 0x286e
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
    284e:	2f 44       	mov	@r4,	r15	
    2850:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    2854:	0d 3c       	jmp	$+28     	;abs 0x2870
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
    2856:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    285a:	af 44 00 00 	mov	@r4,	0(r15)	;0x0000(r15)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
    285e:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    2862:	06 24       	jz	$+14     	;abs 0x2870
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
    2864:	2f 44       	mov	@r4,	r15	
    2866:	9f 44 02 00 	mov	2(r4),	2(r15)	;0x0002(r4), 0x0002(r15)
    286a:	02 00 
    286c:	01 3c       	jmp	$+4      	;abs 0x2870
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
        if (pnode_next != (OS_FLAG_NODE *)0) {
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
    286e:	03 43       	nop			
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
#endif
}
    2870:	31 52       	add	#8,	r1	;r2 As==11
    2872:	34 41       	pop	r4		
    2874:	30 41       	ret			

00002876 <OSMboxAccept>:
*********************************************************************************************************
*/

#if OS_MBOX_ACCEPT_EN > 0
void  *OSMboxAccept (OS_EVENT *pevent)
{
    2876:	04 12       	push	r4		
    2878:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    287c:	04 41       	mov	r1,	r4	
    287e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                               /* Allocate storage for CPU status register  */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                           /* Prevent compiler warning                  */
    2882:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
    2886:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    288a:	6f 4f       	mov.b	@r15,	r15	
    288c:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    288e:	02 24       	jz	$+6      	;abs 0x2894
        return ((void *)0);
    2890:	0f 43       	clr	r15		
    2892:	12 3c       	jmp	$+38     	;abs 0x28b8
    }
    OS_ENTER_CRITICAL();
    2894:	b0 12 d6 13 	call	#0x13d6	
    2898:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    msg                = pevent->OSEventPtr;
    289c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    28a0:	94 4f 04 00 	mov	4(r15),	2(r4)	;0x0004(r15), 0x0002(r4)
    28a4:	02 00 
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
    28a6:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    28aa:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
    OS_EXIT_CRITICAL();
    28ae:	2f 44       	mov	@r4,	r15	
    28b0:	b0 12 dc 13 	call	#0x13dc	
    return (msg);                                         /* Return the message received (or NULL)     */
    28b4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    28b8:	31 50 06 00 	add	#6,	r1	;#0x0006
    28bc:	34 41       	pop	r4		
    28be:	30 41       	ret			

000028c0 <OSMboxCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSMboxCreate (void *msg)
{
    28c0:	04 12       	push	r4		
    28c2:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    28c6:	04 41       	mov	r1,	r4	
    28c8:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    28cc:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    28d0:	5f 42 86 03 	mov.b	&0x0386,r15	
    28d4:	4f 93       	tst.b	r15		
    28d6:	02 24       	jz	$+6      	;abs 0x28dc
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    28d8:	0f 43       	clr	r15		
    28da:	2a 3c       	jmp	$+86     	;abs 0x2930
    }
    OS_ENTER_CRITICAL();
    28dc:	b0 12 d6 13 	call	#0x13d6	
    28e0:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
    28e4:	94 42 84 03 	mov	&0x0384,2(r4)	;0x0002(r4)
    28e8:	02 00 
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
    28ea:	1f 42 84 03 	mov	&0x0384,r15	
    28ee:	0f 93       	tst	r15		
    28f0:	06 24       	jz	$+14     	;abs 0x28fe
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    28f2:	1f 42 84 03 	mov	&0x0384,r15	
    28f6:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    28fa:	82 4f 84 03 	mov	r15,	&0x0384	
    }
    OS_EXIT_CRITICAL();
    28fe:	2f 44       	mov	@r4,	r15	
    2900:	b0 12 dc 13 	call	#0x13dc	
    if (pevent != (OS_EVENT *)0) {
    2904:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2908:	11 24       	jz	$+36     	;abs 0x292c
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
    290a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    290e:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        pevent->OSEventCnt     = 0;
    2912:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2916:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
        pevent->OSEventPtr     = msg;            /* Deposit message in event control block             */
    291a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    291e:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2922:	04 00 
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);
    2924:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2928:	b0 12 60 1b 	call	#0x1b60	
    }
    return (pevent);                             /* Return pointer to event control block              */
    292c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    2930:	31 50 06 00 	add	#6,	r1	;#0x0006
    2934:	34 41       	pop	r4		
    2936:	30 41       	ret			

00002938 <OSMboxPend>:
*                            if you didn't pass the proper pointer to the event control block.
*********************************************************************************************************
*/

void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    2938:	04 12       	push	r4		
    293a:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    293e:	04 41       	mov	r1,	r4	
    2940:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2944:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    2948:	84 4d 08 00 	mov	r13,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    294c:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
    2950:	5f 42 86 03 	mov.b	&0x0386,r15	
    2954:	4f 93       	tst.b	r15		
    2956:	06 24       	jz	$+14     	;abs 0x2964
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
    2958:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    295c:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((void *)0);
    2960:	0f 43       	clr	r15		
    2962:	72 3c       	jmp	$+230    	;abs 0x2a48
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    2964:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2968:	6f 4f       	mov.b	@r15,	r15	
    296a:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    296c:	06 24       	jz	$+14     	;abs 0x297a
        *err = OS_ERR_EVENT_TYPE;
    296e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2972:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((void *)0);
    2976:	0f 43       	clr	r15		
    2978:	67 3c       	jmp	$+208    	;abs 0x2a48
    }
    OS_ENTER_CRITICAL();
    297a:	b0 12 d6 13 	call	#0x13d6	
    297e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    msg = pevent->OSEventPtr;
    2982:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2986:	94 4f 04 00 	mov	4(r15),	2(r4)	;0x0004(r15), 0x0002(r4)
    298a:	02 00 
    if (msg != (void *)0) {                           /* See if there is already a message             */
    298c:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2990:	0e 24       	jz	$+30     	;abs 0x29ae
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
    2992:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2996:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
        OS_EXIT_CRITICAL();
    299a:	2f 44       	mov	@r4,	r15	
    299c:	b0 12 dc 13 	call	#0x13dc	
        *err = OS_NO_ERR;
    29a0:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    29a4:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        return (msg);                                 /* Return the message received (or NULL)         */
    29a8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    29ac:	4d 3c       	jmp	$+156    	;abs 0x2a48
    }
    OSTCBCur->OSTCBStat  |= OS_STAT_MBOX;             /* Message not available, task will pend         */
    29ae:	1f 42 88 03 	mov	&0x0388,r15	
    29b2:	1e 42 88 03 	mov	&0x0388,r14	
    29b6:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    29ba:	6e d3       	bis.b	#2,	r14	;r3 As==10
    29bc:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO = FALSE;
    29c0:	1f 42 88 03 	mov	&0x0388,r15	
    29c4:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly    = timeout;                  /* Load timeout in TCB                           */
    29c8:	1f 42 88 03 	mov	&0x0388,r15	
    29cc:	9f 44 06 00 	mov	6(r4),	24(r15)	;0x0006(r4), 0x0018(r15)
    29d0:	18 00 
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    29d2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    29d6:	b0 12 1e 1a 	call	#0x1a1e	
    OS_EXIT_CRITICAL();
    29da:	2f 44       	mov	@r4,	r15	
    29dc:	b0 12 dc 13 	call	#0x13dc	
    OS_Sched();                                       /* Find next highest priority task ready to run  */
    29e0:	b0 12 7c 1d 	call	#0x1d7c	
    OS_ENTER_CRITICAL();
    29e4:	b0 12 d6 13 	call	#0x13d6	
    29e8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we were given the message              */
    29ec:	1f 42 88 03 	mov	&0x0388,r15	
    29f0:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    29f4:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    29f6:	0e 20       	jnz	$+30     	;abs 0x2a14
        OS_EventTO(pevent);                           /* Timed out, Make task ready                    */
    29f8:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    29fc:	b0 12 ce 1a 	call	#0x1ace	
        OS_EXIT_CRITICAL();
    2a00:	2f 44       	mov	@r4,	r15	
    2a02:	b0 12 dc 13 	call	#0x13dc	
        *err = OS_TIMEOUT;                            /* Indicate that a timeout occured               */
    2a06:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2a0a:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    2a0e:	00 00 
        return ((void *)0);                           /* Return a NULL message                         */
    2a10:	0f 43       	clr	r15		
    2a12:	1a 3c       	jmp	$+54     	;abs 0x2a48
    }
    msg                     = OSTCBCur->OSTCBMsg;
    2a14:	1f 42 88 03 	mov	&0x0388,r15	
    2a18:	94 4f 14 00 	mov	20(r15),2(r4)	;0x0014(r15), 0x0002(r4)
    2a1c:	02 00 
    OSTCBCur->OSTCBMsg      = (void *)0;              /* Yes, clear message received                   */
    2a1e:	1f 42 88 03 	mov	&0x0388,r15	
    2a22:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    2a26:	1f 42 88 03 	mov	&0x0388,r15	
    2a2a:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;          /* No longer waiting for event                   */
    2a2e:	1f 42 88 03 	mov	&0x0388,r15	
    2a32:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    2a36:	2f 44       	mov	@r4,	r15	
    2a38:	b0 12 dc 13 	call	#0x13dc	
    *err                    = OS_NO_ERR;
    2a3c:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2a40:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (msg);                                     /* Return the message received                   */
    2a44:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    2a48:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2a4c:	34 41       	pop	r4		
    2a4e:	30 41       	ret			

00002a50 <OSMboxPost>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_EN > 0
INT8U  OSMboxPost (OS_EVENT *pevent, void *msg)
{
    2a50:	04 12       	push	r4		
    2a52:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2a56:	04 41       	mov	r1,	r4	
    2a58:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    2a5c:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
    

    
    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2a60:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    2a64:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2a68:	6f 4f       	mov.b	@r15,	r15	
    2a6a:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2a6c:	02 24       	jz	$+6      	;abs 0x2a72
        return (OS_ERR_EVENT_TYPE);
    2a6e:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2a70:	2d 3c       	jmp	$+92     	;abs 0x2acc
    }
    OS_ENTER_CRITICAL();
    2a72:	b0 12 d6 13 	call	#0x13d6	
    2a76:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                     /* See if any task pending on mailbox        */
    2a7a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2a7e:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2a82:	4f 93       	tst.b	r15		
    2a84:	0e 24       	jz	$+30     	;abs 0x2aa2
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX); /* Ready HPT waiting on event                */
    2a86:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2a8a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2a8e:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2a90:	b0 12 dc 18 	call	#0x18dc	
        OS_EXIT_CRITICAL();
    2a94:	2f 44       	mov	@r4,	r15	
    2a96:	b0 12 dc 13 	call	#0x13dc	
        OS_Sched();                                   /* Find highest priority task ready to run       */
    2a9a:	b0 12 7c 1d 	call	#0x1d7c	
        return (OS_NO_ERR);
    2a9e:	4f 43       	clr.b	r15		
    2aa0:	15 3c       	jmp	$+44     	;abs 0x2acc
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
    2aa2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2aa6:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2aaa:	0f 93       	tst	r15		
    2aac:	06 24       	jz	$+14     	;abs 0x2aba
        OS_EXIT_CRITICAL();
    2aae:	2f 44       	mov	@r4,	r15	
    2ab0:	b0 12 dc 13 	call	#0x13dc	
        return (OS_MBOX_FULL);
    2ab4:	7f 40 14 00 	mov.b	#20,	r15	;#0x0014
    2ab8:	09 3c       	jmp	$+20     	;abs 0x2acc
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
    2aba:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2abe:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2ac2:	04 00 
    OS_EXIT_CRITICAL();
    2ac4:	2f 44       	mov	@r4,	r15	
    2ac6:	b0 12 dc 13 	call	#0x13dc	
    return (OS_NO_ERR);
    2aca:	4f 43       	clr.b	r15		
}
    2acc:	31 50 06 00 	add	#6,	r1	;#0x0006
    2ad0:	34 41       	pop	r4		
    2ad2:	30 41       	ret			

00002ad4 <OSMboxPostOpt>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_OPT_EN > 0
INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
    2ad4:	04 12       	push	r4		
    2ad6:	31 82       	sub	#8,	r1	;r2 As==11
    2ad8:	04 41       	mov	r1,	r4	
    2ada:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    2ade:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    2ae2:	c4 4d 06 00 	mov.b	r13,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
    
    

    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2ae6:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (msg == (void *)0) {                           /* Make sure we are not posting a NULL pointer   */
        return (OS_ERR_POST_NULL_PTR);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
    2aea:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2aee:	6f 4f       	mov.b	@r15,	r15	
    2af0:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2af2:	02 24       	jz	$+6      	;abs 0x2af8
        return (OS_ERR_EVENT_TYPE);
    2af4:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2af6:	41 3c       	jmp	$+132    	;abs 0x2b7a
    }
    OS_ENTER_CRITICAL();
    2af8:	b0 12 d6 13 	call	#0x13d6	
    2afc:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on mailbox            */
    2b00:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b04:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2b08:	4f 93       	tst.b	r15		
    2b0a:	22 24       	jz	$+70     	;abs 0x2b50
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
    2b0c:	5f 44 06 00 	mov.b	6(r4),	r15	;0x0006(r4)
    2b10:	1f f3       	and	#1,	r15	;r3 As==01
    2b12:	4f 93       	tst.b	r15		
    2b14:	0f 24       	jz	$+32     	;abs 0x2b34
    2b16:	07 3c       	jmp	$+16     	;abs 0x2b26
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on mailbox     */           
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);    
    2b18:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2b1c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b20:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2b22:	b0 12 dc 18 	call	#0x18dc	
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on mailbox            */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on mailbox     */           
    2b26:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b2a:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2b2e:	4f 93       	tst.b	r15		
    2b30:	f3 23       	jnz	$-24     	;abs 0x2b18
    2b32:	07 3c       	jmp	$+16     	;abs 0x2b42
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);    
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_MBOX);  /* No,  Post to HPT waiting on mbox     */
    2b34:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    2b38:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b3c:	6d 43       	mov.b	#2,	r13	;r3 As==10
    2b3e:	b0 12 dc 18 	call	#0x18dc	
        }
        OS_EXIT_CRITICAL();
    2b42:	2f 44       	mov	@r4,	r15	
    2b44:	b0 12 dc 13 	call	#0x13dc	
        OS_Sched();                                            /* Find HPT ready to run                */
    2b48:	b0 12 7c 1d 	call	#0x1d7c	
        return (OS_NO_ERR);
    2b4c:	4f 43       	clr.b	r15		
    2b4e:	15 3c       	jmp	$+44     	;abs 0x2b7a
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
    2b50:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b54:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2b58:	0f 93       	tst	r15		
    2b5a:	06 24       	jz	$+14     	;abs 0x2b68
        OS_EXIT_CRITICAL();
    2b5c:	2f 44       	mov	@r4,	r15	
    2b5e:	b0 12 dc 13 	call	#0x13dc	
        return (OS_MBOX_FULL);
    2b62:	7f 40 14 00 	mov.b	#20,	r15	;#0x0014
    2b66:	09 3c       	jmp	$+20     	;abs 0x2b7a
    }
    pevent->OSEventPtr = msg;                         /* Place message in mailbox                      */
    2b68:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2b6c:	9f 44 04 00 	mov	4(r4),	4(r15)	;0x0004(r4), 0x0004(r15)
    2b70:	04 00 
    OS_EXIT_CRITICAL();
    2b72:	2f 44       	mov	@r4,	r15	
    2b74:	b0 12 dc 13 	call	#0x13dc	
    return (OS_NO_ERR);
    2b78:	4f 43       	clr.b	r15		
}
    2b7a:	31 52       	add	#8,	r1	;r2 As==11
    2b7c:	34 41       	pop	r4		
    2b7e:	30 41       	ret			

00002b80 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *err)
{
    2b80:	04 12       	push	r4		
    2b82:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    2b86:	04 41       	mov	r1,	r4	
    2b88:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2b8c:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2b90:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
        *err = OS_ERR_PEVENT_NULL;
        return ((void *)0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
    2b94:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2b98:	6f 4f       	mov.b	@r15,	r15	
    2b9a:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    2b9c:	06 24       	jz	$+14     	;abs 0x2baa
        *err = OS_ERR_EVENT_TYPE;
    2b9e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2ba2:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
        return ((void *)0);
    2ba6:	0f 43       	clr	r15		
    2ba8:	49 3c       	jmp	$+148    	;abs 0x2c3c
    }
    OS_ENTER_CRITICAL();
    2baa:	b0 12 d6 13 	call	#0x13d6	
    2bae:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    2bb2:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2bb6:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2bba:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
    2bbe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bc2:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2bc6:	0f 93       	tst	r15		
    2bc8:	2d 24       	jz	$+92     	;abs 0x2c24
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
    2bca:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bce:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2bd2:	a4 4f 04 00 	mov	@r15,	4(r4)	;0x0004(r4)
    2bd6:	0e 4f       	mov	r15,	r14	
    2bd8:	2e 53       	incd	r14		
    2bda:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bde:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
    2be2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2be6:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2bea:	0e 4f       	mov	r15,	r14	
    2bec:	3e 53       	add	#-1,	r14	;r3 As==11
    2bee:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bf2:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
    2bf6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2bfa:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    2bfe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c02:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2c06:	0e 9f       	cmp	r15,	r14	
    2c08:	08 20       	jnz	$+18     	;abs 0x2c1a
            pq->OSQOut = pq->OSQStart;
    2c0a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c0e:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2c12:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2c16:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        *err = OS_NO_ERR;
    2c1a:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2c1e:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    2c22:	07 3c       	jmp	$+16     	;abs 0x2c32
    } else {
        *err = OS_Q_EMPTY;
    2c24:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2c28:	ff 40 1f 00 	mov.b	#31,	0(r15)	;#0x001f, 0x0000(r15)
    2c2c:	00 00 
        msg  = (void *)0;                        /* Queue is empty                                     */
    2c2e:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    }
    OS_EXIT_CRITICAL();
    2c32:	2f 44       	mov	@r4,	r15	
    2c34:	b0 12 dc 13 	call	#0x13dc	
    return (msg);                                /* Return message received (or NULL)                  */
    2c38:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2c3c:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2c40:	34 41       	pop	r4		
    2c42:	30 41       	ret			

00002c44 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
    2c44:	04 12       	push	r4		
    2c46:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    2c4a:	04 41       	mov	r1,	r4	
    2c4c:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2c50:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2c54:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    2c58:	5f 42 86 03 	mov.b	&0x0386,r15	
    2c5c:	4f 93       	tst.b	r15		
    2c5e:	02 24       	jz	$+6      	;abs 0x2c64
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
    2c60:	0f 43       	clr	r15		
    2c62:	6d 3c       	jmp	$+220    	;abs 0x2d3e
    }
    OS_ENTER_CRITICAL();
    2c64:	b0 12 d6 13 	call	#0x13d6	
    2c68:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
    2c6c:	94 42 84 03 	mov	&0x0384,4(r4)	;0x0004(r4)
    2c70:	04 00 
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
    2c72:	1f 42 84 03 	mov	&0x0384,r15	
    2c76:	0f 93       	tst	r15		
    2c78:	06 24       	jz	$+14     	;abs 0x2c86
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    2c7a:	1f 42 84 03 	mov	&0x0384,r15	
    2c7e:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2c82:	82 4f 84 03 	mov	r15,	&0x0384	
    }
    OS_EXIT_CRITICAL();
    2c86:	2f 44       	mov	@r4,	r15	
    2c88:	b0 12 dc 13 	call	#0x13dc	
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
    2c8c:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    2c90:	54 24       	jz	$+170    	;abs 0x2d3a
        OS_ENTER_CRITICAL();
    2c92:	b0 12 d6 13 	call	#0x13d6	
    2c96:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
    2c9a:	94 42 7c 03 	mov	&0x037c,2(r4)	;0x0002(r4)
    2c9e:	02 00 
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
    2ca0:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    2ca4:	3c 24       	jz	$+122    	;abs 0x2d1e
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
    2ca6:	1f 42 7c 03 	mov	&0x037c,r15	
    2caa:	2f 4f       	mov	@r15,	r15	
    2cac:	82 4f 7c 03 	mov	r15,	&0x037c	
            OS_EXIT_CRITICAL();
    2cb0:	2f 44       	mov	@r4,	r15	
    2cb2:	b0 12 dc 13 	call	#0x13dc	
            pq->OSQStart           = start;               /*      Initialize the queue                 */
    2cb6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cba:	9f 44 06 00 	mov	6(r4),	2(r15)	;0x0006(r4), 0x0002(r15)
    2cbe:	02 00 
            pq->OSQEnd             = &start[size];
    2cc0:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    2cc4:	0f 5f       	rla	r15		
    2cc6:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    2cca:	0e 5f       	add	r15,	r14	
    2ccc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cd0:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
            pq->OSQIn              = start;
    2cd4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cd8:	9f 44 06 00 	mov	6(r4),	6(r15)	;0x0006(r4), 0x0006(r15)
    2cdc:	06 00 
            pq->OSQOut             = start;
    2cde:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2ce2:	9f 44 06 00 	mov	6(r4),	8(r15)	;0x0006(r4), 0x0008(r15)
    2ce6:	08 00 
            pq->OSQSize            = size;
    2ce8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cec:	9f 44 08 00 	mov	8(r4),	10(r15)	;0x0008(r4), 0x000a(r15)
    2cf0:	0a 00 
            pq->OSQEntries         = 0;
    2cf2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2cf6:	8f 43 0c 00 	mov	#0,	12(r15)	;r3 As==00, 0x000c(r15)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
    2cfa:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2cfe:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
            pevent->OSEventCnt     = 0;
    2d02:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d06:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
            pevent->OSEventPtr     = pq;
    2d0a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d0e:	9f 44 02 00 	mov	2(r4),	4(r15)	;0x0002(r4), 0x0004(r15)
    2d12:	04 00 
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
            pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
    2d14:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d18:	b0 12 60 1b 	call	#0x1b60	
    2d1c:	0e 3c       	jmp	$+30     	;abs 0x2d3a
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
    2d1e:	1e 42 84 03 	mov	&0x0384,r14	
    2d22:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d26:	8f 4e 04 00 	mov	r14,	4(r15)	;0x0004(r15)
            OSEventFreeList    = pevent;
    2d2a:	92 44 04 00 	mov	4(r4),	&0x0384	;0x0004(r4)
    2d2e:	84 03 
            OS_EXIT_CRITICAL();
    2d30:	2f 44       	mov	@r4,	r15	
    2d32:	b0 12 dc 13 	call	#0x13dc	
            pevent = (OS_EVENT *)0;
    2d36:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
        }
    }
    return (pevent);
    2d3a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2d3e:	31 50 0a 00 	add	#10,	r1	;#0x000a
    2d42:	34 41       	pop	r4		
    2d44:	30 41       	ret			

00002d46 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
    2d46:	04 12       	push	r4		
    2d48:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    2d4c:	04 41       	mov	r1,	r4	
    2d4e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2d52:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
        return (OS_ERR_EVENT_TYPE);
    }
#endif
    OS_ENTER_CRITICAL();
    2d56:	b0 12 d6 13 	call	#0x13d6	
    2d5a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
    2d5e:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2d62:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2d66:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    pq->OSQIn      = pq->OSQStart;
    2d6a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d6e:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2d72:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d76:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    pq->OSQOut     = pq->OSQStart;
    2d7a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d7e:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2d82:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d86:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    pq->OSQEntries = 0;
    2d8a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2d8e:	8f 43 0c 00 	mov	#0,	12(r15)	;r3 As==00, 0x000c(r15)
    OS_EXIT_CRITICAL();
    2d92:	2f 44       	mov	@r4,	r15	
    2d94:	b0 12 dc 13 	call	#0x13dc	
    return (OS_NO_ERR);
    2d98:	4f 43       	clr.b	r15		
}
    2d9a:	31 50 06 00 	add	#6,	r1	;#0x0006
    2d9e:	34 41       	pop	r4		
    2da0:	30 41       	ret			

00002da2 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    2da2:	04 12       	push	r4		
    2da4:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    2da8:	04 41       	mov	r1,	r4	
    2daa:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    2dae:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    2db2:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    2db6:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
    2dba:	5f 42 86 03 	mov.b	&0x0386,r15	
    2dbe:	4f 93       	tst.b	r15		
    2dc0:	06 24       	jz	$+14     	;abs 0x2dce
        *err = OS_ERR_PEND_ISR;                  /* ... can't PEND from an ISR                         */
    2dc2:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2dc6:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
        return ((void *)0);
    2dca:	0f 43       	clr	r15		
    2dcc:	8f 3c       	jmp	$+288    	;abs 0x2eec
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
        *err = OS_ERR_EVENT_TYPE;
        return ((void *)0);
    }
#endif
    OS_ENTER_CRITICAL();
    2dce:	b0 12 d6 13 	call	#0x13d6	
    2dd2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
    2dd6:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2dda:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2dde:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
    2de2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2de6:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2dea:	0f 93       	tst	r15		
    2dec:	32 24       	jz	$+102    	;abs 0x2e52
        msg = *pq->OSQOut++;                     /* Yes, extract oldest message from the queue         */
    2dee:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2df2:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    2df6:	a4 4f 04 00 	mov	@r15,	4(r4)	;0x0004(r4)
    2dfa:	0e 4f       	mov	r15,	r14	
    2dfc:	2e 53       	incd	r14		
    2dfe:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e02:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
    2e06:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e0a:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2e0e:	0e 4f       	mov	r15,	r14	
    2e10:	3e 53       	add	#-1,	r14	;r3 As==11
    2e12:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e16:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
    2e1a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e1e:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    2e22:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e26:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2e2a:	0e 9f       	cmp	r15,	r14	
    2e2c:	08 20       	jnz	$+18     	;abs 0x2e3e
            pq->OSQOut = pq->OSQStart;
    2e2e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e32:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2e36:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2e3a:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        OS_EXIT_CRITICAL();
    2e3e:	2f 44       	mov	@r4,	r15	
    2e40:	b0 12 dc 13 	call	#0x13dc	
        *err = OS_NO_ERR;
    2e44:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2e48:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
        return (msg);                            /* Return message received                            */
    2e4c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2e50:	4d 3c       	jmp	$+156    	;abs 0x2eec
    }
    OSTCBCur->OSTCBStat   |= OS_STAT_Q;          /* Task will have to pend for a message to be posted  */
    2e52:	1f 42 88 03 	mov	&0x0388,r15	
    2e56:	1e 42 88 03 	mov	&0x0388,r14	
    2e5a:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    2e5e:	6e d2       	bis.b	#4,	r14	;r2 As==10
    2e60:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO  = FALSE;
    2e64:	1f 42 88 03 	mov	&0x0388,r15	
    2e68:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly     = timeout;            /* Load timeout into TCB                              */
    2e6c:	1f 42 88 03 	mov	&0x0388,r15	
    2e70:	9f 44 08 00 	mov	8(r4),	24(r15)	;0x0008(r4), 0x0018(r15)
    2e74:	18 00 
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
    2e76:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2e7a:	b0 12 1e 1a 	call	#0x1a1e	
    OS_EXIT_CRITICAL();
    2e7e:	2f 44       	mov	@r4,	r15	
    2e80:	b0 12 dc 13 	call	#0x13dc	
    OS_Sched();                                  /* Find next highest priority task ready to run       */
    2e84:	b0 12 7c 1d 	call	#0x1d7c	
    OS_ENTER_CRITICAL();
    2e88:	b0 12 d6 13 	call	#0x13d6	
    2e8c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {         /* Was task readied because of a timeout?             */
    2e90:	1f 42 88 03 	mov	&0x0388,r15	
    2e94:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    2e98:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    2e9a:	0e 20       	jnz	$+30     	;abs 0x2eb8
        OS_EventTO(pevent);                      /* Yes                                                */
    2e9c:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    2ea0:	b0 12 ce 1a 	call	#0x1ace	
        OS_EXIT_CRITICAL();
    2ea4:	2f 44       	mov	@r4,	r15	
    2ea6:	b0 12 dc 13 	call	#0x13dc	
        *err = OS_TIMEOUT;                       /*     Indicate a timeout occured                     */
    2eaa:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2eae:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    2eb2:	00 00 
        return ((void *)0);                      /*     No message received                            */
    2eb4:	0f 43       	clr	r15		
    2eb6:	1a 3c       	jmp	$+54     	;abs 0x2eec
    }
    msg                     = OSTCBCur->OSTCBMsg;/* No, Extract message from TCB (Put there by QPost)  */
    2eb8:	1f 42 88 03 	mov	&0x0388,r15	
    2ebc:	94 4f 14 00 	mov	20(r15),4(r4)	;0x0014(r15), 0x0004(r4)
    2ec0:	04 00 
    OSTCBCur->OSTCBMsg      = (void *)0;
    2ec2:	1f 42 88 03 	mov	&0x0388,r15	
    2ec6:	8f 43 14 00 	mov	#0,	20(r15)	;r3 As==00, 0x0014(r15)
    OSTCBCur->OSTCBStat     = OS_STAT_RDY;
    2eca:	1f 42 88 03 	mov	&0x0388,r15	
    2ece:	cf 43 1a 00 	mov.b	#0,	26(r15)	;r3 As==00, 0x001a(r15)
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;     /*     No longer waiting for event                    */
    2ed2:	1f 42 88 03 	mov	&0x0388,r15	
    2ed6:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    2eda:	2f 44       	mov	@r4,	r15	
    2edc:	b0 12 dc 13 	call	#0x13dc	
    *err                    = OS_NO_ERR;
    2ee0:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    2ee4:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    return (msg);                                /*     Return message received                        */
    2ee8:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
}
    2eec:	31 50 0c 00 	add	#12,	r1	;#0x000c
    2ef0:	34 41       	pop	r4		
    2ef2:	30 41       	ret			

00002ef4 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *msg)
{
    2ef4:	04 12       	push	r4		
    2ef6:	31 82       	sub	#8,	r1	;r2 As==11
    2ef8:	04 41       	mov	r1,	r4	
    2efa:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2efe:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    2f02:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
    2f06:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f0a:	6f 4f       	mov.b	@r15,	r15	
    2f0c:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    2f0e:	02 24       	jz	$+6      	;abs 0x2f14
        return (OS_ERR_EVENT_TYPE);
    2f10:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2f12:	5b 3c       	jmp	$+184    	;abs 0x2fca
    }
    OS_ENTER_CRITICAL();
    2f14:	b0 12 d6 13 	call	#0x13d6	
    2f18:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                  /* See if any task pending on queue             */
    2f1c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f20:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    2f24:	4f 93       	tst.b	r15		
    2f26:	0e 24       	jz	$+30     	;abs 0x2f44
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q); /* Ready highest priority task waiting on event */
    2f28:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    2f2c:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f30:	6d 42       	mov.b	#4,	r13	;r2 As==10
    2f32:	b0 12 dc 18 	call	#0x18dc	
        OS_EXIT_CRITICAL();
    2f36:	2f 44       	mov	@r4,	r15	
    2f38:	b0 12 dc 13 	call	#0x13dc	
        OS_Sched();                                    /* Find highest priority task ready to run      */
    2f3c:	b0 12 7c 1d 	call	#0x1d7c	
        return (OS_NO_ERR);
    2f40:	4f 43       	clr.b	r15		
    2f42:	43 3c       	jmp	$+136    	;abs 0x2fca
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
    2f44:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2f48:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2f4c:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
    2f50:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f54:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    2f58:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f5c:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    2f60:	0e 9f       	cmp	r15,	r14	
    2f62:	06 28       	jnc	$+14     	;abs 0x2f70
        OS_EXIT_CRITICAL();
    2f64:	2f 44       	mov	@r4,	r15	
    2f66:	b0 12 dc 13 	call	#0x13dc	
        return (OS_Q_FULL);
    2f6a:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    2f6e:	2d 3c       	jmp	$+92     	;abs 0x2fca
    }
    *pq->OSQIn++ = msg;                                /* Insert message into queue                    */
    2f70:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f74:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    2f78:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    2f7c:	00 00 
    2f7e:	0e 4f       	mov	r15,	r14	
    2f80:	2e 53       	incd	r14		
    2f82:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f86:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
    2f8a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f8e:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    2f92:	0e 4f       	mov	r15,	r14	
    2f94:	1e 53       	inc	r14		
    2f96:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2f9a:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
    2f9e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fa2:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    2fa6:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2faa:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    2fae:	0e 9f       	cmp	r15,	r14	
    2fb0:	08 20       	jnz	$+18     	;abs 0x2fc2
        pq->OSQIn = pq->OSQStart;
    2fb2:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fb6:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    2fba:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    2fbe:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
    }
    OS_EXIT_CRITICAL();
    2fc2:	2f 44       	mov	@r4,	r15	
    2fc4:	b0 12 dc 13 	call	#0x13dc	
    return (OS_NO_ERR);
    2fc8:	4f 43       	clr.b	r15		
}
    2fca:	31 52       	add	#8,	r1	;r2 As==11
    2fcc:	34 41       	pop	r4		
    2fce:	30 41       	ret			

00002fd0 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *msg)
{
    2fd0:	04 12       	push	r4		
    2fd2:	31 82       	sub	#8,	r1	;r2 As==11
    2fd4:	04 41       	mov	r1,	r4	
    2fd6:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    2fda:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    2fde:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
    2fe2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2fe6:	6f 4f       	mov.b	@r15,	r15	
    2fe8:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    2fea:	02 24       	jz	$+6      	;abs 0x2ff0
        return (OS_ERR_EVENT_TYPE);
    2fec:	5f 43       	mov.b	#1,	r15	;r3 As==01
    2fee:	5f 3c       	jmp	$+192    	;abs 0x30ae
    }
    OS_ENTER_CRITICAL();
    2ff0:	b0 12 d6 13 	call	#0x13d6	
    2ff4:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
    2ff8:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    2ffc:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3000:	4f 93       	tst.b	r15		
    3002:	0e 24       	jz	$+30     	;abs 0x3020
        (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);/* Ready highest priority task waiting on event  */
    3004:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    3008:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    300c:	6d 42       	mov.b	#4,	r13	;r2 As==10
    300e:	b0 12 dc 18 	call	#0x18dc	
        OS_EXIT_CRITICAL();
    3012:	2f 44       	mov	@r4,	r15	
    3014:	b0 12 dc 13 	call	#0x13dc	
        OS_Sched();                                   /* Find highest priority task ready to run       */
    3018:	b0 12 7c 1d 	call	#0x1d7c	
        return (OS_NO_ERR);
    301c:	4f 43       	clr.b	r15		
    301e:	47 3c       	jmp	$+144    	;abs 0x30ae
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    3020:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3024:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    3028:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
    302c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3030:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    3034:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3038:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    303c:	0e 9f       	cmp	r15,	r14	
    303e:	06 28       	jnc	$+14     	;abs 0x304c
        OS_EXIT_CRITICAL();
    3040:	2f 44       	mov	@r4,	r15	
    3042:	b0 12 dc 13 	call	#0x13dc	
        return (OS_Q_FULL);
    3046:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    304a:	31 3c       	jmp	$+100    	;abs 0x30ae
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
    304c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3050:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    3054:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3058:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    305c:	0e 9f       	cmp	r15,	r14	
    305e:	08 20       	jnz	$+18     	;abs 0x3070
        pq->OSQOut = pq->OSQEnd;
    3060:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3064:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    3068:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    306c:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    }
    pq->OSQOut--;
    3070:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3074:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    3078:	0e 4f       	mov	r15,	r14	
    307a:	2e 83       	decd	r14		
    307c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3080:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
    *pq->OSQOut = msg;                                /* Insert message into queue                     */
    3084:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3088:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    308c:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    3090:	00 00 
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    3092:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3096:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    309a:	0e 4f       	mov	r15,	r14	
    309c:	1e 53       	inc	r14		
    309e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    30a2:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    OS_EXIT_CRITICAL();
    30a6:	2f 44       	mov	@r4,	r15	
    30a8:	b0 12 dc 13 	call	#0x13dc	
    return (OS_NO_ERR);
    30ac:	4f 43       	clr.b	r15		
}
    30ae:	31 52       	add	#8,	r1	;r2 As==11
    30b0:	34 41       	pop	r4		
    30b2:	30 41       	ret			

000030b4 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *msg, INT8U opt)
{
    30b4:	04 12       	push	r4		
    30b6:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    30ba:	04 41       	mov	r1,	r4	
    30bc:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
    30c0:	84 4e 06 00 	mov	r14,	6(r4)	;0x0006(r4)
    30c4:	c4 4d 08 00 	mov.b	r13,	8(r4)	;0x0008(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;
                     


    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    30c8:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
    30cc:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    30d0:	6f 4f       	mov.b	@r15,	r15	
    30d2:	6f 93       	cmp.b	#2,	r15	;r3 As==10
    30d4:	02 24       	jz	$+6      	;abs 0x30da
        return (OS_ERR_EVENT_TYPE);
    30d6:	5f 43       	mov.b	#1,	r15	;r3 As==01
    30d8:	97 3c       	jmp	$+304    	;abs 0x3208
    }
    OS_ENTER_CRITICAL();
    30da:	b0 12 d6 13 	call	#0x13d6	
    30de:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
    30e2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    30e6:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    30ea:	4f 93       	tst.b	r15		
    30ec:	22 24       	jz	$+70     	;abs 0x3132
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
    30ee:	5f 44 08 00 	mov.b	8(r4),	r15	;0x0008(r4)
    30f2:	1f f3       	and	#1,	r15	;r3 As==01
    30f4:	4f 93       	tst.b	r15		
    30f6:	0f 24       	jz	$+32     	;abs 0x3116
    30f8:	07 3c       	jmp	$+16     	;abs 0x3108
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
    30fa:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    30fe:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3102:	6d 42       	mov.b	#4,	r13	;r2 As==10
    3104:	b0 12 dc 18 	call	#0x18dc	
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0x00) {      /* Yes, Post to ALL tasks waiting on queue       */
    3108:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    310c:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3110:	4f 93       	tst.b	r15		
    3112:	f3 23       	jnz	$-24     	;abs 0x30fa
    3114:	07 3c       	jmp	$+16     	;abs 0x3124
                (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);
            }
        } else {
            (void)OS_EventTaskRdy(pevent, msg, OS_STAT_Q);  /* No,  Post to HPT waiting on queue       */
    3116:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    311a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    311e:	6d 42       	mov.b	#4,	r13	;r2 As==10
    3120:	b0 12 dc 18 	call	#0x18dc	
        }
        OS_EXIT_CRITICAL();
    3124:	2f 44       	mov	@r4,	r15	
    3126:	b0 12 dc 13 	call	#0x13dc	
        OS_Sched();                                         /* Find highest priority task ready to run */
    312a:	b0 12 7c 1d 	call	#0x1d7c	
        return (OS_NO_ERR);
    312e:	4f 43       	clr.b	r15		
    3130:	6b 3c       	jmp	$+216    	;abs 0x3208
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
    3132:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3136:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    313a:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
    313e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3142:	1e 4f 0c 00 	mov	12(r15),r14	;0x000c(r15)
    3146:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    314a:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    314e:	0e 9f       	cmp	r15,	r14	
    3150:	06 28       	jnc	$+14     	;abs 0x315e
        OS_EXIT_CRITICAL();
    3152:	2f 44       	mov	@r4,	r15	
    3154:	b0 12 dc 13 	call	#0x13dc	
        return (OS_Q_FULL);
    3158:	7f 40 1e 00 	mov.b	#30,	r15	;#0x001e
    315c:	55 3c       	jmp	$+172    	;abs 0x3208
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
    315e:	5f 44 08 00 	mov.b	8(r4),	r15	;0x0008(r4)
    3162:	2f f3       	and	#2,	r15	;r3 As==10
    3164:	24 24       	jz	$+74     	;abs 0x31ae
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
    3166:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    316a:	1e 4f 08 00 	mov	8(r15),	r14	;0x0008(r15)
    316e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3172:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    3176:	0e 9f       	cmp	r15,	r14	
    3178:	08 20       	jnz	$+18     	;abs 0x318a
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
    317a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    317e:	1e 4f 04 00 	mov	4(r15),	r14	;0x0004(r15)
    3182:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3186:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        }
        pq->OSQOut--;
    318a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    318e:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    3192:	0e 4f       	mov	r15,	r14	
    3194:	2e 83       	decd	r14		
    3196:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    319a:	8f 4e 08 00 	mov	r14,	8(r15)	;0x0008(r15)
        *pq->OSQOut = msg;                            /*      Insert message into queue                */
    319e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31a2:	1f 4f 08 00 	mov	8(r15),	r15	;0x0008(r15)
    31a6:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    31aa:	00 00 
    31ac:	1f 3c       	jmp	$+64     	;abs 0x31ec
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = msg;                           /*      Insert message into queue                */
    31ae:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31b2:	1f 4f 06 00 	mov	6(r15),	r15	;0x0006(r15)
    31b6:	9f 44 06 00 	mov	6(r4),	0(r15)	;0x0006(r4), 0x0000(r15)
    31ba:	00 00 
    31bc:	0e 4f       	mov	r15,	r14	
    31be:	2e 53       	incd	r14		
    31c0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31c4:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
    31c8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31cc:	1e 4f 06 00 	mov	6(r15),	r14	;0x0006(r15)
    31d0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31d4:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    31d8:	0e 9f       	cmp	r15,	r14	
    31da:	08 20       	jnz	$+18     	;abs 0x31ec
            pq->OSQIn = pq->OSQStart;
    31dc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31e0:	1e 4f 02 00 	mov	2(r15),	r14	;0x0002(r15)
    31e4:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31e8:	8f 4e 06 00 	mov	r14,	6(r15)	;0x0006(r15)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
    31ec:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31f0:	1f 4f 0c 00 	mov	12(r15),r15	;0x000c(r15)
    31f4:	0e 4f       	mov	r15,	r14	
    31f6:	1e 53       	inc	r14		
    31f8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    31fc:	8f 4e 0c 00 	mov	r14,	12(r15)	;0x000c(r15)
    OS_EXIT_CRITICAL();
    3200:	2f 44       	mov	@r4,	r15	
    3202:	b0 12 dc 13 	call	#0x13dc	
    return (OS_NO_ERR);
    3206:	4f 43       	clr.b	r15		
}
    3208:	31 50 0a 00 	add	#10,	r1	;#0x000a
    320c:	34 41       	pop	r4		
    320e:	30 41       	ret			

00003210 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
    3210:	04 12       	push	r4		
    3212:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3216:	04 41       	mov	r1,	r4	
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    3218:	3f 40 34 03 	mov	#820,	r15	;#0x0334
    321c:	3e 40 46 00 	mov	#70,	r14	;#0x0046
    3220:	b0 12 16 1d 	call	#0x1d16	
    pq1 = &OSQTbl[0];
    3224:	b4 40 34 03 	mov	#820,	2(r4)	;#0x0334, 0x0002(r4)
    3228:	02 00 
    pq2 = &OSQTbl[1];
    322a:	b4 40 42 03 	mov	#834,	0(r4)	;#0x0342, 0x0000(r4)
    322e:	00 00 
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
    3230:	84 43 04 00 	mov	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    3234:	0c 3c       	jmp	$+26     	;abs 0x324e
        pq1->OSQPtr = pq2;
    3236:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    323a:	af 44 00 00 	mov	@r4,	0(r15)	;0x0000(r15)
        pq1++;
    323e:	b4 50 0e 00 	add	#14,	2(r4)	;#0x000e, 0x0002(r4)
    3242:	02 00 
        pq2++;
    3244:	b4 50 0e 00 	add	#14,	0(r4)	;#0x000e, 0x0000(r4)
    3248:	00 00 


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
    324a:	94 53 04 00 	inc	4(r4)		;0x0004(r4)
    324e:	a4 92 04 00 	cmp	#4,	4(r4)	;r2 As==10, 0x0004(r4)
    3252:	f1 2b       	jnc	$-28     	;abs 0x3236
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
    3254:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3258:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OSQFreeList = &OSQTbl[0];
    325c:	b2 40 34 03 	mov	#820,	&0x037c	;#0x0334
    3260:	7c 03 
#endif
}
    3262:	31 50 06 00 	add	#6,	r1	;#0x0006
    3266:	34 41       	pop	r4		
    3268:	30 41       	ret			

0000326a <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
    326a:	04 12       	push	r4		
    326c:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3270:	04 41       	mov	r1,	r4	
    3272:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    3276:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        return (0);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
    327a:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    327e:	6f 4f       	mov.b	@r15,	r15	
    3280:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    3284:	02 24       	jz	$+6      	;abs 0x328a
        return (0);
    3286:	0f 43       	clr	r15		
    3288:	1b 3c       	jmp	$+56     	;abs 0x32c0
    }
    OS_ENTER_CRITICAL();
    328a:	b0 12 d6 13 	call	#0x13d6	
    328e:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    cnt = pevent->OSEventCnt;
    3292:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3296:	94 4f 02 00 	mov	2(r15),	2(r4)	;0x0002(r15), 0x0002(r4)
    329a:	02 00 
    if (cnt > 0) {                                    /* See if resource is available                  */
    329c:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    32a0:	0a 24       	jz	$+22     	;abs 0x32b6
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
    32a2:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    32a6:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    32aa:	0e 4f       	mov	r15,	r14	
    32ac:	3e 53       	add	#-1,	r14	;r3 As==11
    32ae:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    32b2:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
    }
    OS_EXIT_CRITICAL();
    32b6:	2f 44       	mov	@r4,	r15	
    32b8:	b0 12 dc 13 	call	#0x13dc	
    return (cnt);                                     /* Return semaphore count                        */
    32bc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    32c0:	31 50 06 00 	add	#6,	r1	;#0x0006
    32c4:	34 41       	pop	r4		
    32c6:	30 41       	ret			

000032c8 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
    32c8:	04 12       	push	r4		
    32ca:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    32ce:	04 41       	mov	r1,	r4	
    32d0:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    32d4:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
    32d8:	5f 42 86 03 	mov.b	&0x0386,r15	
    32dc:	4f 93       	tst.b	r15		
    32de:	02 24       	jz	$+6      	;abs 0x32e4
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
    32e0:	0f 43       	clr	r15		
    32e2:	2b 3c       	jmp	$+88     	;abs 0x333a
    }
    OS_ENTER_CRITICAL();
    32e4:	b0 12 d6 13 	call	#0x13d6	
    32e8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
    32ec:	94 42 84 03 	mov	&0x0384,2(r4)	;0x0002(r4)
    32f0:	02 00 
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
    32f2:	1f 42 84 03 	mov	&0x0384,r15	
    32f6:	0f 93       	tst	r15		
    32f8:	06 24       	jz	$+14     	;abs 0x3306
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    32fa:	1f 42 84 03 	mov	&0x0384,r15	
    32fe:	1f 4f 04 00 	mov	4(r15),	r15	;0x0004(r15)
    3302:	82 4f 84 03 	mov	r15,	&0x0384	
    }
    OS_EXIT_CRITICAL();
    3306:	2f 44       	mov	@r4,	r15	
    3308:	b0 12 dc 13 	call	#0x13dc	
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
    330c:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3310:	12 24       	jz	$+38     	;abs 0x3336
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
    3312:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3316:	ff 40 03 00 	mov.b	#3,	0(r15)	;#0x0003, 0x0000(r15)
    331a:	00 00 
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
    331c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3320:	9f 44 04 00 	mov	4(r4),	2(r15)	;0x0004(r4), 0x0002(r15)
    3324:	02 00 
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
    3326:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    332a:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
        pevent->OSEventName[1] = OS_ASCII_NUL;
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
    332e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3332:	b0 12 60 1b 	call	#0x1b60	
    }
    return (pevent);
    3336:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
}
    333a:	31 50 06 00 	add	#6,	r1	;#0x0006
    333e:	34 41       	pop	r4		
    3340:	30 41       	ret			

00003342 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/

void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)
{
    3342:	04 12       	push	r4		
    3344:	31 82       	sub	#8,	r1	;r2 As==11
    3346:	04 41       	mov	r1,	r4	
    3348:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    334c:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    3350:	84 4d 06 00 	mov	r13,	6(r4)	;0x0006(r4)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                       /* Prevent compiler warning                      */
    3354:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
    3358:	5f 42 86 03 	mov.b	&0x0386,r15	
    335c:	4f 93       	tst.b	r15		
    335e:	05 24       	jz	$+12     	;abs 0x336a
        *err = OS_ERR_PEND_ISR;                       /* ... can't PEND from an ISR                    */
    3360:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3364:	ef 43 00 00 	mov.b	#2,	0(r15)	;r3 As==10, 0x0000(r15)
    3368:	64 3c       	jmp	$+202    	;abs 0x3432
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
        *err = OS_ERR_PEVENT_NULL;
        return;
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
    336a:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    336e:	6f 4f       	mov.b	@r15,	r15	
    3370:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    3374:	05 24       	jz	$+12     	;abs 0x3380
        *err = OS_ERR_EVENT_TYPE;
    3376:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    337a:	df 43 00 00 	mov.b	#1,	0(r15)	;r3 As==01, 0x0000(r15)
    337e:	59 3c       	jmp	$+180    	;abs 0x3432
        return;
    }
    OS_ENTER_CRITICAL();
    3380:	b0 12 d6 13 	call	#0x13d6	
    3384:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
    3388:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    338c:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    3390:	0f 93       	tst	r15		
    3392:	12 24       	jz	$+38     	;abs 0x33b8
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
    3394:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3398:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    339c:	0e 4f       	mov	r15,	r14	
    339e:	3e 53       	add	#-1,	r14	;r3 As==11
    33a0:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33a4:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
        OS_EXIT_CRITICAL();
    33a8:	2f 44       	mov	@r4,	r15	
    33aa:	b0 12 dc 13 	call	#0x13dc	
        *err = OS_NO_ERR;
    33ae:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    33b2:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    33b6:	3d 3c       	jmp	$+124    	;abs 0x3432
        return;
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat   |= OS_STAT_SEM;             /* Resource not available, pend on semaphore     */
    33b8:	1f 42 88 03 	mov	&0x0388,r15	
    33bc:	1e 42 88 03 	mov	&0x0388,r14	
    33c0:	5e 4e 1a 00 	mov.b	26(r14),r14	;0x001a(r14)
    33c4:	5e d3       	bis.b	#1,	r14	;r3 As==01
    33c6:	cf 4e 1a 00 	mov.b	r14,	26(r15)	;0x001a(r15)
    OSTCBCur->OSTCBPendTO  = FALSE;
    33ca:	1f 42 88 03 	mov	&0x0388,r15	
    33ce:	cf 43 1b 00 	mov.b	#0,	27(r15)	;r3 As==00, 0x001b(r15)
    OSTCBCur->OSTCBDly     = timeout;                 /* Store pend timeout in TCB                     */
    33d2:	1f 42 88 03 	mov	&0x0388,r15	
    33d6:	9f 44 04 00 	mov	4(r4),	24(r15)	;0x0004(r4), 0x0018(r15)
    33da:	18 00 
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
    33dc:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    33e0:	b0 12 1e 1a 	call	#0x1a1e	
    OS_EXIT_CRITICAL();
    33e4:	2f 44       	mov	@r4,	r15	
    33e6:	b0 12 dc 13 	call	#0x13dc	
    OS_Sched();                                       /* Find next highest priority task ready         */
    33ea:	b0 12 7c 1d 	call	#0x1d7c	
    OS_ENTER_CRITICAL();
    33ee:	b0 12 d6 13 	call	#0x13d6	
    33f2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBCur->OSTCBPendTO == TRUE) {              /* See if we timedout                            */
    33f6:	1f 42 88 03 	mov	&0x0388,r15	
    33fa:	5f 4f 1b 00 	mov.b	27(r15),r15	;0x001b(r15)
    33fe:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    3400:	0d 20       	jnz	$+28     	;abs 0x341c
        OS_EventTO(pevent);
    3402:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3406:	b0 12 ce 1a 	call	#0x1ace	
        OS_EXIT_CRITICAL();
    340a:	2f 44       	mov	@r4,	r15	
    340c:	b0 12 dc 13 	call	#0x13dc	
        *err = OS_TIMEOUT;                            /* Indicate that didn't get event within TO      */
    3410:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3414:	ff 40 0a 00 	mov.b	#10,	0(r15)	;#0x000a, 0x0000(r15)
    3418:	00 00 
    341a:	0b 3c       	jmp	$+24     	;abs 0x3432
        return;
    }
    OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
    341c:	1f 42 88 03 	mov	&0x0388,r15	
    3420:	8f 43 12 00 	mov	#0,	18(r15)	;r3 As==00, 0x0012(r15)
    OS_EXIT_CRITICAL();
    3424:	2f 44       	mov	@r4,	r15	
    3426:	b0 12 dc 13 	call	#0x13dc	
    *err = OS_NO_ERR;
    342a:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    342e:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
}
    3432:	31 52       	add	#8,	r1	;r2 As==11
    3434:	34 41       	pop	r4		
    3436:	30 41       	ret			

00003438 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
    3438:	04 12       	push	r4		
    343a:	21 82       	sub	#4,	r1	;r2 As==10
    343c:	04 41       	mov	r1,	r4	
    343e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr;                               



    cpu_sr = 0;                                            /* Prevent compiler warning                 */
    3442:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
        return (OS_ERR_PEVENT_NULL);
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
    3446:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    344a:	6f 4f       	mov.b	@r15,	r15	
    344c:	7f 90 03 00 	cmp.b	#3,	r15	;#0x0003
    3450:	02 24       	jz	$+6      	;abs 0x3456
        return (OS_ERR_EVENT_TYPE);
    3452:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3454:	32 3c       	jmp	$+102    	;abs 0x34ba
    }
    OS_ENTER_CRITICAL();
    3456:	b0 12 d6 13 	call	#0x13d6	
    345a:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (pevent->OSEventGrp != 0x00) {                          /* See if any task waiting for semaphore*/
    345e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3462:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3466:	4f 93       	tst.b	r15		
    3468:	0e 24       	jz	$+30     	;abs 0x3486
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM); /* Ready HPT waiting on event           */
    346a:	5e 43       	mov.b	#1,	r14	;r3 As==01
    346c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3470:	4d 4e       	mov.b	r14,	r13	
    3472:	0e 43       	clr	r14		
    3474:	b0 12 dc 18 	call	#0x18dc	
        OS_EXIT_CRITICAL();
    3478:	2f 44       	mov	@r4,	r15	
    347a:	b0 12 dc 13 	call	#0x13dc	
        OS_Sched();                                            /* Find HPT ready to run                */
    347e:	b0 12 7c 1d 	call	#0x1d7c	
        return (OS_NO_ERR);
    3482:	4f 43       	clr.b	r15		
    3484:	1a 3c       	jmp	$+54     	;abs 0x34ba
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
    3486:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    348a:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    348e:	3f 93       	cmp	#-1,	r15	;r3 As==11
    3490:	0f 24       	jz	$+32     	;abs 0x34b0
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
    3492:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3496:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    349a:	0e 4f       	mov	r15,	r14	
    349c:	1e 53       	inc	r14		
    349e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    34a2:	8f 4e 02 00 	mov	r14,	2(r15)	;0x0002(r15)
        OS_EXIT_CRITICAL();
    34a6:	2f 44       	mov	@r4,	r15	
    34a8:	b0 12 dc 13 	call	#0x13dc	
        return (OS_NO_ERR);
    34ac:	4f 43       	clr.b	r15		
    34ae:	05 3c       	jmp	$+12     	;abs 0x34ba
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    34b0:	2f 44       	mov	@r4,	r15	
    34b2:	b0 12 dc 13 	call	#0x13dc	
    return (OS_SEM_OVF);
    34b6:	7f 40 32 00 	mov.b	#50,	r15	;#0x0032
}
    34ba:	21 52       	add	#4,	r1	;r2 As==10
    34bc:	34 41       	pop	r4		
    34be:	30 41       	ret			

000034c0 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
    34c0:	04 12       	push	r4		
    34c2:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    34c6:	04 41       	mov	r1,	r4	
    34c8:	c4 4f 0c 00 	mov.b	r15,	12(r4)	;0x000c(r4)
    34cc:	c4 4e 0d 00 	mov.b	r14,	13(r4)	;0x000d(r4)
#if OS_CRITICAL_METHOD == 3                                     
    OS_CPU_SR    cpu_sr;                                        /* Storage for CPU status register     */



    cpu_sr = 0;                                                 /* Prevent compiler warning            */
    34d0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
	}
    if (newprio >= OS_LOWEST_PRIO) {
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    34d4:	b0 12 d6 13 	call	#0x13d6	
    34d8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {                 /* New priority must not already exist */
    34dc:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    34e0:	0f 5f       	rla	r15		
    34e2:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    34e6:	2f 4f       	mov	@r15,	r15	
    34e8:	0f 93       	tst	r15		
    34ea:	06 24       	jz	$+14     	;abs 0x34f8
        OS_EXIT_CRITICAL();
    34ec:	2f 44       	mov	@r4,	r15	
    34ee:	b0 12 dc 13 	call	#0x13dc	
        return (OS_PRIO_EXIST);
    34f2:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
    34f6:	01 3d       	jmp	$+516    	;abs 0x36fa
    } 
    if (oldprio == OS_PRIO_SELF) {                              /* See if changing self                */
    34f8:	f4 93 0c 00 	cmp.b	#-1,	12(r4)	;r3 As==11, 0x000c(r4)
    34fc:	05 20       	jnz	$+12     	;abs 0x3508
        oldprio = OSTCBCur->OSTCBPrio;                          /* Yes, get priority                   */
    34fe:	1f 42 88 03 	mov	&0x0388,r15	
    3502:	d4 4f 1c 00 	mov.b	28(r15),12(r4)	;0x001c(r15), 0x000c(r4)
    3506:	0c 00 
    }
    ptcb = OSTCBPrioTbl[oldprio];
    3508:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    350c:	0f 5f       	rla	r15		
    350e:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3512:	a4 4f 08 00 	mov	@r15,	8(r4)	;0x0008(r4)
    if (ptcb == (OS_TCB *)0) {                                  /* Does task to change exist?          */
    3516:	84 93 08 00 	tst	8(r4)		;0x0008(r4)
    351a:	06 20       	jnz	$+14     	;abs 0x3528
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
    351c:	2f 44       	mov	@r4,	r15	
    351e:	b0 12 dc 13 	call	#0x13dc	
        return (OS_PRIO_ERR);
    3522:	7f 40 29 00 	mov.b	#41,	r15	;#0x0029
    3526:	e9 3c       	jmp	$+468    	;abs 0x36fa
    }                                       
    if (ptcb == (OS_TCB *)1) {                                  /* Is task assigned to Mutex           */
    3528:	94 93 08 00 	cmp	#1,	8(r4)	;r3 As==01, 0x0008(r4)
    352c:	06 20       	jnz	$+14     	;abs 0x353a
        OS_EXIT_CRITICAL();                                     /* No, can't change its priority!      */
    352e:	2f 44       	mov	@r4,	r15	
    3530:	b0 12 dc 13 	call	#0x13dc	
        return (OS_TASK_NOT_EXIST);
    3534:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    3538:	e0 3c       	jmp	$+450    	;abs 0x36fa
    }                                       
    y                     = newprio >> 3;                       /* Yes, compute new TCB fields         */
    353a:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    353e:	12 c3       	clrc			
    3540:	4f 10       	rrc.b	r15		
    3542:	4f 11       	rra.b	r15		
    3544:	4f 11       	rra.b	r15		
    3546:	c4 4f 05 00 	mov.b	r15,	5(r4)	;0x0005(r4)
    bity                  = OSMapTbl[y];
    354a:	5f 44 05 00 	mov.b	5(r4),	r15	;0x0005(r4)
    354e:	d4 4f 20 15 	mov.b	5408(r15),3(r4)	;0x1520(r15), 0x0003(r4)
    3552:	03 00 
    x                     = newprio & 0x07;
    3554:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    3558:	7f f0 07 00 	and.b	#7,	r15	;#0x0007
    355c:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
    bitx                  = OSMapTbl[x];
    3560:	5f 44 06 00 	mov.b	6(r4),	r15	;0x0006(r4)
    3564:	d4 4f 20 15 	mov.b	5408(r15),4(r4)	;0x1520(r15), 0x0004(r4)
    3568:	04 00 
    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                        /* Remove TCB from old priority        */
    356a:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    356e:	0f 5f       	rla	r15		
    3570:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3574:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    OSTCBPrioTbl[newprio] = ptcb;                               /* Place pointer to TCB @ new priority */
    3578:	5f 44 0d 00 	mov.b	13(r4),	r15	;0x000d(r4)
    357c:	0f 5f       	rla	r15		
    357e:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3582:	9f 44 08 00 	mov	8(r4),	0(r15)	;0x0008(r4), 0x0000(r15)
    3586:	00 00 
    y_old                 = ptcb->OSTCBY;
    3588:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    358c:	d4 4f 1e 00 	mov.b	30(r15),2(r4)	;0x001e(r15), 0x0002(r4)
    3590:	02 00 
    if ((OSRdyTbl[y_old] & ptcb->OSTCBBitX) != 0x00) {          /* If task is ready make it not        */
    3592:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3596:	5e 4f 80 03 	mov.b	896(r15),r14	;0x0380(r15)
    359a:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    359e:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    35a2:	4f fe       	and.b	r14,	r15	
    35a4:	31 24       	jz	$+100    	;abs 0x3608
        OSRdyTbl[y_old] &= ~ptcb->OSTCBBitX;
    35a6:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    35aa:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    35ae:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    35b2:	4e 4f       	mov.b	r15,	r14	
    35b4:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    35b8:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    35bc:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    35be:	4f fe       	and.b	r14,	r15	
    35c0:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        if (OSRdyTbl[y_old] == 0x00) {
    35c4:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    35c8:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    35cc:	4f 93       	tst.b	r15		
    35ce:	0b 20       	jnz	$+24     	;abs 0x35e6
            OSRdyGrp &= ~ptcb->OSTCBBitY;
    35d0:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    35d4:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    35d8:	4e 4f       	mov.b	r15,	r14	
    35da:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    35dc:	5f 42 7e 03 	mov.b	&0x037e,r15	
    35e0:	4f fe       	and.b	r14,	r15	
    35e2:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        }
        OSRdyGrp    |= bity;                                    /* Make new priority ready to run      */
    35e6:	5f 42 7e 03 	mov.b	&0x037e,r15	
    35ea:	5f d4 03 00 	bis.b	3(r4),	r15	;0x0003(r4)
    35ee:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        OSRdyTbl[y] |= bitx;
    35f2:	5e 44 05 00 	mov.b	5(r4),	r14	;0x0005(r4)
    35f6:	5f 44 05 00 	mov.b	5(r4),	r15	;0x0005(r4)
    35fa:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    35fe:	5f d4 04 00 	bis.b	4(r4),	r15	;0x0004(r4)
    3602:	ce 4f 80 03 	mov.b	r15,	896(r14);0x0380(r14)
    3606:	5a 3c       	jmp	$+182    	;abs 0x36bc
#if OS_EVENT_EN
    } else {                                                    /* Task was not ready ...              */
        pevent = ptcb->OSTCBEventPtr;
    3608:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    360c:	94 4f 12 00 	mov	18(r15),10(r4)	;0x0012(r15), 0x000a(r4)
    3610:	0a 00 
        if (pevent != (OS_EVENT *)0) {                          /* ... remove from event wait list     */
    3612:	84 93 0a 00 	tst	10(r4)		;0x000a(r4)
    3616:	52 24       	jz	$+166    	;abs 0x36bc
            pevent->OSEventTbl[y_old] &= ~ptcb->OSTCBBitX;
    3618:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    361c:	5e 44 02 00 	mov.b	2(r4),	r14	;0x0002(r4)
    3620:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3624:	0f 5e       	add	r14,	r15	
    3626:	3f 50 06 00 	add	#6,	r15	;#0x0006
    362a:	6f 4f       	mov.b	@r15,	r15	
    362c:	4e 4f       	mov.b	r15,	r14	
    362e:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    3632:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    3636:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    3638:	4f fe       	and.b	r14,	r15	
    363a:	4e 4f       	mov.b	r15,	r14	
    363c:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3640:	0f 5d       	add	r13,	r15	
    3642:	3f 50 06 00 	add	#6,	r15	;#0x0006
    3646:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
            if (pevent->OSEventTbl[y_old] == 0) {
    364a:	5e 44 02 00 	mov.b	2(r4),	r14	;0x0002(r4)
    364e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3652:	0f 5e       	add	r14,	r15	
    3654:	3f 50 06 00 	add	#6,	r15	;#0x0006
    3658:	6f 4f       	mov.b	@r15,	r15	
    365a:	4f 93       	tst.b	r15		
    365c:	10 20       	jnz	$+34     	;abs 0x367e
                pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
    365e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3662:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3666:	4e 4f       	mov.b	r15,	r14	
    3668:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    366c:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    3670:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    3672:	4f fe       	and.b	r14,	r15	
    3674:	4e 4f       	mov.b	r15,	r14	
    3676:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    367a:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
            }
            pevent->OSEventGrp    |= bity;                      /* Add new priority to wait list       */
    367e:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3682:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    3686:	4e 4f       	mov.b	r15,	r14	
    3688:	5e d4 03 00 	bis.b	3(r4),	r14	;0x0003(r4)
    368c:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    3690:	cf 4e 01 00 	mov.b	r14,	1(r15)	;0x0001(r15)
            pevent->OSEventTbl[y] |= bitx;
    3694:	5d 44 05 00 	mov.b	5(r4),	r13	;0x0005(r4)
    3698:	5e 44 05 00 	mov.b	5(r4),	r14	;0x0005(r4)
    369c:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36a0:	0f 5e       	add	r14,	r15	
    36a2:	3f 50 06 00 	add	#6,	r15	;#0x0006
    36a6:	6f 4f       	mov.b	@r15,	r15	
    36a8:	4e 4f       	mov.b	r15,	r14	
    36aa:	5e d4 04 00 	bis.b	4(r4),	r14	;0x0004(r4)
    36ae:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    36b2:	0f 5d       	add	r13,	r15	
    36b4:	3f 50 06 00 	add	#6,	r15	;#0x0006
    36b8:	cf 4e 00 00 	mov.b	r14,	0(r15)	;0x0000(r15)
        }
#endif
    }
    ptcb->OSTCBPrio = newprio;                                  /* Set new task priority               */
    36bc:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36c0:	df 44 0d 00 	mov.b	13(r4),	28(r15)	;0x000d(r4), 0x001c(r15)
    36c4:	1c 00 
    ptcb->OSTCBY    = y;
    36c6:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36ca:	df 44 05 00 	mov.b	5(r4),	30(r15)	;0x0005(r4), 0x001e(r15)
    36ce:	1e 00 
    ptcb->OSTCBX    = x;
    36d0:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36d4:	df 44 06 00 	mov.b	6(r4),	29(r15)	;0x0006(r4), 0x001d(r15)
    36d8:	1d 00 
    ptcb->OSTCBBitY = bity;
    36da:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36de:	df 44 03 00 	mov.b	3(r4),	32(r15)	;0x0003(r4), 0x0020(r15)
    36e2:	20 00 
    ptcb->OSTCBBitX = bitx;
    36e4:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    36e8:	df 44 04 00 	mov.b	4(r4),	31(r15)	;0x0004(r4), 0x001f(r15)
    36ec:	1f 00 
    OS_EXIT_CRITICAL();
    36ee:	2f 44       	mov	@r4,	r15	
    36f0:	b0 12 dc 13 	call	#0x13dc	
    OS_Sched();                                                 /* Run highest priority task ready     */
    36f4:	b0 12 7c 1d 	call	#0x1d7c	
    return (OS_NO_ERR);
    36f8:	4f 43       	clr.b	r15		
}
    36fa:	31 50 0e 00 	add	#14,	r1	;#0x000e
    36fe:	34 41       	pop	r4		
    3700:	30 41       	ret			

00003702 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *pd), void *p_arg, OS_STK *ptos, INT8U prio)
{
    3702:	04 12       	push	r4		
    3704:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3708:	04 41       	mov	r1,	r4	
    370a:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    370e:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    3712:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
    3716:	c4 4c 0c 00 	mov.b	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                              /* Prevent compiler warning                               */
    371a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    371e:	b0 12 d6 13 	call	#0x13d6	
    3722:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
    3726:	5f 42 86 03 	mov.b	&0x0386,r15	
    372a:	4f 93       	tst.b	r15		
    372c:	06 24       	jz	$+14     	;abs 0x373a
        OS_EXIT_CRITICAL();
    372e:	2f 44       	mov	@r4,	r15	
    3730:	b0 12 dc 13 	call	#0x13dc	
        return (OS_ERR_TASK_CREATE_ISR);
    3734:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    3738:	4e 3c       	jmp	$+158    	;abs 0x37d6
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
    373a:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    373e:	0f 5f       	rla	r15		
    3740:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3744:	2f 4f       	mov	@r15,	r15	
    3746:	0f 93       	tst	r15		
    3748:	41 20       	jnz	$+132    	;abs 0x37cc
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
    374a:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    374e:	0f 5f       	rla	r15		
    3750:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3754:	9f 43 00 00 	mov	#1,	0(r15)	;r3 As==01, 0x0000(r15)
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
    3758:	2f 44       	mov	@r4,	r15	
    375a:	b0 12 dc 13 	call	#0x13dc	
        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, 0);    /* Initialize the task's stack         */
    375e:	1d 44 0a 00 	mov	10(r4),	r13	;0x000a(r4)
    3762:	1e 44 08 00 	mov	8(r4),	r14	;0x0008(r4)
    3766:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    376a:	0c 43       	clr	r12		
    376c:	b0 12 20 14 	call	#0x1420	
    3770:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
    3774:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    3778:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    377c:	03 12       	push	#0		;r3 As==00
    377e:	03 12       	push	#0		;r3 As==00
    3780:	03 12       	push	#0		;r3 As==00
    3782:	03 12       	push	#0		;r3 As==00
    3784:	0c 43       	clr	r12		
    3786:	0d 43       	clr	r13		
    3788:	b0 12 5a 1e 	call	#0x1e5a	
    378c:	31 52       	add	#8,	r1	;r2 As==11
    378e:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
        if (err == OS_NO_ERR) {
    3792:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    3796:	07 20       	jnz	$+16     	;abs 0x37a6
            if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has started */
    3798:	5f 42 0d 03 	mov.b	&0x030d,r15	
    379c:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    379e:	12 20       	jnz	$+38     	;abs 0x37c4
                OS_Sched();
    37a0:	b0 12 7c 1d 	call	#0x1d7c	
    37a4:	10 3c       	jmp	$+34     	;abs 0x37c6
            }
        } else {
            OS_ENTER_CRITICAL();
    37a6:	b0 12 d6 13 	call	#0x13d6	
    37aa:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
    37ae:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    37b2:	0f 5f       	rla	r15		
    37b4:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    37b8:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
            OS_EXIT_CRITICAL();
    37bc:	2f 44       	mov	@r4,	r15	
    37be:	b0 12 dc 13 	call	#0x13dc	
    37c2:	01 3c       	jmp	$+4      	;abs 0x37c6
        OS_EXIT_CRITICAL();
        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, 0);    /* Initialize the task's stack         */
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
        if (err == OS_NO_ERR) {
            if (OSRunning == TRUE) {         /* Find highest priority task if multitasking has started */
                OS_Sched();
    37c4:	03 43       	nop			
        } else {
            OS_ENTER_CRITICAL();
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
            OS_EXIT_CRITICAL();
        }
        return (err);
    37c6:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    37ca:	05 3c       	jmp	$+12     	;abs 0x37d6
    }
    OS_EXIT_CRITICAL();
    37cc:	2f 44       	mov	@r4,	r15	
    37ce:	b0 12 dc 13 	call	#0x13dc	
    return (OS_PRIO_EXIST);
    37d2:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
}
    37d6:	31 50 0e 00 	add	#14,	r1	;#0x000e
    37da:	34 41       	pop	r4		
    37dc:	30 41       	ret			

000037de <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
    37de:	0b 12       	push	r11		
    37e0:	04 12       	push	r4		
    37e2:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    37e6:	04 41       	mov	r1,	r4	
    37e8:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
    37ec:	84 4e 08 00 	mov	r14,	8(r4)	;0x0008(r4)
    37f0:	84 4d 0a 00 	mov	r13,	10(r4)	;0x000a(r4)
    37f4:	c4 4c 0c 00 	mov.b	r12,	12(r4)	;0x000c(r4)
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                              /* Prevent compiler warning                               */
    37f8:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
        return (OS_PRIO_INVALID);
    }
#endif
    OS_ENTER_CRITICAL();
    37fc:	b0 12 d6 13 	call	#0x13d6	
    3800:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
    3804:	5f 42 86 03 	mov.b	&0x0386,r15	
    3808:	4f 93       	tst.b	r15		
    380a:	06 24       	jz	$+14     	;abs 0x3818
        OS_EXIT_CRITICAL();
    380c:	2f 44       	mov	@r4,	r15	
    380e:	b0 12 dc 13 	call	#0x13dc	
        return (OS_ERR_TASK_CREATE_ISR);
    3812:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    3816:	63 3c       	jmp	$+200    	;abs 0x38de
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
    3818:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    381c:	0f 5f       	rla	r15		
    381e:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3822:	2f 4f       	mov	@r15,	r15	
    3824:	0f 93       	tst	r15		
    3826:	56 20       	jnz	$+174    	;abs 0x38d4
        OSTCBPrioTbl[prio] = (OS_TCB *)1;    /* Reserve the priority to prevent others from doing ...  */
    3828:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    382c:	0f 5f       	rla	r15		
    382e:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3832:	9f 43 00 00 	mov	#1,	0(r15)	;r3 As==01, 0x0000(r15)
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
    3836:	2f 44       	mov	@r4,	r15	
    3838:	b0 12 dc 13 	call	#0x13dc	

        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
    383c:	1d 44 1e 00 	mov	30(r4),	r13	;0x001e(r4)
    3840:	1e 44 18 00 	mov	24(r4),	r14	;0x0018(r4)
    3844:	1f 44 1a 00 	mov	26(r4),	r15	;0x001a(r4)
    3848:	1b 44 16 00 	mov	22(r4),	r11	;0x0016(r4)
    384c:	0c 4d       	mov	r13,	r12	
    384e:	0d 4e       	mov	r14,	r13	
    3850:	0e 4f       	mov	r15,	r14	
    3852:	0f 4b       	mov	r11,	r15	
    3854:	b0 12 00 3a 	call	#0x3a00	

        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, opt); /* Initialize the task's stack          */
    3858:	1c 44 1e 00 	mov	30(r4),	r12	;0x001e(r4)
    385c:	1d 44 0a 00 	mov	10(r4),	r13	;0x000a(r4)
    3860:	1e 44 08 00 	mov	8(r4),	r14	;0x0008(r4)
    3864:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3868:	b0 12 20 14 	call	#0x1420	
    386c:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
    3870:	1d 44 16 00 	mov	22(r4),	r13	;0x0016(r4)
    3874:	1e 44 04 00 	mov	4(r4),	r14	;0x0004(r4)
    3878:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    387c:	14 12 1e 00 	push	30(r4)		;0x001e(r4)
    3880:	14 12 1c 00 	push	28(r4)		;0x001c(r4)
    3884:	14 12 1a 00 	push	26(r4)		;0x001a(r4)
    3888:	14 12 18 00 	push	24(r4)		;0x0018(r4)
    388c:	1c 44 14 00 	mov	20(r4),	r12	;0x0014(r4)
    3890:	b0 12 5a 1e 	call	#0x1e5a	
    3894:	31 52       	add	#8,	r1	;r2 As==11
    3896:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
        if (err == OS_NO_ERR) {
    389a:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    389e:	07 20       	jnz	$+16     	;abs 0x38ae
            if (OSRunning == TRUE) {                           /* Find HPT if multitasking has started */
    38a0:	5f 42 0d 03 	mov.b	&0x030d,r15	
    38a4:	5f 93       	cmp.b	#1,	r15	;r3 As==01
    38a6:	12 20       	jnz	$+38     	;abs 0x38cc
                OS_Sched();
    38a8:	b0 12 7c 1d 	call	#0x1d7c	
    38ac:	10 3c       	jmp	$+34     	;abs 0x38ce
            }
        } else {
            OS_ENTER_CRITICAL();
    38ae:	b0 12 d6 13 	call	#0x13d6	
    38b2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
    38b6:	5f 44 0c 00 	mov.b	12(r4),	r15	;0x000c(r4)
    38ba:	0f 5f       	rla	r15		
    38bc:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    38c0:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
            OS_EXIT_CRITICAL();
    38c4:	2f 44       	mov	@r4,	r15	
    38c6:	b0 12 dc 13 	call	#0x13dc	
    38ca:	01 3c       	jmp	$+4      	;abs 0x38ce

        psp = (OS_STK *)OSTaskStkInit(task, p_arg, ptos, opt); /* Initialize the task's stack          */
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
        if (err == OS_NO_ERR) {
            if (OSRunning == TRUE) {                           /* Find HPT if multitasking has started */
                OS_Sched();
    38cc:	03 43       	nop			
        } else {
            OS_ENTER_CRITICAL();
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
            OS_EXIT_CRITICAL();
        }
        return (err);
    38ce:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    38d2:	05 3c       	jmp	$+12     	;abs 0x38de
    }
    OS_EXIT_CRITICAL();
    38d4:	2f 44       	mov	@r4,	r15	
    38d6:	b0 12 dc 13 	call	#0x13dc	
    return (OS_PRIO_EXIST);
    38da:	7f 40 28 00 	mov.b	#40,	r15	;#0x0028
}
    38de:	31 50 0e 00 	add	#14,	r1	;#0x000e
    38e2:	34 41       	pop	r4		
    38e4:	3b 41       	pop	r11		
    38e6:	30 41       	ret			

000038e8 <OSTaskStkChk>:
*              OS_TASK_OPT_ERR     if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
    38e8:	04 12       	push	r4		
    38ea:	31 50 ee ff 	add	#-18,	r1	;#0xffee
    38ee:	04 41       	mov	r1,	r4	
    38f0:	c4 4f 0e 00 	mov.b	r15,	14(r4)	;0x000e(r4)
    38f4:	84 4e 10 00 	mov	r14,	16(r4)	;0x0010(r4)
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                        /* Prevent compiler warning                     */
    38f8:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
        if (prio != OS_PRIO_SELF) {        
            return (OS_PRIO_INVALID);
        }
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
    38fc:	1f 44 10 00 	mov	16(r4),	r15	;0x0010(r4)
    3900:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    3904:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    p_stk_data->OSUsed = 0;
    3908:	1f 44 10 00 	mov	16(r4),	r15	;0x0010(r4)
    390c:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
    3910:	8f 43 06 00 	mov	#0,	6(r15)	;r3 As==00, 0x0006(r15)
    OS_ENTER_CRITICAL();
    3914:	b0 12 d6 13 	call	#0x13d6	
    3918:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
    391c:	f4 93 0e 00 	cmp.b	#-1,	14(r4)	;r3 As==11, 0x000e(r4)
    3920:	05 20       	jnz	$+12     	;abs 0x392c
        prio = OSTCBCur->OSTCBPrio;
    3922:	1f 42 88 03 	mov	&0x0388,r15	
    3926:	d4 4f 1c 00 	mov.b	28(r15),14(r4)	;0x001c(r15), 0x000e(r4)
    392a:	0e 00 
    }
    ptcb = OSTCBPrioTbl[prio];
    392c:	5f 44 0e 00 	mov.b	14(r4),	r15	;0x000e(r4)
    3930:	0f 5f       	rla	r15		
    3932:	3f 50 76 05 	add	#1398,	r15	;#0x0576
    3936:	a4 4f 0c 00 	mov	@r15,	12(r4)	;0x000c(r4)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
    393a:	84 93 0c 00 	tst	12(r4)		;0x000c(r4)
    393e:	06 20       	jnz	$+14     	;abs 0x394c
        OS_EXIT_CRITICAL();
    3940:	2f 44       	mov	@r4,	r15	
    3942:	b0 12 dc 13 	call	#0x13dc	
        return (OS_TASK_NOT_EXIST);
    3946:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    394a:	56 3c       	jmp	$+174    	;abs 0x39f8
    }
    if (ptcb == (OS_TCB *)1) {
    394c:	94 93 0c 00 	cmp	#1,	12(r4)	;r3 As==01, 0x000c(r4)
    3950:	06 20       	jnz	$+14     	;abs 0x395e
        OS_EXIT_CRITICAL();
    3952:	2f 44       	mov	@r4,	r15	
    3954:	b0 12 dc 13 	call	#0x13dc	
        return (OS_TASK_NOT_EXIST);
    3958:	7f 40 0b 00 	mov.b	#11,	r15	;#0x000b
    395c:	4d 3c       	jmp	$+156    	;abs 0x39f8
    }  
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
    395e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    3962:	1f 4f 0a 00 	mov	10(r15),r15	;0x000a(r15)
    3966:	1f f3       	and	#1,	r15	;r3 As==01
    3968:	06 20       	jnz	$+14     	;abs 0x3976
        OS_EXIT_CRITICAL();
    396a:	2f 44       	mov	@r4,	r15	
    396c:	b0 12 dc 13 	call	#0x13dc	
        return (OS_TASK_OPT_ERR);
    3970:	7f 40 82 ff 	mov.b	#-126,	r15	;#0xff82
    3974:	41 3c       	jmp	$+132    	;abs 0x39f8
    }
    free = 0;
    3976:	84 43 06 00 	mov	#0,	6(r4)	;r3 As==00, 0x0006(r4)
    397a:	84 43 08 00 	mov	#0,	8(r4)	;r3 As==00, 0x0008(r4)
    size = ptcb->OSTCBStkSize;
    397e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    3982:	94 4f 06 00 	mov	6(r15),	2(r4)	;0x0006(r15), 0x0002(r4)
    3986:	02 00 
    3988:	94 4f 08 00 	mov	8(r15),	4(r4)	;0x0008(r15), 0x0004(r4)
    398c:	04 00 
    pchk = ptcb->OSTCBStkBottom;
    398e:	1f 44 0c 00 	mov	12(r4),	r15	;0x000c(r4)
    3992:	94 4f 04 00 	mov	4(r15),	10(r4)	;0x0004(r15), 0x000a(r4)
    3996:	0a 00 
    OS_EXIT_CRITICAL();
    3998:	2f 44       	mov	@r4,	r15	
    399a:	b0 12 dc 13 	call	#0x13dc	
    399e:	04 3c       	jmp	$+10     	;abs 0x39a8
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
        free++;
    39a0:	94 53 06 00 	inc	6(r4)		;0x0006(r4)
    39a4:	84 63 08 00 	adc	8(r4)		;0x0008(r4)
    free = 0;
    size = ptcb->OSTCBStkSize;
    pchk = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
    39a8:	1f 44 0a 00 	mov	10(r4),	r15	;0x000a(r4)
    39ac:	2e 4f       	mov	@r15,	r14	
    39ae:	4f 43       	clr.b	r15		
    39b0:	0e 93       	tst	r14		
    39b2:	01 20       	jnz	$+4      	;abs 0x39b6
    39b4:	5f 43       	mov.b	#1,	r15	;r3 As==01
    39b6:	a4 53 0a 00 	incd	10(r4)		;0x000a(r4)
    39ba:	4f 93       	tst.b	r15		
    39bc:	f1 23       	jnz	$-28     	;abs 0x39a0
#else
    while (*pchk-- == (OS_STK)0) {
        free++;
    }
#endif
    p_stk_data->OSFree = free * sizeof(OS_STK);           /* Compute number of free bytes on the stack */
    39be:	1e 44 06 00 	mov	6(r4),	r14	;0x0006(r4)
    39c2:	1f 44 08 00 	mov	8(r4),	r15	;0x0008(r4)
    39c6:	0e 5e       	rla	r14		
    39c8:	0f 6f       	rlc	r15		
    39ca:	1d 44 10 00 	mov	16(r4),	r13	;0x0010(r4)
    39ce:	8d 4e 00 00 	mov	r14,	0(r13)	;0x0000(r13)
    39d2:	8d 4f 02 00 	mov	r15,	2(r13)	;0x0002(r13)
    p_stk_data->OSUsed = (size - free) * sizeof(OS_STK);  /* Compute number of bytes used on the stack */
    39d6:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    39da:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    39de:	1e 84 06 00 	sub	6(r4),	r14	;0x0006(r4)
    39e2:	1f 74 08 00 	subc	8(r4),	r15	;0x0008(r4)
    39e6:	0e 5e       	rla	r14		
    39e8:	0f 6f       	rlc	r15		
    39ea:	1d 44 10 00 	mov	16(r4),	r13	;0x0010(r4)
    39ee:	8d 4e 04 00 	mov	r14,	4(r13)	;0x0004(r13)
    39f2:	8d 4f 06 00 	mov	r15,	6(r13)	;0x0006(r13)
    return (OS_NO_ERR);
    39f6:	4f 43       	clr.b	r15		
}
    39f8:	31 50 12 00 	add	#18,	r1	;#0x0012
    39fc:	34 41       	pop	r4		
    39fe:	30 41       	ret			

00003a00 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if OS_TASK_CREATE_EXT_EN > 0
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    3a00:	04 12       	push	r4		
    3a02:	31 82       	sub	#8,	r1	;r2 As==11
    3a04:	04 41       	mov	r1,	r4	
    3a06:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    3a0a:	84 4d 02 00 	mov	r13,	2(r4)	;0x0002(r4)
    3a0e:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    3a12:	84 4c 06 00 	mov	r12,	6(r4)	;0x0006(r4)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
    3a16:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3a1a:	1f f3       	and	#1,	r15	;r3 As==01
    3a1c:	4f 93       	tst.b	r15		
    3a1e:	14 24       	jz	$+42     	;abs 0x3a48
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
    3a20:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3a24:	2f f3       	and	#2,	r15	;r3 As==10
    3a26:	10 24       	jz	$+34     	;abs 0x3a48
    3a28:	09 3c       	jmp	$+20     	;abs 0x3a3c
#if OS_STK_GROWTH == 1                     
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
                size--;
    3a2a:	b4 53 02 00 	add	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
    3a2e:	b4 63 04 00 	addc	#-1,	4(r4)	;r3 As==11, 0x0004(r4)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
    3a32:	2f 44       	mov	@r4,	r15	
    3a34:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    3a38:	a4 53 00 00 	incd	0(r4)		;0x0000(r4)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1                     
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
    3a3c:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3a40:	f4 23       	jnz	$-22     	;abs 0x3a2a
    3a42:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    3a46:	f1 23       	jnz	$-28     	;abs 0x3a2a
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
    3a48:	31 52       	add	#8,	r1	;r2 As==11
    3a4a:	34 41       	pop	r4		
    3a4c:	30 41       	ret			

00003a4e <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
    3a4e:	04 12       	push	r4		
    3a50:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3a54:	04 41       	mov	r1,	r4	
    3a56:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr;



    cpu_sr = 0;                                  /* Prevent compiler warning                           */
    3a5a:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
#endif    
    if (ticks > 0) {                             /* 0 means no delay!                                  */
    3a5e:	84 93 04 00 	tst	4(r4)		;0x0004(r4)
    3a62:	33 24       	jz	$+104    	;abs 0x3aca
        OS_ENTER_CRITICAL();
    3a64:	b0 12 d6 13 	call	#0x13d6	
    3a68:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
    3a6c:	1f 42 88 03 	mov	&0x0388,r15	
    3a70:	d4 4f 1e 00 	mov.b	30(r15),2(r4)	;0x001e(r15), 0x0002(r4)
    3a74:	02 00 
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
    3a76:	5d 44 02 00 	mov.b	2(r4),	r13	;0x0002(r4)
    3a7a:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3a7e:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    3a82:	4e 4f       	mov.b	r15,	r14	
    3a84:	1f 42 88 03 	mov	&0x0388,r15	
    3a88:	5f 4f 1f 00 	mov.b	31(r15),r15	;0x001f(r15)
    3a8c:	7f e3       	xor.b	#-1,	r15	;r3 As==11
    3a8e:	4f fe       	and.b	r14,	r15	
    3a90:	cd 4f 80 03 	mov.b	r15,	896(r13);0x0380(r13)
        if (OSRdyTbl[y] == 0) {  
    3a94:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    3a98:	5f 4f 80 03 	mov.b	896(r15),r15	;0x0380(r15)
    3a9c:	4f 93       	tst.b	r15		
    3a9e:	0b 20       	jnz	$+24     	;abs 0x3ab6
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
    3aa0:	1f 42 88 03 	mov	&0x0388,r15	
    3aa4:	5f 4f 20 00 	mov.b	32(r15),r15	;0x0020(r15)
    3aa8:	4e 4f       	mov.b	r15,	r14	
    3aaa:	7e e3       	xor.b	#-1,	r14	;r3 As==11
    3aac:	5f 42 7e 03 	mov.b	&0x037e,r15	
    3ab0:	4f fe       	and.b	r14,	r15	
    3ab2:	c2 4f 7e 03 	mov.b	r15,	&0x037e	
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
    3ab6:	1f 42 88 03 	mov	&0x0388,r15	
    3aba:	9f 44 04 00 	mov	4(r4),	24(r15)	;0x0004(r4), 0x0018(r15)
    3abe:	18 00 
        OS_EXIT_CRITICAL();
    3ac0:	2f 44       	mov	@r4,	r15	
    3ac2:	b0 12 dc 13 	call	#0x13dc	
        OS_Sched();                              /* Find next task to run!                             */
    3ac6:	b0 12 7c 1d 	call	#0x1d7c	
    }
}
    3aca:	31 50 06 00 	add	#6,	r1	;#0x0006
    3ace:	34 41       	pop	r4		
    3ad0:	30 41       	ret			

00003ad2 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U milli)
{
    3ad2:	0b 12       	push	r11		
    3ad4:	0a 12       	push	r10		
    3ad6:	09 12       	push	r9		
    3ad8:	08 12       	push	r8		
    3ada:	07 12       	push	r7		
    3adc:	06 12       	push	r6		
    3ade:	04 12       	push	r4		
    3ae0:	31 50 f0 ff 	add	#-16,	r1	;#0xfff0
    3ae4:	04 41       	mov	r1,	r4	
    3ae6:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
    3aea:	c4 4e 07 00 	mov.b	r14,	7(r4)	;0x0007(r4)
    3aee:	c4 4d 08 00 	mov.b	r13,	8(r4)	;0x0008(r4)
    3af2:	84 4c 0a 00 	mov	r12,	10(r4)	;0x000a(r4)
        return (OS_TIME_INVALID_MILLI);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
    3af6:	5c 44 06 00 	mov.b	6(r4),	r12	;0x0006(r4)
    3afa:	0d 43       	clr	r13		
    3afc:	0e 4c       	mov	r12,	r14	
    3afe:	0f 4d       	mov	r13,	r15	
    3b00:	0e 5e       	rla	r14		
    3b02:	0f 6f       	rlc	r15		
    3b04:	0e 5e       	rla	r14		
    3b06:	0f 6f       	rlc	r15		
    3b08:	0e 5e       	rla	r14		
    3b0a:	0f 6f       	rlc	r15		
    3b0c:	0e 8c       	sub	r12,	r14	
    3b0e:	0f 7d       	subc	r13,	r15	
    3b10:	0a 4e       	mov	r14,	r10	
    3b12:	0b 4f       	mov	r15,	r11	
    3b14:	4b ea       	xor.b	r10,	r11	
    3b16:	0b ea       	xor	r10,	r11	
    3b18:	8b 10       	swpb	r11		
    3b1a:	7a f3       	and.b	#-1,	r10	;r3 As==11
    3b1c:	8a 10       	swpb	r10		
    3b1e:	0e 5a       	add	r10,	r14	
    3b20:	0f 6b       	addc	r11,	r15	
    3b22:	0e 5e       	rla	r14		
    3b24:	0f 6f       	rlc	r15		
    3b26:	0e 5c       	add	r12,	r14	
    3b28:	0f 6d       	addc	r13,	r15	
    3b2a:	0a 4e       	mov	r14,	r10	
    3b2c:	0b 4f       	mov	r15,	r11	
    3b2e:	0a 5c       	add	r12,	r10	
    3b30:	0b 6d       	addc	r13,	r11	
    3b32:	5c 44 07 00 	mov.b	7(r4),	r12	;0x0007(r4)
    3b36:	0d 43       	clr	r13		
    3b38:	0e 4c       	mov	r12,	r14	
    3b3a:	0f 4d       	mov	r13,	r15	
    3b3c:	0e 5e       	rla	r14		
    3b3e:	0f 6f       	rlc	r15		
    3b40:	0e 5e       	rla	r14		
    3b42:	0f 6f       	rlc	r15		
    3b44:	0e 5e       	rla	r14		
    3b46:	0f 6f       	rlc	r15		
    3b48:	0e 5e       	rla	r14		
    3b4a:	0f 6f       	rlc	r15		
    3b4c:	0e 8c       	sub	r12,	r14	
    3b4e:	0f 7d       	subc	r13,	r15	
    3b50:	0e 5e       	rla	r14		
    3b52:	0f 6f       	rlc	r15		
    3b54:	0e 5e       	rla	r14		
    3b56:	0f 6f       	rlc	r15		
    3b58:	0c 4a       	mov	r10,	r12	
    3b5a:	0d 4b       	mov	r11,	r13	
    3b5c:	0c 5e       	add	r14,	r12	
    3b5e:	0d 6f       	addc	r15,	r13	
    3b60:	5e 44 08 00 	mov.b	8(r4),	r14	;0x0008(r4)
    3b64:	0f 43       	clr	r15		
    3b66:	0a 4c       	mov	r12,	r10	
    3b68:	0b 4d       	mov	r13,	r11	
    3b6a:	0a 5e       	add	r14,	r10	
    3b6c:	0b 6f       	addc	r15,	r11	
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    3b6e:	0c 4a       	mov	r10,	r12	
    3b70:	0d 4b       	mov	r11,	r13	
    3b72:	0e 4c       	mov	r12,	r14	
    3b74:	0f 4d       	mov	r13,	r15	
    3b76:	0e 5e       	rla	r14		
    3b78:	0f 6f       	rlc	r15		
    3b7a:	0c 4e       	mov	r14,	r12	
    3b7c:	0d 4f       	mov	r15,	r13	
    3b7e:	0c 5a       	add	r10,	r12	
    3b80:	0d 6b       	addc	r11,	r13	
    3b82:	0e 4c       	mov	r12,	r14	
    3b84:	0f 4d       	mov	r13,	r15	
    3b86:	0e 5e       	rla	r14		
    3b88:	0f 6f       	rlc	r15		
    3b8a:	0e 5e       	rla	r14		
    3b8c:	0f 6f       	rlc	r15		
    3b8e:	0e 5e       	rla	r14		
    3b90:	0f 6f       	rlc	r15		
    3b92:	0e 5e       	rla	r14		
    3b94:	0f 6f       	rlc	r15		
    3b96:	0e 5e       	rla	r14		
    3b98:	0f 6f       	rlc	r15		
    3b9a:	0c 5e       	add	r14,	r12	
    3b9c:	0d 6f       	addc	r15,	r13	
    3b9e:	0e 4c       	mov	r12,	r14	
    3ba0:	0f 4d       	mov	r13,	r15	
    3ba2:	0e 5a       	add	r10,	r14	
    3ba4:	0f 6b       	addc	r11,	r15	
    3ba6:	84 4e 0c 00 	mov	r14,	12(r4)	;0x000c(r4)
    3baa:	84 4f 0e 00 	mov	r15,	14(r4)	;0x000e(r4)
    3bae:	1a 44 0a 00 	mov	10(r4),	r10	;0x000a(r4)
    3bb2:	0b 43       	clr	r11		
    3bb4:	0c 4a       	mov	r10,	r12	
    3bb6:	0d 4b       	mov	r11,	r13	
    3bb8:	0e 4c       	mov	r12,	r14	
    3bba:	0f 4d       	mov	r13,	r15	
    3bbc:	0e 5e       	rla	r14		
    3bbe:	0f 6f       	rlc	r15		
    3bc0:	0c 4e       	mov	r14,	r12	
    3bc2:	0d 4f       	mov	r15,	r13	
    3bc4:	0c 5a       	add	r10,	r12	
    3bc6:	0d 6b       	addc	r11,	r13	
    3bc8:	0e 4c       	mov	r12,	r14	
    3bca:	0f 4d       	mov	r13,	r15	
    3bcc:	0e 5e       	rla	r14		
    3bce:	0f 6f       	rlc	r15		
    3bd0:	0e 5e       	rla	r14		
    3bd2:	0f 6f       	rlc	r15		
    3bd4:	0e 5e       	rla	r14		
    3bd6:	0f 6f       	rlc	r15		
    3bd8:	0e 5e       	rla	r14		
    3bda:	0f 6f       	rlc	r15		
    3bdc:	0e 5e       	rla	r14		
    3bde:	0f 6f       	rlc	r15		
    3be0:	0c 5e       	add	r14,	r12	
    3be2:	0d 6f       	addc	r15,	r13	
    3be4:	0e 4c       	mov	r12,	r14	
    3be6:	0f 4d       	mov	r13,	r15	
    3be8:	0e 5a       	add	r10,	r14	
    3bea:	0f 6b       	addc	r11,	r15	
    3bec:	0c 4e       	mov	r14,	r12	
    3bee:	0d 4f       	mov	r15,	r13	
    3bf0:	3c 50 f4 01 	add	#500,	r12	;#0x01f4
    3bf4:	0d 63       	adc	r13		
    3bf6:	3e 40 e8 03 	mov	#1000,	r14	;#0x03e8
    3bfa:	0f 43       	clr	r15		
    3bfc:	0a 4e       	mov	r14,	r10	
    3bfe:	0b 4f       	mov	r15,	r11	
    3c00:	b0 12 b8 45 	call	#0x45b8	
    3c04:	0e 4c       	mov	r12,	r14	
    3c06:	0f 4d       	mov	r13,	r15	
        return (OS_TIME_INVALID_MILLI);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
    3c08:	1c 44 0c 00 	mov	12(r4),	r12	;0x000c(r4)
    3c0c:	1d 44 0e 00 	mov	14(r4),	r13	;0x000e(r4)
    3c10:	0c 5e       	add	r14,	r12	
    3c12:	0d 6f       	addc	r15,	r13	
    3c14:	84 4c 02 00 	mov	r12,	2(r4)	;0x0002(r4)
    3c18:	84 4d 04 00 	mov	r13,	4(r4)	;0x0004(r4)
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    3c1c:	1e 44 02 00 	mov	2(r4),	r14	;0x0002(r4)
    3c20:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    3c24:	07 43       	clr	r7		
    3c26:	06 4f       	mov	r15,	r6	
    3c28:	07 43       	clr	r7		
    3c2a:	84 46 00 00 	mov	r6,	0(r4)	;0x0000(r4)
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    3c2e:	84 f3 04 00 	and	#0,	4(r4)	;r3 As==00, 0x0004(r4)
    OSTimeDly((INT16U)ticks);
    3c32:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3c36:	b0 12 4e 3a 	call	#0x3a4e	
    3c3a:	0a 3c       	jmp	$+22     	;abs 0x3c50
    while (loops > 0) {
        OSTimeDly((INT16U)32768u);
    3c3c:	3f 40 00 80 	mov	#-32768,r15	;#0x8000
    3c40:	b0 12 4e 3a 	call	#0x3a4e	
        OSTimeDly((INT16U)32768u);
    3c44:	3f 40 00 80 	mov	#-32768,r15	;#0x8000
    3c48:	b0 12 4e 3a 	call	#0x3a4e	
        loops--;
    3c4c:	b4 53 00 00 	add	#-1,	0(r4)	;r3 As==11, 0x0000(r4)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)milli + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks / 65536L);            /* Compute the integral number of 65536 tick delays   */
    ticks = ticks % 65536L;                      /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
    3c50:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    3c54:	f3 23       	jnz	$-24     	;abs 0x3c3c
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_NO_ERR);
    3c56:	4f 43       	clr.b	r15		
}
    3c58:	31 50 10 00 	add	#16,	r1	;#0x0010
    3c5c:	34 41       	pop	r4		
    3c5e:	36 41       	pop	r6		
    3c60:	37 41       	pop	r7		
    3c62:	38 41       	pop	r8		
    3c64:	39 41       	pop	r9		
    3c66:	3a 41       	pop	r10		
    3c68:	3b 41       	pop	r11		
    3c6a:	30 41       	ret			

00003c6c <initDisplay>:



#include "Display.h"

void initDisplay() {
    3c6c:	04 12       	push	r4		
    3c6e:	04 41       	mov	r1,	r4	
	InitOsc();
    3c70:	b0 12 78 3f 	call	#0x3f78	
	InitPorts();
    3c74:	b0 12 fc 3f 	call	#0x3ffc	
	InitLCD();
    3c78:	b0 12 22 42 	call	#0x4222	
	clearDisplay();
    3c7c:	b0 12 9a 3c 	call	#0x3c9a	
}
    3c80:	34 41       	pop	r4		
    3c82:	30 41       	ret			

00003c84 <putch>:
void putch(char c) {
    3c84:	04 12       	push	r4		
    3c86:	21 83       	decd	r1		
    3c88:	04 41       	mov	r1,	r4	
    3c8a:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
	SEND_CHAR(c);
    3c8e:	6f 44       	mov.b	@r4,	r15	
    3c90:	b0 12 fa 40 	call	#0x40fa	
}
    3c94:	21 53       	incd	r1		
    3c96:	34 41       	pop	r4		
    3c98:	30 41       	ret			

00003c9a <clearDisplay>:
void clearDisplay() {
    3c9a:	04 12       	push	r4		
    3c9c:	04 41       	mov	r1,	r4	
	SEND_CMD(CLR_DISP);
    3c9e:	5f 43       	mov.b	#1,	r15	;r3 As==01
    3ca0:	b0 12 8e 41 	call	#0x418e	
	Delayx100us(10);
    3ca4:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3ca8:	0f 43       	clr	r15		
    3caa:	b0 12 92 40 	call	#0x4092	
}
    3cae:	34 41       	pop	r4		
    3cb0:	30 41       	ret			

00003cb2 <gotoSecondLine>:
void gotoSecondLine() {
    3cb2:	04 12       	push	r4		
    3cb4:	04 41       	mov	r1,	r4	
//    SEND_CMD(CLR_DISP);
	SEND_CMD(DD_RAM_ADDR2);
    3cb6:	7f 40 c0 ff 	mov.b	#-64,	r15	;#0xffc0
    3cba:	b0 12 8e 41 	call	#0x418e	
}
    3cbe:	34 41       	pop	r4		
    3cc0:	30 41       	ret			

00003cc2 <printString>:
void printString(char *String) {
    3cc2:	04 12       	push	r4		
    3cc4:	21 83       	decd	r1		
    3cc6:	04 41       	mov	r1,	r4	
    3cc8:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
    3ccc:	06 3c       	jmp	$+14     	;abs 0x3cda
	while (*String)
		putch(*String++);
    3cce:	2f 44       	mov	@r4,	r15	
    3cd0:	6f 4f       	mov.b	@r15,	r15	
    3cd2:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    3cd6:	b0 12 84 3c 	call	#0x3c84	
void gotoSecondLine() {
//    SEND_CMD(CLR_DISP);
	SEND_CMD(DD_RAM_ADDR2);
}
void printString(char *String) {
	while (*String)
    3cda:	2f 44       	mov	@r4,	r15	
    3cdc:	6f 4f       	mov.b	@r15,	r15	
    3cde:	4f 93       	tst.b	r15		
    3ce0:	f6 23       	jnz	$-18     	;abs 0x3cce
		putch(*String++);
}
    3ce2:	21 53       	incd	r1		
    3ce4:	34 41       	pop	r4		
    3ce6:	30 41       	ret			

00003ce8 <HexDigit>:
char HexDigit(int digitvalue) {
    3ce8:	04 12       	push	r4		
    3cea:	21 83       	decd	r1		
    3cec:	04 41       	mov	r1,	r4	
    3cee:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	if (digitvalue < 10)
    3cf2:	b4 90 0a 00 	cmp	#10,	0(r4)	;#0x000a, 0x0000(r4)
    3cf6:	00 00 
    3cf8:	04 34       	jge	$+10     	;abs 0x3d02
		return (digitvalue + '0');
    3cfa:	2f 44       	mov	@r4,	r15	
    3cfc:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3d00:	03 3c       	jmp	$+8      	;abs 0x3d08
	else
		return (digitvalue + 'A' - 10);
    3d02:	2f 44       	mov	@r4,	r15	
    3d04:	7f 50 37 00 	add.b	#55,	r15	;#0x0037
}
    3d08:	21 53       	incd	r1		
    3d0a:	34 41       	pop	r4		
    3d0c:	30 41       	ret			

00003d0e <printByte>:
void printByte(INT8U theByte) {
    3d0e:	04 12       	push	r4		
    3d10:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    3d14:	04 41       	mov	r1,	r4	
    3d16:	c4 4f 04 00 	mov.b	r15,	4(r4)	;0x0004(r4)
	char HexBuffer[3];
	HexBuffer[2] = '\0';
    3d1a:	c4 43 02 00 	mov.b	#0,	2(r4)	;r3 As==00, 0x0002(r4)
	HexBuffer[1] = HexDigit(theByte & 0x000f);
    3d1e:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    3d22:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d26:	b0 12 e8 3c 	call	#0x3ce8	
    3d2a:	c4 4f 01 00 	mov.b	r15,	1(r4)	;0x0001(r4)
	theByte = theByte >> 4;
    3d2e:	12 c3       	clrc			
    3d30:	54 10 04 00 	rrc.b	4(r4)		;0x0004(r4)
    3d34:	54 11 04 00 	rra.b	4(r4)		;0x0004(r4)
    3d38:	54 11 04 00 	rra.b	4(r4)		;0x0004(r4)
    3d3c:	54 11 04 00 	rra.b	4(r4)		;0x0004(r4)
	HexBuffer[0] = HexDigit(theByte & 0x000f);
    3d40:	5f 44 04 00 	mov.b	4(r4),	r15	;0x0004(r4)
    3d44:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d48:	b0 12 e8 3c 	call	#0x3ce8	
    3d4c:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
	printString(HexBuffer);
    3d50:	0f 44       	mov	r4,	r15	
    3d52:	b0 12 c2 3c 	call	#0x3cc2	
}
    3d56:	31 50 06 00 	add	#6,	r1	;#0x0006
    3d5a:	34 41       	pop	r4		
    3d5c:	30 41       	ret			

00003d5e <printHex>:
void printHex(unsigned int Number) {
    3d5e:	04 12       	push	r4		
    3d60:	31 82       	sub	#8,	r1	;r2 As==11
    3d62:	04 41       	mov	r1,	r4	
    3d64:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	char HexBuffer[5];
	HexBuffer[4] = 0;
    3d68:	c4 43 04 00 	mov.b	#0,	4(r4)	;r3 As==00, 0x0004(r4)
	HexBuffer[3] = HexDigit(Number & 0x000f);
    3d6c:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3d70:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d74:	b0 12 e8 3c 	call	#0x3ce8	
    3d78:	c4 4f 03 00 	mov.b	r15,	3(r4)	;0x0003(r4)
	Number = Number >> 4;
    3d7c:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3d80:	12 c3       	clrc			
    3d82:	0f 10       	rrc	r15		
    3d84:	0f 11       	rra	r15		
    3d86:	0f 11       	rra	r15		
    3d88:	0f 11       	rra	r15		
    3d8a:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	HexBuffer[2] = HexDigit(Number & 0x000f);
    3d8e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3d92:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3d96:	b0 12 e8 3c 	call	#0x3ce8	
    3d9a:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
	Number = Number >> 4;
    3d9e:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3da2:	12 c3       	clrc			
    3da4:	0f 10       	rrc	r15		
    3da6:	0f 11       	rra	r15		
    3da8:	0f 11       	rra	r15		
    3daa:	0f 11       	rra	r15		
    3dac:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	HexBuffer[1] = HexDigit(Number & 0x000f);
    3db0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3db4:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3db8:	b0 12 e8 3c 	call	#0x3ce8	
    3dbc:	c4 4f 01 00 	mov.b	r15,	1(r4)	;0x0001(r4)
	Number = Number >> 4;
    3dc0:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3dc4:	12 c3       	clrc			
    3dc6:	0f 10       	rrc	r15		
    3dc8:	0f 11       	rra	r15		
    3dca:	0f 11       	rra	r15		
    3dcc:	0f 11       	rra	r15		
    3dce:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	HexBuffer[0] = HexDigit(Number & 0x000f);
    3dd2:	1f 44 06 00 	mov	6(r4),	r15	;0x0006(r4)
    3dd6:	3f f0 0f 00 	and	#15,	r15	;#0x000f
    3dda:	b0 12 e8 3c 	call	#0x3ce8	
    3dde:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
	printString(HexBuffer);
    3de2:	0f 44       	mov	r4,	r15	
    3de4:	b0 12 c2 3c 	call	#0x3cc2	
}
    3de8:	31 52       	add	#8,	r1	;r2 As==11
    3dea:	34 41       	pop	r4		
    3dec:	30 41       	ret			

00003dee <printDecimal>:
void printDecimal(int Number) {
    3dee:	0b 12       	push	r11		
    3df0:	0a 12       	push	r10		
    3df2:	09 12       	push	r9		
    3df4:	08 12       	push	r8		
    3df6:	04 12       	push	r4		
    3df8:	31 50 f2 ff 	add	#-14,	r1	;#0xfff2
    3dfc:	04 41       	mov	r1,	r4	
    3dfe:	84 4f 0c 00 	mov	r15,	12(r4)	;0x000c(r4)
	// need to move to long int to account for
	// negative 32768
	char DecimalBuffer[7];
	long lNumber = Number;
    3e02:	94 44 0c 00 	mov	12(r4),	0(r4)	;0x000c(r4), 0x0000(r4)
    3e06:	00 00 
    3e08:	a4 44 02 00 	mov	@r4,	2(r4)	;0x0002(r4)
    3e0c:	94 54 02 00 	rla	2(r4)		;0x0002(r4)
    3e10:	02 00 
    3e12:	94 74 02 00 	subc	2(r4),	2(r4)	;0x0002(r4), 0x0002(r4)
    3e16:	02 00 
    3e18:	b4 e3 02 00 	xor	#-1,	2(r4)	;r3 As==11, 0x0002(r4)
	DecimalBuffer[6] = 0;
    3e1c:	c4 43 0a 00 	mov.b	#0,	10(r4)	;r3 As==00, 0x000a(r4)
	if (lNumber < 0) {
    3e20:	84 93 02 00 	tst	2(r4)		;0x0002(r4)
    3e24:	0f 34       	jge	$+32     	;abs 0x3e44
		DecimalBuffer[0] = '-';
    3e26:	f4 40 2d 00 	mov.b	#45,	4(r4)	;#0x002d, 0x0004(r4)
    3e2a:	04 00 
		lNumber = -lNumber;
    3e2c:	2e 44       	mov	@r4,	r14	
    3e2e:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    3e32:	3e e3       	inv	r14		
    3e34:	3f e3       	inv	r15		
    3e36:	1e 53       	inc	r14		
    3e38:	0f 63       	adc	r15		
    3e3a:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3e3e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
    3e42:	03 3c       	jmp	$+8      	;abs 0x3e4a
	} else
		DecimalBuffer[0] = '+';
    3e44:	f4 40 2b 00 	mov.b	#43,	4(r4)	;#0x002b, 0x0004(r4)
    3e48:	04 00 
	DecimalBuffer[5] = (lNumber % 10) + '0';
    3e4a:	2c 44       	mov	@r4,	r12	
    3e4c:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3e50:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3e54:	0f 43       	clr	r15		
    3e56:	0a 4e       	mov	r14,	r10	
    3e58:	0b 4f       	mov	r15,	r11	
    3e5a:	b0 12 e2 45 	call	#0x45e2	
    3e5e:	4f 4e       	mov.b	r14,	r15	
    3e60:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3e64:	c4 4f 09 00 	mov.b	r15,	9(r4)	;0x0009(r4)
	lNumber = lNumber / 10;
    3e68:	2c 44       	mov	@r4,	r12	
    3e6a:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3e6e:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3e72:	0f 43       	clr	r15		
    3e74:	0a 4e       	mov	r14,	r10	
    3e76:	0b 4f       	mov	r15,	r11	
    3e78:	b0 12 e2 45 	call	#0x45e2	
    3e7c:	0e 4c       	mov	r12,	r14	
    3e7e:	0f 4d       	mov	r13,	r15	
    3e80:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3e84:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[4] = (lNumber % 10) + '0';
    3e88:	2c 44       	mov	@r4,	r12	
    3e8a:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3e8e:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3e92:	0f 43       	clr	r15		
    3e94:	0a 4e       	mov	r14,	r10	
    3e96:	0b 4f       	mov	r15,	r11	
    3e98:	b0 12 e2 45 	call	#0x45e2	
    3e9c:	4f 4e       	mov.b	r14,	r15	
    3e9e:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3ea2:	c4 4f 08 00 	mov.b	r15,	8(r4)	;0x0008(r4)
	lNumber = lNumber / 10;
    3ea6:	2c 44       	mov	@r4,	r12	
    3ea8:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3eac:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3eb0:	0f 43       	clr	r15		
    3eb2:	0a 4e       	mov	r14,	r10	
    3eb4:	0b 4f       	mov	r15,	r11	
    3eb6:	b0 12 e2 45 	call	#0x45e2	
    3eba:	0e 4c       	mov	r12,	r14	
    3ebc:	0f 4d       	mov	r13,	r15	
    3ebe:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3ec2:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[3] = (lNumber % 10) + '0';
    3ec6:	2c 44       	mov	@r4,	r12	
    3ec8:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3ecc:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3ed0:	0f 43       	clr	r15		
    3ed2:	0a 4e       	mov	r14,	r10	
    3ed4:	0b 4f       	mov	r15,	r11	
    3ed6:	b0 12 e2 45 	call	#0x45e2	
    3eda:	4f 4e       	mov.b	r14,	r15	
    3edc:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3ee0:	c4 4f 07 00 	mov.b	r15,	7(r4)	;0x0007(r4)
	lNumber = lNumber / 10;
    3ee4:	2c 44       	mov	@r4,	r12	
    3ee6:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3eea:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3eee:	0f 43       	clr	r15		
    3ef0:	0a 4e       	mov	r14,	r10	
    3ef2:	0b 4f       	mov	r15,	r11	
    3ef4:	b0 12 e2 45 	call	#0x45e2	
    3ef8:	0e 4c       	mov	r12,	r14	
    3efa:	0f 4d       	mov	r13,	r15	
    3efc:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3f00:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[2] = (lNumber % 10) + '0';
    3f04:	2c 44       	mov	@r4,	r12	
    3f06:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f0a:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f0e:	0f 43       	clr	r15		
    3f10:	0a 4e       	mov	r14,	r10	
    3f12:	0b 4f       	mov	r15,	r11	
    3f14:	b0 12 e2 45 	call	#0x45e2	
    3f18:	4f 4e       	mov.b	r14,	r15	
    3f1a:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3f1e:	c4 4f 06 00 	mov.b	r15,	6(r4)	;0x0006(r4)
	lNumber = lNumber / 10;
    3f22:	2c 44       	mov	@r4,	r12	
    3f24:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f28:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f2c:	0f 43       	clr	r15		
    3f2e:	0a 4e       	mov	r14,	r10	
    3f30:	0b 4f       	mov	r15,	r11	
    3f32:	b0 12 e2 45 	call	#0x45e2	
    3f36:	0e 4c       	mov	r12,	r14	
    3f38:	0f 4d       	mov	r13,	r15	
    3f3a:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
    3f3e:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)
	DecimalBuffer[1] = (lNumber % 10) + '0';
    3f42:	2c 44       	mov	@r4,	r12	
    3f44:	1d 44 02 00 	mov	2(r4),	r13	;0x0002(r4)
    3f48:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    3f4c:	0f 43       	clr	r15		
    3f4e:	0a 4e       	mov	r14,	r10	
    3f50:	0b 4f       	mov	r15,	r11	
    3f52:	b0 12 e2 45 	call	#0x45e2	
    3f56:	4f 4e       	mov.b	r14,	r15	
    3f58:	7f 50 30 00 	add.b	#48,	r15	;#0x0030
    3f5c:	c4 4f 05 00 	mov.b	r15,	5(r4)	;0x0005(r4)
	printString(DecimalBuffer);
    3f60:	0f 44       	mov	r4,	r15	
    3f62:	2f 52       	add	#4,	r15	;r2 As==10
    3f64:	b0 12 c2 3c 	call	#0x3cc2	
}
    3f68:	31 50 0e 00 	add	#14,	r1	;#0x000e
    3f6c:	34 41       	pop	r4		
    3f6e:	38 41       	pop	r8		
    3f70:	39 41       	pop	r9		
    3f72:	3a 41       	pop	r10		
    3f74:	3b 41       	pop	r11		
    3f76:	30 41       	ret			

00003f78 <InitOsc>:

void InitOsc(void) {
    3f78:	04 12       	push	r4		
    3f7a:	04 41       	mov	r1,	r4	
	WDTCTL = WDTPW | WDTHOLD; // stop watchdog timer
    3f7c:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    3f80:	20 01 

	BCSCTL1 |= XTS; // XT1 as high-frequency
    3f82:	5f 42 57 00 	mov.b	&0x0057,r15	
    3f86:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    3f8a:	c2 4f 57 00 	mov.b	r15,	&0x0057	
	_BIC_SR(OSCOFF);
    3f8e:	32 c0 20 00 	bic	#32,	r2	;#0x0020
	// turn on XT1 oscillator

	do // wait in loop until crystal is stable
		IFG1 &= ~OFIFG;
    3f92:	5f 42 02 00 	mov.b	&0x0002,r15	
    3f96:	6f c3       	bic.b	#2,	r15	;r3 As==10
    3f98:	c2 4f 02 00 	mov.b	r15,	&0x0002	
	while (IFG1 & OFIFG);
    3f9c:	5f 42 02 00 	mov.b	&0x0002,r15	
    3fa0:	7f f3       	and.b	#-1,	r15	;r3 As==11
    3fa2:	2f f3       	and	#2,	r15	;r3 As==10
    3fa4:	f6 23       	jnz	$-18     	;abs 0x3f92

	BCSCTL1 |= DIVA0; // ACLK = XT1 / 2
    3fa6:	5f 42 57 00 	mov.b	&0x0057,r15	
    3faa:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    3fae:	c2 4f 57 00 	mov.b	r15,	&0x0057	
	BCSCTL1 &= ~DIVA1;
    3fb2:	5f 42 57 00 	mov.b	&0x0057,r15	
    3fb6:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    3fba:	c2 4f 57 00 	mov.b	r15,	&0x0057	

	IE1 &= ~WDTIE; // disable WDT int.
    3fbe:	5f 42 00 00 	mov.b	&0x0000,r15	
    3fc2:	5f c3       	bic.b	#1,	r15	;r3 As==01
    3fc4:	c2 4f 00 00 	mov.b	r15,	&0x0000	
	IFG1 &= ~WDTIFG; // clear WDT int. flag
    3fc8:	5f 42 02 00 	mov.b	&0x0002,r15	
    3fcc:	5f c3       	bic.b	#1,	r15	;r3 As==01
    3fce:	c2 4f 02 00 	mov.b	r15,	&0x0002	

	WDTCTL = WDTPW | WDTTMSEL | WDTCNTCL | WDTSSEL | WDTIS1; // use WDT as timer, flag each
    3fd2:	b2 40 1e 5a 	mov	#23070,	&0x0120	;#0x5a1e
    3fd6:	20 01 
															 // 512 pulses from ACLK

	while (!(IFG1 & WDTIFG))
    3fd8:	5f 42 02 00 	mov.b	&0x0002,r15	
    3fdc:	7f f3       	and.b	#-1,	r15	;r3 As==11
    3fde:	1f f3       	and	#1,	r15	;r3 As==01
    3fe0:	fb 27       	jz	$-8      	;abs 0x3fd8
		; // count 1024 pulses from XT1 (until XT1's
		  // amplitude is OK)

	IFG1 &= ~OFIFG; // clear osc. fault int. flag
    3fe2:	5f 42 02 00 	mov.b	&0x0002,r15	
    3fe6:	6f c3       	bic.b	#2,	r15	;r3 As==10
    3fe8:	c2 4f 02 00 	mov.b	r15,	&0x0002	
	BCSCTL2 |= SELM0 | SELM1; // set XT1 as MCLK
    3fec:	5f 42 58 00 	mov.b	&0x0058,r15	
    3ff0:	7f d0 c0 ff 	bis.b	#-64,	r15	;#0xffc0
    3ff4:	c2 4f 58 00 	mov.b	r15,	&0x0058	
}
    3ff8:	34 41       	pop	r4		
    3ffa:	30 41       	ret			

00003ffc <InitPorts>:

void InitPorts(void) {
    3ffc:	04 12       	push	r4		
    3ffe:	04 41       	mov	r1,	r4	
	P1SEL = 0; //
    4000:	c2 43 26 00 	mov.b	#0,	&0x0026	;r3 As==00
	P1OUT = 0; //
    4004:	c2 43 21 00 	mov.b	#0,	&0x0021	;r3 As==00
	P1DIR = BIT5 | BIT6; //enable only Relay outputs
    4008:	f2 40 60 00 	mov.b	#96,	&0x0022	;#0x0060
    400c:	22 00 

	P2SEL = 0;
    400e:	c2 43 2e 00 	mov.b	#0,	&0x002e	;r3 As==00
	P2OUT = 0;
    4012:	c2 43 29 00 	mov.b	#0,	&0x0029	;r3 As==00
	P2DIR = ~BIT0; //only P2.0 is input
    4016:	f2 40 fe ff 	mov.b	#-2,	&0x002a	;#0xfffe
    401a:	2a 00 

	P3SEL |= BIT4 | BIT5; //enable UART0
    401c:	5f 42 1b 00 	mov.b	&0x001b,r15	
    4020:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    4024:	c2 4f 1b 00 	mov.b	r15,	&0x001b	
	P3DIR |= BIT4; //enable TXD0 as output
    4028:	5f 42 1a 00 	mov.b	&0x001a,r15	
    402c:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    4030:	c2 4f 1a 00 	mov.b	r15,	&0x001a	
	P3DIR &= ~BIT5; //enable RXD0 as input
    4034:	5f 42 1a 00 	mov.b	&0x001a,r15	
    4038:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    403c:	c2 4f 1a 00 	mov.b	r15,	&0x001a	

	P4SEL = 0;
    4040:	c2 43 1f 00 	mov.b	#0,	&0x001f	;r3 As==00
	P4OUT = 0;
    4044:	c2 43 1d 00 	mov.b	#0,	&0x001d	;r3 As==00
	P4DIR = BIT2 | BIT3; //only buzzer pins are outputs
    4048:	f2 40 0c 00 	mov.b	#12,	&0x001e	;#0x000c
    404c:	1e 00 

	//P6SEL = 0x80;
	//P6OUT = 0;
	//P6DIR = 0x00;
	//all output
}
    404e:	34 41       	pop	r4		
    4050:	30 41       	ret			

00004052 <Delay>:

void Delay(unsigned long int a)

{
    4052:	04 12       	push	r4		
    4054:	31 50 fa ff 	add	#-6,	r1	;#0xfffa
    4058:	04 41       	mov	r1,	r4	
    405a:	84 4e 02 00 	mov	r14,	2(r4)	;0x0002(r4)
    405e:	84 4f 04 00 	mov	r15,	4(r4)	;0x0004(r4)
	int k;
	for (k = 0; k != a; ++k) {
    4062:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    4066:	06 3c       	jmp	$+14     	;abs 0x4074
		_NOP();
    4068:	03 43       	nop			
		_NOP();
    406a:	03 43       	nop			
		_NOP();
    406c:	03 43       	nop			
		_NOP();
    406e:	03 43       	nop			

void Delay(unsigned long int a)

{
	int k;
	for (k = 0; k != a; ++k) {
    4070:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    4074:	2e 44       	mov	@r4,	r14	
    4076:	0f 4e       	mov	r14,	r15	
    4078:	0f 5f       	rla	r15		
    407a:	0f 7f       	subc	r15,	r15	
    407c:	3f e3       	inv	r15		
    407e:	1e 94 02 00 	cmp	2(r4),	r14	;0x0002(r4)
    4082:	f2 23       	jnz	$-26     	;abs 0x4068
    4084:	1f 94 04 00 	cmp	4(r4),	r15	;0x0004(r4)
    4088:	ef 23       	jnz	$-32     	;abs 0x4068
		_NOP();
		_NOP();
		_NOP();
		_NOP();
	}
}
    408a:	31 50 06 00 	add	#6,	r1	;#0x0006
    408e:	34 41       	pop	r4		
    4090:	30 41       	ret			

00004092 <Delayx100us>:

void Delayx100us(unsigned long int b) {
    4092:	04 12       	push	r4		
    4094:	31 82       	sub	#8,	r1	;r2 As==11
    4096:	04 41       	mov	r1,	r4	
    4098:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    409c:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)
	long int j;

	for (j = 0; j != b; ++j)
    40a0:	84 43 00 00 	mov	#0,	0(r4)	;r3 As==00, 0x0000(r4)
    40a4:	84 43 02 00 	mov	#0,	2(r4)	;r3 As==00, 0x0002(r4)
    40a8:	09 3c       	jmp	$+20     	;abs 0x40bc
		Delay(_100us);
    40aa:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    40ae:	0f 43       	clr	r15		
    40b0:	b0 12 52 40 	call	#0x4052	
}

void Delayx100us(unsigned long int b) {
	long int j;

	for (j = 0; j != b; ++j)
    40b4:	94 53 00 00 	inc	0(r4)		;0x0000(r4)
    40b8:	84 63 02 00 	adc	2(r4)		;0x0002(r4)
    40bc:	2e 44       	mov	@r4,	r14	
    40be:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    40c2:	1e 94 04 00 	cmp	4(r4),	r14	;0x0004(r4)
    40c6:	f1 23       	jnz	$-28     	;abs 0x40aa
    40c8:	1f 94 06 00 	cmp	6(r4),	r15	;0x0006(r4)
    40cc:	ee 23       	jnz	$-34     	;abs 0x40aa
		Delay(_100us);
}
    40ce:	31 52       	add	#8,	r1	;r2 As==11
    40d0:	34 41       	pop	r4		
    40d2:	30 41       	ret			

000040d4 <_E>:

void _E(void) {
    40d4:	04 12       	push	r4		
    40d6:	04 41       	mov	r1,	r4	
	bitset(P2OUT, E);
    40d8:	5f 42 29 00 	mov.b	&0x0029,r15	
    40dc:	7f d2       	bis.b	#8,	r15	;r2 As==11
    40de:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//toggle E for LCD
	Delay(_10us);
    40e2:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    40e6:	0f 43       	clr	r15		
    40e8:	b0 12 52 40 	call	#0x4052	
	bitclr(P2OUT, E);
    40ec:	5f 42 29 00 	mov.b	&0x0029,r15	
    40f0:	7f c2       	bic.b	#8,	r15	;r2 As==11
    40f2:	c2 4f 29 00 	mov.b	r15,	&0x0029	
}
    40f6:	34 41       	pop	r4		
    40f8:	30 41       	ret			

000040fa <SEND_CHAR>:

void SEND_CHAR(unsigned char d) {
    40fa:	04 12       	push	r4		
    40fc:	21 82       	sub	#4,	r1	;r2 As==10
    40fe:	04 41       	mov	r1,	r4	
    4100:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
	int temp;
	Delayx100us(5); //.5ms
    4104:	3e 40 05 00 	mov	#5,	r14	;#0x0005
    4108:	0f 43       	clr	r15		
    410a:	b0 12 92 40 	call	#0x4092	
	temp = d & 0xf0; //get upper nibble
    410e:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    4112:	0e 4f       	mov	r15,	r14	
    4114:	3e f0 f0 00 	and	#240,	r14	;#0x00f0
    4118:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    411c:	5f 42 29 00 	mov.b	&0x0029,r15	
    4120:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    4124:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    4128:	2f 44       	mov	@r4,	r15	
    412a:	4e 4f       	mov.b	r15,	r14	
    412c:	5f 42 29 00 	mov.b	&0x0029,r15	
    4130:	4f de       	bis.b	r14,	r15	
    4132:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitset(P2OUT, RS);
    4136:	5f 42 29 00 	mov.b	&0x0029,r15	
    413a:	6f d2       	bis.b	#4,	r15	;r2 As==10
    413c:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to data mode
	_E(); //toggle E for LCD
    4140:	b0 12 d4 40 	call	#0x40d4	
	temp = d & 0x0f;
    4144:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    4148:	0e 4f       	mov	r15,	r14	
    414a:	3e f0 0f 00 	and	#15,	r14	;#0x000f
    414e:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	temp = temp << 4; //get down nibble
    4152:	2f 44       	mov	@r4,	r15	
    4154:	0f 5f       	rla	r15		
    4156:	0f 5f       	rla	r15		
    4158:	0f 5f       	rla	r15		
    415a:	0f 5f       	rla	r15		
    415c:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    4160:	5f 42 29 00 	mov.b	&0x0029,r15	
    4164:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    4168:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    416c:	2f 44       	mov	@r4,	r15	
    416e:	4e 4f       	mov.b	r15,	r14	
    4170:	5f 42 29 00 	mov.b	&0x0029,r15	
    4174:	4f de       	bis.b	r14,	r15	
    4176:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitset(P2OUT, RS);
    417a:	5f 42 29 00 	mov.b	&0x0029,r15	
    417e:	6f d2       	bis.b	#4,	r15	;r2 As==10
    4180:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to data mode
	_E(); //toggle E for LCD
    4184:	b0 12 d4 40 	call	#0x40d4	
}
    4188:	21 52       	add	#4,	r1	;r2 As==10
    418a:	34 41       	pop	r4		
    418c:	30 41       	ret			

0000418e <SEND_CMD>:

void SEND_CMD(unsigned char e) {
    418e:	04 12       	push	r4		
    4190:	21 82       	sub	#4,	r1	;r2 As==10
    4192:	04 41       	mov	r1,	r4	
    4194:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
	int temp;
	Delayx100us(10); //10ms
    4198:	3e 40 0a 00 	mov	#10,	r14	;#0x000a
    419c:	0f 43       	clr	r15		
    419e:	b0 12 92 40 	call	#0x4092	
	temp = e & 0xf0; //get upper nibble
    41a2:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    41a6:	0e 4f       	mov	r15,	r14	
    41a8:	3e f0 f0 00 	and	#240,	r14	;#0x00f0
    41ac:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    41b0:	5f 42 29 00 	mov.b	&0x0029,r15	
    41b4:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    41b8:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp; //send CMD to LCD
    41bc:	2f 44       	mov	@r4,	r15	
    41be:	4e 4f       	mov.b	r15,	r14	
    41c0:	5f 42 29 00 	mov.b	&0x0029,r15	
    41c4:	4f de       	bis.b	r14,	r15	
    41c6:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitclr(P2OUT, RS);
    41ca:	5f 42 29 00 	mov.b	&0x0029,r15	
    41ce:	6f c2       	bic.b	#4,	r15	;r2 As==10
    41d0:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to CMD mode
	_E(); //toggle E for LCD
    41d4:	b0 12 d4 40 	call	#0x40d4	
	temp = e & 0x0f;
    41d8:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    41dc:	0e 4f       	mov	r15,	r14	
    41de:	3e f0 0f 00 	and	#15,	r14	;#0x000f
    41e2:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)
	temp = temp << 4; //get down nibble
    41e6:	2f 44       	mov	@r4,	r15	
    41e8:	0f 5f       	rla	r15		
    41ea:	0f 5f       	rla	r15		
    41ec:	0f 5f       	rla	r15		
    41ee:	0f 5f       	rla	r15		
    41f0:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	LCD_Data &= 0x0f;
    41f4:	5f 42 29 00 	mov.b	&0x0029,r15	
    41f8:	7f f0 0f 00 	and.b	#15,	r15	;#0x000f
    41fc:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data |= temp;
    4200:	2f 44       	mov	@r4,	r15	
    4202:	4e 4f       	mov.b	r15,	r14	
    4204:	5f 42 29 00 	mov.b	&0x0029,r15	
    4208:	4f de       	bis.b	r14,	r15	
    420a:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	bitclr(P2OUT, RS);
    420e:	5f 42 29 00 	mov.b	&0x0029,r15	
    4212:	6f c2       	bic.b	#4,	r15	;r2 As==10
    4214:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	//set LCD to CMD mode
	_E(); //toggle E for LCD
    4218:	b0 12 d4 40 	call	#0x40d4	
}
    421c:	21 52       	add	#4,	r1	;r2 As==10
    421e:	34 41       	pop	r4		
    4220:	30 41       	ret			

00004222 <InitLCD>:

void InitLCD(void) {
    4222:	04 12       	push	r4		
    4224:	04 41       	mov	r1,	r4	
	bitclr(P2OUT, RS);
    4226:	5f 42 29 00 	mov.b	&0x0029,r15	
    422a:	6f c2       	bic.b	#4,	r15	;r2 As==10
    422c:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	Delayx100us(250); //Delay 100ms
    4230:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4234:	0f 43       	clr	r15		
    4236:	b0 12 92 40 	call	#0x4092	
	Delayx100us(250);
    423a:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    423e:	0f 43       	clr	r15		
    4240:	b0 12 92 40 	call	#0x4092	
	Delayx100us(250);
    4244:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4248:	0f 43       	clr	r15		
    424a:	b0 12 92 40 	call	#0x4092	
	Delayx100us(250);
    424e:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    4252:	0f 43       	clr	r15		
    4254:	b0 12 92 40 	call	#0x4092	
	LCD_Data |= BIT4 | BIT5; //D7-D4 = 0011
    4258:	5f 42 29 00 	mov.b	&0x0029,r15	
    425c:	7f d0 30 00 	bis.b	#48,	r15	;#0x0030
    4260:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	LCD_Data &= ~BIT6 & ~BIT7;
    4264:	5f 42 29 00 	mov.b	&0x0029,r15	
    4268:	7f f0 3f 00 	and.b	#63,	r15	;#0x003f
    426c:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	_E(); //toggle E for LCD
    4270:	b0 12 d4 40 	call	#0x40d4	
	Delayx100us(100); //10ms
    4274:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    4278:	0f 43       	clr	r15		
    427a:	b0 12 92 40 	call	#0x4092	
	_E(); //toggle E for LCD
    427e:	b0 12 d4 40 	call	#0x40d4	
	Delayx100us(100); //10ms
    4282:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    4286:	0f 43       	clr	r15		
    4288:	b0 12 92 40 	call	#0x4092	
	_E(); //toggle E for LCD
    428c:	b0 12 d4 40 	call	#0x40d4	
	Delayx100us(100); //10ms
    4290:	3e 40 64 00 	mov	#100,	r14	;#0x0064
    4294:	0f 43       	clr	r15		
    4296:	b0 12 92 40 	call	#0x4092	
	LCD_Data &= ~BIT4;
    429a:	5f 42 29 00 	mov.b	&0x0029,r15	
    429e:	7f f0 ef ff 	and.b	#-17,	r15	;#0xffef
    42a2:	c2 4f 29 00 	mov.b	r15,	&0x0029	
	_E(); //toggle E for LCD
    42a6:	b0 12 d4 40 	call	#0x40d4	

	SEND_CMD(DISP_ON);
    42aa:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    42ae:	b0 12 8e 41 	call	#0x418e	
	SEND_CMD(CLR_DISP);
    42b2:	5f 43       	mov.b	#1,	r15	;r3 As==01
    42b4:	b0 12 8e 41 	call	#0x418e	
	Delayx100us(250);
    42b8:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    42bc:	0f 43       	clr	r15		
    42be:	b0 12 92 40 	call	#0x4092	
	Delayx100us(250);
    42c2:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    42c6:	0f 43       	clr	r15		
    42c8:	b0 12 92 40 	call	#0x4092	
	Delayx100us(250);
    42cc:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    42d0:	0f 43       	clr	r15		
    42d2:	b0 12 92 40 	call	#0x4092	
	Delayx100us(250);
    42d6:	3e 40 fa 00 	mov	#250,	r14	;#0x00fa
    42da:	0f 43       	clr	r15		
    42dc:	b0 12 92 40 	call	#0x4092	
}
    42e0:	34 41       	pop	r4		
    42e2:	30 41       	ret			

000042e4 <ServiceOutput>:
INT8S setVolume(INT8U cmd, INT8U nb);

// Helpers
INT8S sendOverSPI(INT8U target, INT16U data, INT8U nbits);

void ServiceOutput(void *parg) {
    42e4:	04 12       	push	r4		
    42e6:	31 82       	sub	#8,	r1	;r2 As==11
    42e8:	04 41       	mov	r1,	r4	
    42ea:	84 4f 06 00 	mov	r15,	6(r4)	;0x0006(r4)

		OS_EVENT *msgQServiceOutput = (OS_EVENT*) parg;
    42ee:	94 44 06 00 	mov	6(r4),	2(r4)	;0x0006(r4), 0x0002(r4)
    42f2:	02 00 
		INT8U err;
		ServiceMsg* data;

		for (;;) {

			data = (ServiceMsg*) OSQPend (msgQServiceOutput, 0, &err);
    42f4:	0e 44       	mov	r4,	r14	
    42f6:	2e 52       	add	#4,	r14	;r2 As==10
    42f8:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    42fc:	0d 4e       	mov	r14,	r13	
    42fe:	0e 43       	clr	r14		
    4300:	b0 12 a2 2d 	call	#0x2da2	
    4304:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)

			switch(data->serviceType) {
    4308:	2f 44       	mov	@r4,	r15	
    430a:	2f 4f       	mov	@r15,	r15	
    430c:	2f 93       	cmp	#2,	r15	;r3 As==10
    430e:	10 24       	jz	$+34     	;abs 0x4330
    4310:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4314:	05 2c       	jc	$+12     	;abs 0x4320
    4316:	0f 93       	tst	r15		
    4318:	09 24       	jz	$+20     	;abs 0x432c
    431a:	1f 93       	cmp	#1,	r15	;r3 As==01
    431c:	08 24       	jz	$+18     	;abs 0x432e
    431e:	ea 3f       	jmp	$-42     	;abs 0x42f4
    4320:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4324:	0b 24       	jz	$+24     	;abs 0x433c
    4326:	2f 92       	cmp	#4,	r15	;r2 As==10
    4328:	11 24       	jz	$+36     	;abs 0x434c
    432a:	e4 3f       	jmp	$-54     	;abs 0x42f4
				break;
			default:
				// Error
				break;
			}
		}
    432c:	18 3c       	jmp	$+50     	;abs 0x435e

			data = (ServiceMsg*) OSQPend (msgQServiceOutput, 0, &err);

			switch(data->serviceType) {
			case SERV_BARGRAPH:
				break;
    432e:	17 3c       	jmp	$+48     	;abs 0x435e
			case SERV_EEPROM:
				break;
			case SERV_FREQ:
				setFrequency(data->val);
    4330:	2f 44       	mov	@r4,	r15	
    4332:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    4336:	b0 12 60 43 	call	#0x4360	
    433a:	11 3c       	jmp	$+36     	;abs 0x435e
				break;
			case SERV_LCD:
				clearDisplay();
    433c:	b0 12 9a 3c 	call	#0x3c9a	
				// Parse string '\n' gotoSecondLine() TODO
				printString(data->msg.pBuffer);
    4340:	2f 44       	mov	@r4,	r15	
    4342:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    4346:	b0 12 c2 3c 	call	#0x3cc2	
    434a:	09 3c       	jmp	$+20     	;abs 0x435e
				break;
			case SERV_VOLUME:
				setVolume(VOLUME_CMD, data->val);
    434c:	2f 44       	mov	@r4,	r15	
    434e:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    4352:	4e 4f       	mov.b	r15,	r14	
    4354:	7f 40 1f 00 	mov.b	#31,	r15	;#0x001f
    4358:	b0 12 b4 43 	call	#0x43b4	
    435c:	cb 3f       	jmp	$-104    	;abs 0x42f4
				break;
			default:
				// Error
				break;
			}
		}
    435e:	ca 3f       	jmp	$-106    	;abs 0x42f4

00004360 <setFrequency>:

}

INT8S setFrequency(INT16U nb) {
    4360:	04 12       	push	r4		
    4362:	21 82       	sub	#4,	r1	;r2 As==10
    4364:	04 41       	mov	r1,	r4	
    4366:	84 4f 02 00 	mov	r15,	2(r4)	;0x0002(r4)

	if(nb>1023) {
    436a:	b4 90 00 04 	cmp	#1024,	2(r4)	;#0x0400, 0x0002(r4)
    436e:	02 00 
    4370:	02 28       	jnc	$+6      	;abs 0x4376
		return -1;
    4372:	7f 43       	mov.b	#-1,	r15	;r3 As==11
    4374:	1c 3c       	jmp	$+58     	;abs 0x43ae
	}

	INT16U data = (nb << 2) & 0x0fff; // "create" dummy bits and select lowest 12 bits
    4376:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    437a:	0f 5f       	rla	r15		
    437c:	0f 5f       	rla	r15		
    437e:	0e 4f       	mov	r15,	r14	
    4380:	3e f0 ff 0f 	and	#4095,	r14	;#0x0fff
    4384:	84 4e 00 00 	mov	r14,	0(r4)	;0x0000(r4)

	clearDisplay();
    4388:	b0 12 9a 3c 	call	#0x3c9a	
	printDecimal(nb);
    438c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    4390:	b0 12 ee 3d 	call	#0x3dee	
	gotoSecondLine();
    4394:	b0 12 b2 3c 	call	#0x3cb2	
	printHex(data);
    4398:	2f 44       	mov	@r4,	r15	
    439a:	b0 12 5e 3d 	call	#0x3d5e	
	sendOverSPI(SPI_FREQ, data, 12);
    439e:	7f 40 0c 00 	mov.b	#12,	r15	;#0x000c
    43a2:	4d 4f       	mov.b	r15,	r13	
    43a4:	2e 44       	mov	@r4,	r14	
    43a6:	4f 43       	clr.b	r15		
    43a8:	b0 12 ea 43 	call	#0x43ea	

	return 0;
    43ac:	4f 43       	clr.b	r15		
}
    43ae:	21 52       	add	#4,	r1	;r2 As==10
    43b0:	34 41       	pop	r4		
    43b2:	30 41       	ret			

000043b4 <setVolume>:

INT8S setVolume(INT8U cmd, INT8U nb) {
    43b4:	04 12       	push	r4		
    43b6:	21 82       	sub	#4,	r1	;r2 As==10
    43b8:	04 41       	mov	r1,	r4	
    43ba:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
    43be:	c4 4e 03 00 	mov.b	r14,	3(r4)	;0x0003(r4)

	INT16U data = (cmd << 8) | nb;
    43c2:	5f 44 02 00 	mov.b	2(r4),	r15	;0x0002(r4)
    43c6:	7f f3       	and.b	#-1,	r15	;r3 As==11
    43c8:	8f 10       	swpb	r15		
    43ca:	5e 44 03 00 	mov.b	3(r4),	r14	;0x0003(r4)
    43ce:	0f de       	bis	r14,	r15	
    43d0:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	// Send command & data
	sendOverSPI(SPI_VOL, data, 16);
    43d4:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    43d8:	5f 43       	mov.b	#1,	r15	;r3 As==01
    43da:	4d 4e       	mov.b	r14,	r13	
    43dc:	2e 44       	mov	@r4,	r14	
    43de:	b0 12 ea 43 	call	#0x43ea	

	return 0;
    43e2:	4f 43       	clr.b	r15		
}
    43e4:	21 52       	add	#4,	r1	;r2 As==10
    43e6:	34 41       	pop	r4		
    43e8:	30 41       	ret			

000043ea <sendOverSPI>:
/////////////////////////////////////////////////////////////////
// HELPERS /////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////

// nbits=[1,15], nbits de poids faible
INT8S sendOverSPI(INT8U target, INT16U data, INT8U nbits) {
    43ea:	04 12       	push	r4		
    43ec:	31 82       	sub	#8,	r1	;r2 As==11
    43ee:	04 41       	mov	r1,	r4	
    43f0:	c4 4f 02 00 	mov.b	r15,	2(r4)	;0x0002(r4)
    43f4:	84 4e 04 00 	mov	r14,	4(r4)	;0x0004(r4)
    43f8:	c4 4d 06 00 	mov.b	r13,	6(r4)	;0x0006(r4)
	// Select SPI path
	if (target == SPI_FREQ) {
    43fc:	c4 93 02 00 	tst.b	2(r4)		;0x0002(r4)
    4400:	07 20       	jnz	$+16     	;abs 0x4410
		SEL_OFF;
    4402:	5f 42 35 00 	mov.b	&0x0035,r15	
    4406:	7f f0 7f 00 	and.b	#127,	r15	;#0x007f
    440a:	c2 4f 35 00 	mov.b	r15,	&0x0035	
    440e:	0c 3c       	jmp	$+26     	;abs 0x4428
	} else if(target == SPI_VOL) {
    4410:	d4 93 02 00 	cmp.b	#1,	2(r4)	;r3 As==01, 0x0002(r4)
    4414:	07 20       	jnz	$+16     	;abs 0x4424
		SEL_ON;
    4416:	5f 42 35 00 	mov.b	&0x0035,r15	
    441a:	7f d0 80 ff 	bis.b	#-128,	r15	;#0xff80
    441e:	c2 4f 35 00 	mov.b	r15,	&0x0035	
    4422:	02 3c       	jmp	$+6      	;abs 0x4428
	} else {
		return -1;
    4424:	7f 43       	mov.b	#-1,	r15	;r3 As==11
    4426:	57 3c       	jmp	$+176    	;abs 0x44d6
	}

	// Three state gate : disable and re-enable output
	CS_ON;
    4428:	5f 42 35 00 	mov.b	&0x0035,r15	
    442c:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    4430:	c2 4f 35 00 	mov.b	r15,	&0x0035	
	Delayx100us(1);
    4434:	1e 43       	mov	#1,	r14	;r3 As==01
    4436:	0f 43       	clr	r15		
    4438:	b0 12 92 40 	call	#0x4092	
	CS_OFF;
    443c:	5f 42 35 00 	mov.b	&0x0035,r15	
    4440:	7f f0 bf ff 	and.b	#-65,	r15	;#0xffbf
    4444:	c2 4f 35 00 	mov.b	r15,	&0x0035	

	INT8U currentBit;
	INT8U k = nbits;
    4448:	d4 44 06 00 	mov.b	6(r4),	0(r4)	;0x0006(r4), 0x0000(r4)
    444c:	00 00 
    444e:	39 3c       	jmp	$+116    	;abs 0x44c2
	while (k > 0)
	{
		currentBit = (data >> (k-1)) & 0x1;
    4450:	6f 44       	mov.b	@r4,	r15	
    4452:	0e 4f       	mov	r15,	r14	
    4454:	3e 53       	add	#-1,	r14	;r3 As==11
    4456:	1f 44 04 00 	mov	4(r4),	r15	;0x0004(r4)
    445a:	0e 93       	tst	r14		
    445c:	04 24       	jz	$+10     	;abs 0x4466
    445e:	12 c3       	clrc			
    4460:	0f 10       	rrc	r15		
    4462:	1e 83       	dec	r14		
    4464:	fc 23       	jnz	$-6      	;abs 0x445e
    4466:	4e 4f       	mov.b	r15,	r14	
    4468:	5e f3       	and.b	#1,	r14	;r3 As==01
    446a:	c4 4e 01 00 	mov.b	r14,	1(r4)	;0x0001(r4)
		if (currentBit)
    446e:	c4 93 01 00 	tst.b	1(r4)		;0x0001(r4)
    4472:	13 24       	jz	$+40     	;abs 0x449a
		{
			// currentBit = 1
			P6OUT |=0x10;	// DIN=1 	SCLK=0	 CS=0
    4474:	5f 42 35 00 	mov.b	&0x0035,r15	
    4478:	7f d0 10 00 	bis.b	#16,	r15	;#0x0010
    447c:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT |=0x20;	// SCLK=1
    4480:	5f 42 35 00 	mov.b	&0x0035,r15	
    4484:	7f d0 20 00 	bis.b	#32,	r15	;#0x0020
    4488:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT &=~0x20;	// SCLK=0
    448c:	5f 42 35 00 	mov.b	&0x0035,r15	
    4490:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    4494:	c2 4f 35 00 	mov.b	r15,	&0x0035	
    4498:	12 3c       	jmp	$+38     	;abs 0x44be
		}
		else
		{
			// currentBit = 0
			P6OUT &=~0x70;	// DIN=0 	SCLK=0	 CS=0
    449a:	5f 42 35 00 	mov.b	&0x0035,r15	
    449e:	7f f0 8f ff 	and.b	#-113,	r15	;#0xff8f
    44a2:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT |=0x20;	// SCLK=1
    44a6:	5f 42 35 00 	mov.b	&0x0035,r15	
    44aa:	7f d0 20 00 	bis.b	#32,	r15	;#0x0020
    44ae:	c2 4f 35 00 	mov.b	r15,	&0x0035	
			P6OUT &=~0x20;	// SCLK=0
    44b2:	5f 42 35 00 	mov.b	&0x0035,r15	
    44b6:	7f f0 df ff 	and.b	#-33,	r15	;#0xffdf
    44ba:	c2 4f 35 00 	mov.b	r15,	&0x0035	
		}
		--k;
    44be:	f4 53 00 00 	add.b	#-1,	0(r4)	;r3 As==11, 0x0000(r4)
	Delayx100us(1);
	CS_OFF;

	INT8U currentBit;
	INT8U k = nbits;
	while (k > 0)
    44c2:	c4 93 00 00 	tst.b	0(r4)		;0x0000(r4)
    44c6:	c4 23       	jnz	$-118    	;abs 0x4450
		}
		--k;
	}

	// Three state gate : disable output
	CS_ON;
    44c8:	5f 42 35 00 	mov.b	&0x0035,r15	
    44cc:	7f d0 40 00 	bis.b	#64,	r15	;#0x0040
    44d0:	c2 4f 35 00 	mov.b	r15,	&0x0035	
		SEL_ON;
	} else if(target == SPI_VOL) {
		SEL_OFF;
	}*/

	return 0;
    44d4:	4f 43       	clr.b	r15		
}
    44d6:	31 52       	add	#8,	r1	;r2 As==11
    44d8:	34 41       	pop	r4		
    44da:	30 41       	ret			

000044dc <ModeStep>:
//} //----- fin de nom

//////////////////////////////////////////////////////////////////  PUBLIC
//---------------------------------------------------- Fonctions publiques

void ModeStep(INT16U event) {
    44dc:	04 12       	push	r4		
    44de:	21 83       	decd	r1		
    44e0:	04 41       	mov	r1,	r4	
    44e2:	84 4f 00 00 	mov	r15,	0(r4)	;0x0000(r4)
	switch (mode) {
    44e6:	1f 42 02 02 	mov	&0x0202,r15	
    44ea:	2f 93       	cmp	#2,	r15	;r3 As==10
    44ec:	20 24       	jz	$+66     	;abs 0x452e
    44ee:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    44f2:	05 2c       	jc	$+12     	;abs 0x44fe
    44f4:	0f 93       	tst	r15		
    44f6:	09 24       	jz	$+20     	;abs 0x450a
    44f8:	1f 93       	cmp	#1,	r15	;r3 As==01
    44fa:	13 24       	jz	$+40     	;abs 0x4522
    44fc:	33 3c       	jmp	$+104    	;abs 0x4564
    44fe:	3f 90 03 00 	cmp	#3,	r15	;#0x0003
    4502:	1c 24       	jz	$+58     	;abs 0x453c
    4504:	2f 92       	cmp	#4,	r15	;r2 As==10
    4506:	21 24       	jz	$+68     	;abs 0x454a
    4508:	2d 3c       	jmp	$+92     	;abs 0x4564
	case VEILLE:
		if(event == CMD0) {
    450a:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    450e:	03 20       	jnz	$+8      	;abs 0x4516
			mode = MR_INIT;
    4510:	92 43 02 02 	mov	#1,	&0x0202	;r3 As==01
    4514:	27 3c       	jmp	$+80     	;abs 0x4564
		} else if (event == CMD1) {
    4516:	94 93 00 00 	cmp	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    451a:	1d 20       	jnz	$+60     	;abs 0x4556
			mode = MS;
    451c:	a2 42 02 02 	mov	#4,	&0x0202	;r2 As==10
    4520:	21 3c       	jmp	$+68     	;abs 0x4564
		}
		break;
	case MR_INIT:
		if(event == MR_INIT_ACK) {
    4522:	a4 92 00 00 	cmp	#4,	0(r4)	;r2 As==10, 0x0000(r4)
    4526:	19 20       	jnz	$+52     	;abs 0x455a
			mode = MR;
    4528:	a2 43 02 02 	mov	#2,	&0x0202	;r3 As==10
    452c:	1b 3c       	jmp	$+56     	;abs 0x4564
		}
		break;
	case MR:
		if(event == CMD0) {
    452e:	84 93 00 00 	tst	0(r4)		;0x0000(r4)
    4532:	15 20       	jnz	$+44     	;abs 0x455e
			mode = MR_FIN;
    4534:	b2 40 03 00 	mov	#3,	&0x0202	;#0x0003
    4538:	02 02 
    453a:	14 3c       	jmp	$+42     	;abs 0x4564
		}
		break;
	case MR_FIN:
		if(event == MR_FIN_ACK) {
    453c:	b4 90 05 00 	cmp	#5,	0(r4)	;#0x0005, 0x0000(r4)
    4540:	00 00 
    4542:	0f 20       	jnz	$+32     	;abs 0x4562
			mode = VEILLE;
    4544:	82 43 02 02 	mov	#0,	&0x0202	;r3 As==00
    4548:	0d 3c       	jmp	$+28     	;abs 0x4564
		}
		break;
	case MS:
		if(event == CMD1) {
    454a:	94 93 00 00 	cmp	#1,	0(r4)	;r3 As==01, 0x0000(r4)
    454e:	0a 20       	jnz	$+22     	;abs 0x4564
			mode = VEILLE;
    4550:	82 43 02 02 	mov	#0,	&0x0202	;r3 As==00
    4554:	07 3c       	jmp	$+16     	;abs 0x4564
		if(event == CMD0) {
			mode = MR_INIT;
		} else if (event == CMD1) {
			mode = MS;
		}
		break;
    4556:	03 43       	nop			
    4558:	05 3c       	jmp	$+12     	;abs 0x4564
	case MR_INIT:
		if(event == MR_INIT_ACK) {
			mode = MR;
		}
		break;
    455a:	03 43       	nop			
    455c:	03 3c       	jmp	$+8      	;abs 0x4564
	case MR:
		if(event == CMD0) {
			mode = MR_FIN;
		}
		break;
    455e:	03 43       	nop			
    4560:	01 3c       	jmp	$+4      	;abs 0x4564
	case MR_FIN:
		if(event == MR_FIN_ACK) {
			mode = VEILLE;
		}
		break;
    4562:	03 43       	nop			
		}
		break;
	default:
		break;
	}
}
    4564:	21 53       	incd	r1		
    4566:	34 41       	pop	r4		
    4568:	30 41       	ret			

0000456a <GestionMode>:


void GestionMode(void *parg) {
    456a:	04 12       	push	r4		
    456c:	31 50 f4 ff 	add	#-12,	r1	;#0xfff4
    4570:	04 41       	mov	r1,	r4	
    4572:	84 4f 0a 00 	mov	r15,	10(r4)	;0x000a(r4)

		OS_EVENT *msgQServiceOutput = (OS_EVENT*) parg;
    4576:	94 44 0a 00 	mov	10(r4),	2(r4)	;0x000a(r4), 0x0002(r4)
    457a:	02 00 
		INT8U err;
		ServiceMsg data;

		for(;;) {

			data.serviceType = SERV_LCD;
    457c:	b4 40 03 00 	mov	#3,	4(r4)	;#0x0003, 0x0004(r4)
    4580:	04 00 
			data.val = 33;
    4582:	b4 40 21 00 	mov	#33,	6(r4)	;#0x0021, 0x0006(r4)
    4586:	06 00 

			err = OSQPost (msgQServiceOutput, (void *)&data);
    4588:	0e 44       	mov	r4,	r14	
    458a:	2e 52       	add	#4,	r14	;r2 As==10
    458c:	1f 44 02 00 	mov	2(r4),	r15	;0x0002(r4)
    4590:	b0 12 f4 2e 	call	#0x2ef4	
    4594:	c4 4f 00 00 	mov.b	r15,	0(r4)	;0x0000(r4)
			STATUS_LED_ON;
    4598:	5f 42 29 00 	mov.b	&0x0029,r15	
    459c:	6f c3       	bic.b	#2,	r15	;r3 As==10
    459e:	c2 4f 29 00 	mov.b	r15,	&0x0029	
			OSTimeDly(2*OS_TICKS_PER_SEC);
    45a2:	3f 40 c8 00 	mov	#200,	r15	;#0x00c8
    45a6:	b0 12 4e 3a 	call	#0x3a4e	
			STATUS_LED_OFF;
    45aa:	5f 42 29 00 	mov.b	&0x0029,r15	
    45ae:	6f d3       	bis.b	#2,	r15	;r3 As==10
    45b0:	c2 4f 29 00 	mov.b	r15,	&0x0029	
    45b4:	e3 3f       	jmp	$-56     	;abs 0x457c

000045b6 <_unexpected_>:
    45b6:	00 13       	reti			

000045b8 <__udivmodsi4>:
    45b8:	0f ef       	xor	r15,	r15	
    45ba:	0e ee       	xor	r14,	r14	
    45bc:	39 40 21 00 	mov	#33,	r9	;#0x0021
    45c0:	0a 3c       	jmp	$+22     	;abs 0x45d6
    45c2:	08 10       	rrc	r8		
    45c4:	0e 6e       	rlc	r14		
    45c6:	0f 6f       	rlc	r15		
    45c8:	0f 9b       	cmp	r11,	r15	
    45ca:	05 28       	jnc	$+12     	;abs 0x45d6
    45cc:	02 20       	jnz	$+6      	;abs 0x45d2
    45ce:	0e 9a       	cmp	r10,	r14	
    45d0:	02 28       	jnc	$+6      	;abs 0x45d6
    45d2:	0e 8a       	sub	r10,	r14	
    45d4:	0f 7b       	subc	r11,	r15	
    45d6:	0c 6c       	rlc	r12		
    45d8:	0d 6d       	rlc	r13		
    45da:	08 68       	rlc	r8		
    45dc:	19 83       	dec	r9		
    45de:	f1 23       	jnz	$-28     	;abs 0x45c2
    45e0:	30 41       	ret			

000045e2 <__divmodsi4>:
    45e2:	08 43       	clr	r8		
    45e4:	3d b0 00 80 	bit	#-32768,r13	;#0x8000
    45e8:	05 24       	jz	$+12     	;abs 0x45f4
    45ea:	3d e3       	inv	r13		
    45ec:	3c e3       	inv	r12		
    45ee:	1c 53       	inc	r12		
    45f0:	0d 63       	adc	r13		
    45f2:	28 d2       	bis	#4,	r8	;r2 As==10
    45f4:	3b b0 00 80 	bit	#-32768,r11	;#0x8000
    45f8:	05 24       	jz	$+12     	;abs 0x4604
    45fa:	3b e3       	inv	r11		
    45fc:	3a e3       	inv	r10		
    45fe:	1a 53       	inc	r10		
    4600:	0b 63       	adc	r11		
    4602:	38 d2       	bis	#8,	r8	;r2 As==11
    4604:	b0 12 b8 45 	call	#0x45b8	
    4608:	08 10       	rrc	r8		
    460a:	28 b2       	bit	#4,	r8	;r2 As==10
    460c:	08 24       	jz	$+18     	;abs 0x461e
    460e:	3e e3       	inv	r14		
    4610:	3f e3       	inv	r15		
    4612:	1e 53       	inc	r14		
    4614:	0f 63       	adc	r15		
    4616:	3c e3       	inv	r12		
    4618:	3d e3       	inv	r13		
    461a:	1c 53       	inc	r12		
    461c:	0d 63       	adc	r13		
    461e:	38 b2       	bit	#8,	r8	;r2 As==11
    4620:	04 24       	jz	$+10     	;abs 0x462a
    4622:	3c e3       	inv	r12		
    4624:	3d e3       	inv	r13		
    4626:	1c 53       	inc	r12		
    4628:	0d 63       	adc	r13		
    462a:	30 41       	ret			

0000462c <__stop_progExec__>:
    462c:	ff 3f       	jmp	$+0      	;abs 0x462c

Disassembly of section .vectors:

0000ffe0 <InterruptVectors>:
    ffe0:	30 11 ae 12 30 11 30 11 4e 12 30 11 70 13 30 11     0...0.0.N.0.p.0.
    fff0:	30 11 30 11 30 11 30 11 30 11 30 11 30 11 00 11     0.0.0.0.0.0.0...
